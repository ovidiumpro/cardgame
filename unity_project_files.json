{"files":[
  {
    "fileName": "Command.cs",
    "relativeFilePath": "Assets/Scripts/Commands/Command.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using System.Collections.Generic;" +"" +"public class Command" +"{" +"    public static Queue<Command> CommandQueue = new Queue<Command>();" +"    public static bool playingQueue = false;" +"" +"    public virtual void AddToQueue()" +"    {" +"        CommandQueue.Enqueue(this);" +"        if (!playingQueue) {" +"            Debug.Log(\"Playing command from AddToQueue\");" +"            PlayFirstCommandFromQueue();" +"        }" +"            " +"    }" +"" +"    public virtual void StartCommandExecution()" +"    {" +"        // list of everything that we have to do with this command (draw a card, play a card, play spell effect, etc...)" +"        // there are 2 options of timing : " +"        // 1) use tween sequences and call CommandExecutionComplete in OnComplete()" +"        // 2) use coroutines (IEnumerator) and WaitFor... to introduce delays, call CommandExecutionComplete() in the end of coroutine" +"    }" +"" +"    public static void CommandExecutionComplete()" +"    {" +"        if (CommandQueue.Count > 0) {" +"            Debug.Log(\"Playing command from ExecComplete\");" +"            PlayFirstCommandFromQueue();" +"        }" +"            " +"        else" +"            playingQueue = false;" +"        if (TurnManager.Instance.whoseTurn != null)" +"            TurnManager.Instance.whoseTurn.HighlightPlayableCards();" +"    }" +"" +"    public static void PlayFirstCommandFromQueue()" +"    {" +"        playingQueue = true;" +"        Command c = CommandQueue.Dequeue();" +"        c.StartCommandExecution();" +"    }" +"" +"    public static bool CardDrawPending()" +"    {" +"        foreach (Command c in CommandQueue)" +"        {" +"            if (c is DrawACardCommand)" +"                return true;" +"        }" +"        return false;" +"    }" +"}" 
  }
,
  {
    "fileName": "CreatureAttackCommand.cs",
    "relativeFilePath": "Assets/Scripts/Commands/CreatureAttackCommand.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class CreatureAttackCommand : Command " +"{" +"    // position of creature on enemy\`s table that will be attacked" +"    // if enemyindex == -1 , attack an enemy character " +"    private int TargetUniqueID;" +"    private int AttackerUniqueID;" +"    private int AttackerHealthAfter;" +"    private int TargetHealthAfter;" +"    private int DamageTakenByAttacker;" +"    private int DamageTakenByTarget;" +"" +"    public CreatureAttackCommand(int targetID, int attackerID, int damageTakenByAttacker, int damageTakenByTarget, int attackerHealthAfter, int targetHealthAfter)" +"    {" +"        this.TargetUniqueID = targetID;" +"        this.AttackerUniqueID = attackerID;" +"        this.AttackerHealthAfter = attackerHealthAfter;" +"        this.TargetHealthAfter = targetHealthAfter;" +"        this.DamageTakenByTarget = damageTakenByTarget;" +"        this.DamageTakenByAttacker = damageTakenByAttacker;" +"    }" +"" +"    public override void StartCommandExecution()" +"    {" +"        GameObject Attacker = IDHolder.GetGameObjectWithID(AttackerUniqueID);" +"" +"        //Debug.Log(TargetUniqueID);" +"        Attacker.GetComponent<CreatureAttackVisual>().AttackTarget(TargetUniqueID, DamageTakenByTarget, DamageTakenByAttacker, AttackerHealthAfter, TargetHealthAfter);" +"    }" +"}" 
  }
,
  {
    "fileName": "CreatureDieCommand.cs",
    "relativeFilePath": "Assets/Scripts/Commands/CreatureDieCommand.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class CreatureDieCommand : Command " +"{" +"    private Player p;" +"    private int DeadCreatureID;" +"" +"    public CreatureDieCommand(int CreatureID, Player p)" +"    {" +"        this.p = p;" +"        this.DeadCreatureID = CreatureID;" +"    }" +"" +"    public override void StartCommandExecution()" +"    {" +"        p.PArea.tableVisual.RemoveCreatureWithID(DeadCreatureID);" +"    }" +"}" 
  }
,
  {
    "fileName": "DealDamageCommand.cs",
    "relativeFilePath": "Assets/Scripts/Commands/DealDamageCommand.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class DealDamageCommand : Command {" +"" +"    private int targetID;" +"    private int amount;" +"    private int healthAfter;" +"" +"    public DealDamageCommand( int targetID, int amount, int healthAfter)" +"    {" +"        this.targetID = targetID;" +"        this.amount = amount;" +"        this.healthAfter = healthAfter;" +"    }" +"" +"    public override void StartCommandExecution()" +"    {" +"        Debug.Log(\"In deal damage command!\");" +"" +"        GameObject target = IDHolder.GetGameObjectWithID(targetID);" +"        if (targetID == GlobalSettings.Instance.LowPlayer.PlayerID || targetID == GlobalSettings.Instance.TopPlayer.PlayerID)" +"        {" +"            // target is a hero" +"            target.GetComponent<PlayerPortraitVisual>().TakeDamage(amount,healthAfter);" +"        }" +"        else" +"        {" +"            // target is a creature" +"            target.GetComponent<OneCreatureManager>().TakeDamage(amount, healthAfter);" +"        }" +"        CommandExecutionComplete();" +"    }" +"}" 
  }
,
  {
    "fileName": "DelayCommand.cs",
    "relativeFilePath": "Assets/Scripts/Commands/DelayCommand.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using DG.Tweening;" +"" +"public class DelayCommand : Command " +"{" +"    float delay;" +"" +"    public DelayCommand(float timeToWait)" +"    {" +"        delay = timeToWait;    " +"    }" +"" +"    public override void StartCommandExecution()" +"    {" +"        Sequence s = DOTween.Sequence();" +"        s.PrependInterval(delay);" +"        s.OnComplete(Command.CommandExecutionComplete);" +"    }" +"}" 
  }
,
  {
    "fileName": "DrawACardCommand.cs",
    "relativeFilePath": "Assets/Scripts/Commands/DrawACardCommand.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using CG.Cards;" +"public class DrawACardCommand : Command {" +"    // first argument" +"    // \"1\" - fast" +"    // \"0\" - normal" +"" +"    private Player p;" +"    private int handPos;" +"    private CardLogic cl;" +"    private bool fast;" +"    private int ID;" +"    private bool fromDeck;" +"    private int testTracker;" +"" +"    public DrawACardCommand(CardLogic cl, Player p, int positionInHand, bool fast, bool fromDeck, int testTracker)" +"    {        " +"        this.cl = cl;" +"        this.p = p;" +"        handPos = positionInHand;" +"        this.fast = fast;" +"        this.fromDeck = fromDeck;" +"        this.testTracker = testTracker;" +"    }" +"" +"    public override void StartCommandExecution()" +"    {" +"        Debug.Log(\"Starting command: \" + this.testTracker);" +"        p.PArea.PDeck.CardsInDeck--;" +"        p.PArea.handVisual.GivePlayerACard(cl.ca, cl.UniqueCardID, fast, fromDeck);" +"    }" +"}" 
  }
,
  {
    "fileName": "GameOverCommand.cs",
    "relativeFilePath": "Assets/Scripts/Commands/GameOverCommand.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class GameOverCommand : Command{" +"" +"    private Player looser;" +"" +"    public GameOverCommand(Player looser)" +"    {" +"        this.looser = looser;" +"    }" +"" +"    public override void StartCommandExecution()" +"    {" +"        looser.PArea.Portrait.Explode();" +"    }" +"}" 
  }
,
  {
    "fileName": "PlayACreatureCommand.cs",
    "relativeFilePath": "Assets/Scripts/Commands/PlayACreatureCommand.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class PlayACreatureCommand : Command" +"{" +"    private CardLogic cl;" +"    private int tablePos;" +"    private Player p;" +"    private int creatureID;" +"" +"    public PlayACreatureCommand(CardLogic cl, Player p, int tablePos, int creatureID)" +"    {" +"        this.p = p;" +"        this.cl = cl;" +"        this.tablePos = tablePos;" +"        this.creatureID = creatureID;" +"    }" +"" +"    public override void StartCommandExecution()" +"    {" +"        // remove and destroy the card in hand " +"        HandVisual PlayerHand = p.PArea.handVisual;" +"        GameObject card = IDHolder.GetGameObjectWithID(cl.UniqueCardID);" +"        PlayerHand.RemoveCard(card);" +"        GameObject.Destroy(card);" +"        // enable Hover Previews Back" +"        HoverPreview.PreviewsAllowed = true;" +"        // move this card to the spot " +"        p.PArea.tableVisual.AddCreatureAtIndex(cl.ca, creatureID, tablePos);" +"    }" +"}" 
  }
,
  {
    "fileName": "PlayASpellCardCommand.cs",
    "relativeFilePath": "Assets/Scripts/Commands/PlayASpellCardCommand.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class PlayASpellCardCommand: Command" +"{" +"    private CardLogic card;" +"    private Player p;" +"    //private ICharacter target;" +"" +"    public PlayASpellCardCommand(Player p, CardLogic card)" +"    {" +"        this.card = card;" +"        this.p = p;" +"    }" +"" +"    public override void StartCommandExecution()" +"    {" +"        // move this card to the spot" +"        p.PArea.handVisual.PlayASpellFromHand(card.UniqueCardID);" +"        // do all the visual stuff (for each spell separately????)" +"    }" +"}" 
  }
,
  {
    "fileName": "ShowMessageCommand.cs",
    "relativeFilePath": "Assets/Scripts/Commands/ShowMessageCommand.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using System;" +"" +"public class ShowMessageCommand : Command {" +"" +"    string message;" +"    float duration;" +"" +"    public ShowMessageCommand(string message, float duration)" +"    {" +"        this.message = message;" +"        this.duration = duration;" +"    }" +"" +"    public override void StartCommandExecution()" +"    {" +"        MessageManager.Instance.ShowMessage(message, duration);" +"    }" +"}" 
  }
,
  {
    "fileName": "StartATurnCommand.cs",
    "relativeFilePath": "Assets/Scripts/Commands/StartATurnCommand.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class StartATurnCommand : Command {" +"" +"    private Player p;" +"" +"    public StartATurnCommand(Player p)" +"    {" +"        this.p = p;" +"    }" +"" +"    public override void StartCommandExecution()" +"    {" +"        TurnManager.Instance.whoseTurn = p;" +"        // this command is completed instantly" +"        CommandExecutionComplete();" +"    }" +"}" 
  }
,
  {
    "fileName": "UpdateManaCrystalsCommand.cs",
    "relativeFilePath": "Assets/Scripts/Commands/UpdateManaCrystalsCommand.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class UpdateManaCrystalsCommand : Command {" +"" +"    private Player p;" +"    private int TotalMana;" +"    private int AvailableMana;" +"" +"    public UpdateManaCrystalsCommand(Player p, int TotalMana, int AvailableMana)" +"    {" +"        this.p = p;" +"        this.TotalMana = TotalMana;" +"        this.AvailableMana = AvailableMana;" +"    }" +"" +"    public override void StartCommandExecution()" +"    {" +"        p.PArea.ManaBar.TotalCrystals = TotalMana;" +"        p.PArea.ManaBar.AvailableCrystals = AvailableMana;" +"        CommandExecutionComplete();" +"    }" +"}" 
  }
,
  {
    "fileName": "DragCreatureAttack.cs",
    "relativeFilePath": "Assets/Scripts/Dragging/DragCreatureAttack.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class DragCreatureAttack : DraggingActions {" +"" +"    // reference to the sprite with a round \"Target\" graphic" +"    private SpriteRenderer sr;" +"    // LineRenderer that is attached to a child game object to draw the arrow" +"    private LineRenderer lr;" +"    // reference to WhereIsTheCardOrCreature to track this object\`s state in the game" +"    private WhereIsTheCardOrCreature whereIsThisCreature;" +"    // the pointy end of the arrow, should be called \"Triangle\" in the Hierarchy" +"    private Transform triangle;" +"    // SpriteRenderer of triangle. We need this to disable the pointy end if the target is too close." +"    private SpriteRenderer triangleSR;" +"    // when we stop dragging, the gameObject that we were targeting will be stored in this variable." +"    private GameObject Target;" +"    // Reference to creature manager, attached to the parent game object" +"    private OneCreatureManager manager;" +"" +"    void Awake()" +"    {" +"        // establish all the connections" +"        sr = GetComponent<SpriteRenderer>();" +"        lr = GetComponentInChildren<LineRenderer>();" +"        lr.sortingLayerName = \"AboveEverything\";" +"        triangle = transform.Find(\"Triangle\");" +"        triangleSR = triangle.GetComponent<SpriteRenderer>();" +"" +"        manager = GetComponentInParent<OneCreatureManager>();" +"        whereIsThisCreature = GetComponentInParent<WhereIsTheCardOrCreature>();" +"    }" +"" +"    public override bool CanDrag" +"    {" +"        get" +"        {   " +"            // we can drag this card if " +"            // a) we can control this our player (this is checked in base.canDrag)" +"            // b) creature \"CanAttackNow\" - this info comes from logic part of our code into each creature\`s manager script" +"            return base.CanDrag && manager.CanAttackNow;" +"        }" +"    }" +"" +"    public override void OnStartDrag()" +"    {" +"        whereIsThisCreature.VisualState = VisualStates.Dragging;" +"        // enable target graphic" +"        sr.enabled = true;" +"        // enable line renderer to start drawing the line." +"        lr.enabled = true;" +"    }" +"" +"    public override void OnDraggingInUpdate()" +"    {" +"        Vector3 notNormalized = transform.position - transform.parent.position;" +"        Vector3 direction = notNormalized.normalized;" +"        float distanceToTarget = (direction*2.3f).magnitude;" +"        if (notNormalized.magnitude > distanceToTarget)" +"        {" +"            // draw a line between the creature and the target" +"            lr.SetPositions(new Vector3[]{ transform.parent.position, transform.position - direction*2.3f });" +"            lr.enabled = true;" +"" +"            // position the end of the arrow between near the target." +"            triangleSR.enabled = true;" +"            triangleSR.transform.position = transform.position - 1.5f*direction;" +"" +"            // proper rotarion of arrow end" +"            float rot_z = Mathf.Atan2(notNormalized.y, notNormalized.x) * Mathf.Rad2Deg;" +"            triangleSR.transform.rotation = Quaternion.Euler(0f, 0f, rot_z - 90);" +"        }" +"        else" +"        {" +"            // if the target is not far enough from creature, do not show the arrow" +"            lr.enabled = false;" +"            triangleSR.enabled = false;" +"        }" +"            " +"    }" +"" +"    public override void OnEndDrag()" +"    {" +"        Target = null;" +"        RaycastHit[] hits;" +"        // TODO: raycast here anyway, store the results in " +"        hits = Physics.RaycastAll(origin: Camera.main.transform.position, " +"            direction: (-Camera.main.transform.position + this.transform.position).normalized, " +"            maxDistance: 30f) ;" +"" +"        foreach (RaycastHit h in hits)" +"        {" +"            if ((h.transform.tag == \"TopPlayer\" && this.tag == \"LowCreature\") ||" +"                (h.transform.tag == \"LowPlayer\" && this.tag == \"TopCreature\"))" +"            {" +"                // go face" +"                Target = h.transform.gameObject;" +"            }" +"            else if ((h.transform.tag == \"TopCreature\" && this.tag == \"LowCreature\") ||" +"                    (h.transform.tag == \"LowCreature\" && this.tag == \"TopCreature\"))" +"            {" +"                // hit a creature, save parent transform" +"                Target = h.transform.parent.gameObject;" +"            }" +"               " +"        }" +"" +"        bool targetValid = false;" +"" +"        if (Target != null)" +"        {" +"            int targetID = Target.GetComponent<IDHolder>().UniqueID;" +"            Debug.Log(\"Target ID: \" + targetID);" +"            if (targetID == GlobalSettings.Instance.LowPlayer.PlayerID || targetID == GlobalSettings.Instance.TopPlayer.PlayerID)" +"            {" +"                // attack character" +"                Debug.Log(\"Attacking \"+Target);" +"                Debug.Log(\"TargetID: \" + targetID);" +"                CreatureLogic.CreaturesCreatedThisGame[GetComponentInParent<IDHolder>().UniqueID].GoFace();" +"                targetValid = true;" +"            }" +"            else if (CreatureLogic.CreaturesCreatedThisGame[targetID] != null)" +"            {" +"                // if targeted creature is still alive, attack creature" +"                targetValid = true;" +"                CreatureLogic.CreaturesCreatedThisGame[GetComponentInParent<IDHolder>().UniqueID].AttackCreatureWithID(targetID);" +"                Debug.Log(\"Attacking \"+Target);" +"            }" +"                " +"        }" +"" +"        if (!targetValid)" +"        {" +"            // not a valid target, return" +"            whereIsThisCreature.VisualState = VisualStates.LowTable;" +"            whereIsThisCreature.SetTableSortingOrder();" +"        }" +"" +"        // return target and arrow to original position" +"        transform.localPosition = Vector3.zero;" +"        sr.enabled = false;" +"        lr.enabled = false;" +"        triangleSR.enabled = false;" +"" +"    }" +"" +"    // NOT USED IN THIS SCRIPT" +"    protected override bool DragSuccessful()" +"    {" +"        return true;" +"    }" +"}" 
  }
,
  {
    "fileName": "DragCreatureOnTable.cs",
    "relativeFilePath": "Assets/Scripts/Dragging/DragCreatureOnTable.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using DG.Tweening;" +"" +"public class DragCreatureOnTable : DraggingActions {" +"" +"    private int savedHandSlot;" +"    private WhereIsTheCardOrCreature whereIsCard;" +"    private IDHolder idScript;" +"    private VisualStates tempState;" +"    private OneCardManager manager;" +"" +"    public override bool CanDrag" +"    {" +"        get" +"        { " +"            // TODO : include full field check" +"            return base.CanDrag && manager.CanBePlayedNow;" +"        }" +"    }" +"" +"    void Awake()" +"    {" +"        whereIsCard = GetComponent<WhereIsTheCardOrCreature>();" +"        manager = GetComponent<OneCardManager>();" +"    }" +"" +"    public override void OnStartDrag()" +"    {" +"        savedHandSlot = whereIsCard.Slot;" +"        tempState = whereIsCard.VisualState;" +"        whereIsCard.VisualState = VisualStates.Dragging;" +"        whereIsCard.BringToFront();" +"" +"    }" +"" +"    public override void OnDraggingInUpdate()" +"    {" +"" +"    }" +"" +"    public override void OnEndDrag()" +"    {" +"        " +"        // 1) Check if we are holding a card over the table" +"        if (DragSuccessful())" +"        {" +"            // determine table position" +"            int tablePos = playerOwner.PArea.tableVisual.TablePosForNewCreature(Camera.main.ScreenToWorldPoint(" +"                new Vector3(Input.mousePosition.x, Input.mousePosition.y, transform.position.z - Camera.main.transform.position.z)).x);" +"            // Debug.Log(\"Table Pos for new Creature: \" + tablePos.ToString());" +"            // play this card" +"            playerOwner.PlayACreatureFromHand(GetComponent<IDHolder>().UniqueID, tablePos);" +"        }" +"        else" +"        {" +"            // Set old sorting order " +"            whereIsCard.SetHandSortingOrder();" +"            whereIsCard.VisualState = tempState;" +"            // Move this card back to its slot position" +"            HandVisual PlayerHand = playerOwner.PArea.handVisual;" +"            Vector3 oldCardPos = PlayerHand.slots.Children[savedHandSlot].transform.localPosition;" +"            transform.DOLocalMove(oldCardPos, 1f);" +"        } " +"    }" +"" +"    protected override bool DragSuccessful()" +"    {" +"        bool TableNotFull = (playerOwner.table.CreaturesOnTable.Count < 8);" +"" +"        return TableVisual.CursorOverSomeTable && TableNotFull;" +"    }" +"}" 
  }
,
  {
    "fileName": "Draggable.cs",
    "relativeFilePath": "Assets/Scripts/Dragging/Draggable.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using DG.Tweening;" +"" +"/// <summary>" +"/// This class enables Drag and Drop Behaviour for the game object it is attached to. " +"/// It uses other script - DraggingActions to determine whether we can drag this game object now or not and " +"/// whether the drop was successful or not." +"/// </summary>" +"" +"public class Draggable : MonoBehaviour {" +"" +"    // PRIVATE FIELDS" +"" +"    // a flag to know if we are currently dragging this GameObject" +"    private bool dragging = false;" +"" +"    // distance from the center of this Game Object to the point where we clicked to start dragging " +"    private Vector3 pointerDisplacement;" +"" +"    // distance from camera to mouse on Z axis " +"    private float zDisplacement;" +"" +"    // reference to DraggingActions script. Dragging Actions should be attached to the same GameObject." +"    private DraggingActions da;" +"" +"    // STATIC property that returns the instance of Draggable that is currently being dragged" +"    private static Draggable _draggingThis;" +"    public static Draggable DraggingThis" +"    {" +"        get{ return _draggingThis;}" +"    }" +"" +"    // MONOBEHAVIOUR METHODS" +"    void Awake()" +"    {" +"        da = GetComponent<DraggingActions>();" +"    }" +"" +"    void OnMouseDown()" +"    {" +"        if (da!=null && da.CanDrag)" +"        {" +"            dragging = true;" +"            // when we are dragging something, all previews should be off" +"            HoverPreview.PreviewsAllowed = false;" +"            _draggingThis = this;" +"            da.OnStartDrag();" +"            zDisplacement = -Camera.main.transform.position.z + transform.position.z;" +"            pointerDisplacement = -transform.position + MouseInWorldCoords();" +"        }" +"    }" +"" +"    // Update is called once per frame" +"    void Update ()" +"    {" +"        if (dragging)" +"        { " +"            Vector3 mousePos = MouseInWorldCoords();" +"            //Debug.Log(mousePos);" +"            transform.position = new Vector3(mousePos.x - pointerDisplacement.x, mousePos.y - pointerDisplacement.y, transform.position.z);   " +"            da.OnDraggingInUpdate();" +"        }" +"    }" +"	" +"    void OnMouseUp()" +"    {" +"        if (dragging)" +"        {" +"            dragging = false;" +"            // turn all previews back on" +"            HoverPreview.PreviewsAllowed = true;" +"            _draggingThis = null;" +"            da.OnEndDrag();" +"        }" +"    }   " +"" +"    // returns mouse position in World coordinates for our GameObject to follow. " +"    private Vector3 MouseInWorldCoords()" +"    {" +"        var screenMousePos = Input.mousePosition;" +"        //Debug.Log(screenMousePos);" +"        screenMousePos.z = zDisplacement;" +"        return Camera.main.ScreenToWorldPoint(screenMousePos);" +"    }" +"        " +"}" 
  }
,
  {
    "fileName": "DraggingActions.cs",
    "relativeFilePath": "Assets/Scripts/Dragging/DraggingActions.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public abstract class DraggingActions : MonoBehaviour {" +"" +"    public abstract void OnStartDrag();" +"" +"    public abstract void OnEndDrag();" +"" +"    public abstract void OnDraggingInUpdate();" +"" +"    public virtual bool CanDrag" +"    {" +"        get" +"        {            " +"            return GlobalSettings.Instance.CanControlThisPlayer(playerOwner);" +"        }" +"    }" +"" +"    protected virtual Player playerOwner" +"    {" +"        get{" +"            " +"            if (tag.Contains(\"Low\"))" +"                return GlobalSettings.Instance.LowPlayer;" +"            else if (tag.Contains(\"Top\"))" +"                return GlobalSettings.Instance.TopPlayer;" +"            else" +"            {" +"                Debug.LogError(\"Untagged Card or creature \" + transform.parent.name);" +"                return null;" +"            }" +"        }" +"    }" +"" +"    protected abstract bool DragSuccessful();" +"}" 
  }
,
  {
    "fileName": "DraggableTest.cs",
    "relativeFilePath": "Assets/Scripts/Dragging/DraggingTest/DraggableTest.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class DraggableTest : MonoBehaviour " +"{" +"    public bool UsePointerDisplacement = true;" +"    // PRIVATE FIELDS" +"    // a flag to know if we are currently dragging this GameObject" +"    private bool dragging = false;" +"" +"    // distance from the center of this Game Object to the point where we clicked to start dragging " +"    private Vector3 pointerDisplacement = Vector3.zero;" +"" +"    // distance from camera to mouse on Z axis " +"    private float zDisplacement;" +"" +"    // MONOBEHAVIOUR METHODS" +"    void OnMouseDown()" +"    {" +"        dragging = true;" +"        zDisplacement = -Camera.main.transform.position.z + transform.position.z;" +"        if (UsePointerDisplacement)" +"            pointerDisplacement = -transform.position + MouseInWorldCoords();" +"        else" +"            pointerDisplacement = Vector3.zero;" +"    }" +"" +"    // Update is called once per frame" +"    void Update ()" +"    {" +"        if (dragging)" +"        { " +"            Vector3 mousePos = MouseInWorldCoords();" +"            //Debug.Log(mousePos);" +"            transform.position = new Vector3(mousePos.x - pointerDisplacement.x, mousePos.y - pointerDisplacement.y, transform.position.z);   " +"        }" +"    }" +"" +"    void OnMouseUp()" +"    {" +"        if (dragging)" +"        {" +"            dragging = false;" +"        }" +"    }   " +"" +"    // returns mouse position in World coordinates for our GameObject to follow. " +"    private Vector3 MouseInWorldCoords()" +"    {" +"        var screenMousePos = Input.mousePosition;" +"        //Debug.Log(screenMousePos);" +"        screenMousePos.z = zDisplacement;" +"        return Camera.main.ScreenToWorldPoint(screenMousePos);" +"    }" +"" +"}" 
  }
,
  {
    "fileName": "DraggableTestWithActions.cs",
    "relativeFilePath": "Assets/Scripts/Dragging/DraggingTest/DraggableTestWithActions.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class DraggableTestWithActions : MonoBehaviour {" +"" +"    public bool UsePointerDisplacement = true;" +"    // PRIVATE FIELDS" +"    // a reference to a DraggingActionsTest script" +"    private DraggingActionsTest da;" +"" +"    // a flag to know if we are currently dragging this GameObject" +"    private bool dragging = false;" +"" +"    // distance from the center of this Game Object to the point where we clicked to start dragging " +"    private Vector3 pointerDisplacement = Vector3.zero;" +"" +"    // distance from camera to mouse on Z axis " +"    private float zDisplacement;" +"" +"    // MONOBEHAVIOUR METHODS" +"    void Awake()" +"    {" +"        da = GetComponent<DraggingActionsTest>();" +"    }" +"" +"    void OnMouseDown()" +"    {" +"        if (da.CanDrag)" +"        {" +"            dragging = true;" +"            HoverPreview.PreviewsAllowed = false;" +"            da.OnStartDrag();" +"            zDisplacement = -Camera.main.transform.position.z + transform.position.z;" +"            if (UsePointerDisplacement)" +"                pointerDisplacement = -transform.position + MouseInWorldCoords();" +"            else" +"                pointerDisplacement = Vector3.zero;" +"        }" +"    }" +"" +"    // Update is called once per frame" +"    void Update ()" +"    {" +"        if (dragging)" +"        { " +"            Vector3 mousePos = MouseInWorldCoords();" +"            da.OnDraggingInUpdate();" +"            //Debug.Log(mousePos);" +"            transform.position = new Vector3(mousePos.x - pointerDisplacement.x, mousePos.y - pointerDisplacement.y, transform.position.z);   " +"        }" +"    }" +"" +"    void OnMouseUp()" +"    {" +"        if (dragging)" +"        {" +"            dragging = false;" +"            HoverPreview.PreviewsAllowed = true;" +"            da.OnEndDrag();" +"        }" +"    }   " +"" +"    // returns mouse position in World coordinates for our GameObject to follow. " +"    private Vector3 MouseInWorldCoords()" +"    {" +"        var screenMousePos = Input.mousePosition;" +"        //Debug.Log(screenMousePos);" +"        screenMousePos.z = zDisplacement;" +"        return Camera.main.ScreenToWorldPoint(screenMousePos);" +"    }" +"}" 
  }
,
  {
    "fileName": "DraggingActionsTest.cs",
    "relativeFilePath": "Assets/Scripts/Dragging/DraggingTest/DraggingActionsTest.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public abstract class DraggingActionsTest : MonoBehaviour {" +"" +"    public abstract void OnStartDrag();" +"" +"    public abstract void OnEndDrag();" +"" +"    public abstract void OnDraggingInUpdate();" +"" +"    public virtual bool CanDrag" +"    {" +"        get" +"        {            " +"            return true;" +"        }" +"    }" +"" +"    protected abstract bool DragSuccessful();" +"}" 
  }
,
  {
    "fileName": "DraggingActionsTestReturn.cs",
    "relativeFilePath": "Assets/Scripts/Dragging/DraggingTest/DraggingActionsTestReturn.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using DG.Tweening;" +"" +"public class DraggingActionsTestReturn : DraggingActionsTest " +"{" +"    private Vector3 savedPos;" +"" +"    public override void OnStartDrag()" +"    {" +"        savedPos = transform.position;" +"    }" +"" +"    public override void OnEndDrag()" +"    {" +"        // transform.DOMove(savedPos, 1f);" +"        // transform.DOMove(savedPos, 1f).SetEase(Ease.OutBounce, 0.5f, 0.1f);" +"        transform.DOMove(savedPos, 1f).SetEase(Ease.OutQuint);//, 0.5f, 0.1f);" +"    }" +"" +"    public override void OnDraggingInUpdate(){}" +"" +"    protected override bool DragSuccessful()" +"    {" +"        return true;" +"    }" +"}" 
  }
,
  {
    "fileName": "DragOnTargetTest.cs",
    "relativeFilePath": "Assets/Scripts/Dragging/DraggingTest/DragOnTargetTest.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using DG.Tweening;" +"using CG.Cards;" +"public class DragOnTargetTest : DraggingActionsTest" +"{" +"    public TargetingOptions Targets = TargetingOptions.AllCharacters;" +"    private SpriteRenderer sr;" +"    private LineRenderer lr;" +"    private Transform triangle;" +"    private SpriteRenderer triangleSR;" +"    private GameObject Target;" +"" +"    void Awake()" +"    {" +"        sr = GetComponent<SpriteRenderer>();" +"        lr = GetComponentInChildren<LineRenderer>();" +"        //lr.sortingLayerName = \"EverythingElse\";" +"        triangle = transform.Find(\"Triangle\");" +"        triangleSR = triangle.GetComponent<SpriteRenderer>();" +"    }" +"" +"    public override void OnStartDrag()" +"    {" +"        sr.enabled = true;" +"        lr.enabled = true;" +"    }" +"" +"    public override void OnDraggingInUpdate()" +"    {" +"        // This code only draws the arrow" +"        Vector3 notNormalized = transform.position - transform.parent.position;" +"        Vector3 direction = notNormalized.normalized;" +"        float distanceToTarget = (direction*2.3f).magnitude;" +"        if (notNormalized.magnitude > distanceToTarget)" +"        {" +"            // draw a line between the creature and the target" +"            lr.SetPositions(new Vector3[]{ transform.parent.position, transform.position - direction*2.3f });" +"            lr.enabled = true;" +"" +"            // position the end of the arrow between near the target." +"            triangleSR.enabled = true;" +"            triangleSR.transform.position = transform.position - 1.5f*direction;" +"" +"            // proper rotarion of arrow end" +"            float rot_z = Mathf.Atan2(notNormalized.y, notNormalized.x) * Mathf.Rad2Deg;" +"            triangleSR.transform.rotation = Quaternion.Euler(0f, 0f, rot_z - 90);" +"        }" +"        else" +"        {" +"            // if the target is not far enough from creature, do not show the arrow" +"            lr.enabled = false;" +"            triangleSR.enabled = false;" +"        }" +"" +"    }" +"" +"    public override void OnEndDrag()" +"    {" +"" +"        // return target and arrow to original position" +"        // this position is special for spell cards to show the arrow on top" +"        transform.localPosition = new Vector3(0f, 0f, -0.1f);" +"        sr.enabled = false;" +"        lr.enabled = false;" +"        triangleSR.enabled = false;" +"" +"    }" +"" +"    // NOT USED IN THIS SCRIPT" +"    protected override bool DragSuccessful()" +"    {" +"        return true;" +"    }" +"}" 
  }
,
  {
    "fileName": "DragHeroPowerActions.cs",
    "relativeFilePath": "Assets/Scripts/Dragging/DragHeroPowerActions.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using DG.Tweening;" +"using CG.Cards;" +"" +"public class DragHeroPowerActions : DraggingActions {" +"" +"    public TargetingOptions Options;" +"" +"    public override void OnStartDrag()" +"    {" +"       " +"    }" +"" +"    public override void OnDraggingInUpdate()" +"    {" +"" +"    }" +"" +"    public override void OnEndDrag()" +"    {" +"" +"        // 1) Check if we are holding a card over the table" +"        if (DragSuccessful())" +"        {" +"            " +"        }" +"        else" +"        {" +"            " +"        } " +"    }" +"" +"    protected override bool DragSuccessful()" +"    {" +"        bool TableNotFull = (TurnManager.Instance.whoseTurn.table.CreaturesOnTable.Count < 8);" +"" +"        return TableVisual.CursorOverSomeTable&& TableNotFull;" +"    }" +"}" 
  }
,
  {
    "fileName": "DragSpellNoTarget.cs",
    "relativeFilePath": "Assets/Scripts/Dragging/DragSpellNoTarget.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using DG.Tweening;" +"" +"public class DragSpellNoTarget: DraggingActions{" +"" +"    private int savedHandSlot;" +"    private WhereIsTheCardOrCreature whereIsCard;" +"" +"    void Awake()" +"    {" +"        whereIsCard = GetComponent<WhereIsTheCardOrCreature>();" +"    }" +"" +"    public override void OnStartDrag()" +"    {" +"        savedHandSlot = whereIsCard.Slot;" +"" +"        whereIsCard.VisualState = VisualStates.Dragging;" +"        whereIsCard.BringToFront();" +"" +"    }" +"" +"    public override void OnDraggingInUpdate()" +"    {" +"        " +"    }" +"" +"    public override void OnEndDrag()" +"    {" +"        // 1) Check if we are holding a card over the table" +"        if (DragSuccessful())" +"        {" +"            // play this card" +"            playerOwner.PlayASpellFromHand(GetComponent<IDHolder>().UniqueID, -1);" +"        }" +"        else" +"        {" +"            // Set old sorting order " +"            whereIsCard.Slot = savedHandSlot;" +"            whereIsCard.VisualState = VisualStates.LowHand;" +"            // Move this card back to its slot position" +"            HandVisual PlayerHand = TurnManager.Instance.whoseTurn.PArea.handVisual;" +"            Vector3 oldCardPos = PlayerHand.slots.Children[savedHandSlot].transform.localPosition;" +"            transform.DOLocalMove(oldCardPos, 1f);" +"        } " +"    }" +"" +"    protected override bool DragSuccessful()" +"    {" +"        //bool TableNotFull = (TurnManager.Instance.whoseTurn.table.CreaturesOnTable.Count < 8);" +"" +"        return TableVisual.CursorOverSomeTable; //&& TableNotFull;" +"    }" +"" +"" +"}" 
  }
,
  {
    "fileName": "DragSpellOnTarget.cs",
    "relativeFilePath": "Assets/Scripts/Dragging/DragSpellOnTarget.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using DG.Tweening;" +"using CG.Cards;" +"public class DragSpellOnTarget : DraggingActions {" +"" +"    public TargetingOptions Targets = TargetingOptions.AllCharacters;" +"    private SpriteRenderer sr;" +"    private LineRenderer lr;" +"    private WhereIsTheCardOrCreature whereIsThisCard;" +"    private VisualStates tempVisualState;" +"    private Transform triangle;" +"    private SpriteRenderer triangleSR;" +"    private GameObject Target;" +"" +"    void Awake()" +"    {" +"        sr = GetComponent<SpriteRenderer>();" +"        lr = GetComponentInChildren<LineRenderer>();" +"        lr.sortingLayerName = \"AboveEverything\";" +"        triangle = transform.Find(\"Triangle\");" +"        triangleSR = triangle.GetComponent<SpriteRenderer>();" +"" +"        whereIsThisCard = GetComponentInParent<WhereIsTheCardOrCreature>();" +"    }" +"" +"    public override void OnStartDrag()" +"    {" +"        tempVisualState = whereIsThisCard.VisualState;" +"        whereIsThisCard.VisualState = VisualStates.Dragging;" +"        sr.enabled = true;" +"        lr.enabled = true;" +"    }" +"" +"    public override void OnDraggingInUpdate()" +"    {" +"        // This code only draws the arrow" +"        Vector3 notNormalized = transform.position - transform.parent.position;" +"        Vector3 direction = notNormalized.normalized;" +"        float distanceToTarget = (direction*2.3f).magnitude;" +"        if (notNormalized.magnitude > distanceToTarget)" +"        {" +"            // draw a line between the creature and the target" +"            lr.SetPositions(new Vector3[]{ transform.parent.position, transform.position - direction*2.3f });" +"            lr.enabled = true;" +"" +"            // position the end of the arrow between near the target." +"            triangleSR.enabled = true;" +"            triangleSR.transform.position = transform.position - 1.5f*direction;" +"" +"            // proper rotarion of arrow end" +"            float rot_z = Mathf.Atan2(notNormalized.y, notNormalized.x) * Mathf.Rad2Deg;" +"            triangleSR.transform.rotation = Quaternion.Euler(0f, 0f, rot_z - 90);" +"        }" +"        else" +"        {" +"            // if the target is not far enough from creature, do not show the arrow" +"            lr.enabled = false;" +"            triangleSR.enabled = false;" +"        }" +"" +"    }" +"" +"    public override void OnEndDrag()" +"    {" +"        Target = null;" +"        RaycastHit[] hits;" +"        // TODO: raycast here anyway, store the results in " +"        hits = Physics.RaycastAll(origin: Camera.main.transform.position, " +"            direction: (-Camera.main.transform.position + this.transform.position).normalized, " +"            maxDistance: 30f) ;" +"" +"        foreach (RaycastHit h in hits)" +"        {" +"            if (h.transform.tag.Contains(\"Player\"))" +"            {" +"                // selected a Player" +"                Target = h.transform.gameObject;" +"            }" +"            else if (h.transform.tag.Contains(\"Creature\"))" +"            {" +"                // hit a creature, save parent transform" +"                Target = h.transform.parent.gameObject;" +"            }" +"        }" +"" +"        bool targetValid = false;" +"" +"        if (Target != null)" +"        {" +"            // determine an owner of this card" +"            Player owner = null; " +"            if (tag.Contains(\"Low\"))" +"                owner = GlobalSettings.Instance.LowPlayer;" +"            else" +"                owner = GlobalSettings.Instance.TopPlayer;" +"" +"            // check of we should play this spell depending on targeting options" +"            int targetID = Target.GetComponent<IDHolder>().UniqueID;" +"            switch (Targets)" +"            {" +"                case TargetingOptions.AllCharacters: " +"                    owner.PlayASpellFromHand(GetComponentInParent<IDHolder>().UniqueID, targetID);" +"                    targetValid = true;" +"                    break;" +"                case TargetingOptions.AllCreatures:" +"                    if (Target.tag.Contains(\"Creature\"))" +"                    {" +"                        owner.PlayASpellFromHand(GetComponentInParent<IDHolder>().UniqueID, targetID);" +"                        targetValid = true;" +"                    }" +"                    break;" +"                case TargetingOptions.EnemyCharacters:" +"                    if (Target.tag.Contains(\"Creature\") || Target.tag.Contains(\"Player\"))" +"                    {" +"                        // had to check that target is not a card" +"                        if ((tag.Contains(\"Low\") && Target.tag.Contains(\"Top\"))" +"                           || (tag.Contains(\"Top\") && Target.tag.Contains(\"Low\")))" +"                        {" +"                            owner.PlayASpellFromHand(GetComponentInParent<IDHolder>().UniqueID, targetID);" +"                            targetValid = true;" +"                        }" +"                    }" +"                    break;" +"                case TargetingOptions.EnemyCreatures:" +"                    if (Target.tag.Contains(\"Creature\"))" +"                    {" +"                        // had to check that target is not a card or a player" +"                        if ((tag.Contains(\"Low\") && Target.tag.Contains(\"Top\"))" +"                            || (tag.Contains(\"Top\") && Target.tag.Contains(\"Low\")))" +"                        {" +"                            owner.PlayASpellFromHand(GetComponentInParent<IDHolder>().UniqueID, targetID);" +"                            targetValid = true;" +"                        }" +"                    }" +"                    break;" +"                case TargetingOptions.YourCharacters:" +"                    if (Target.tag.Contains(\"Creature\") || Target.tag.Contains(\"Player\"))" +"                    {" +"                        // had to check that target is not a card" +"                        if ((tag.Contains(\"Low\") && Target.tag.Contains(\"Low\"))" +"                            || (tag.Contains(\"Top\") && Target.tag.Contains(\"Top\")))" +"                        {" +"                            owner.PlayASpellFromHand(GetComponentInParent<IDHolder>().UniqueID, targetID);" +"                            targetValid = true;" +"                        }" +"                    }" +"                    break;" +"                case TargetingOptions.YourCreatures:" +"                    if (Target.tag.Contains(\"Creature\"))" +"                    {" +"                        // had to check that target is not a card or a player" +"                        if ((tag.Contains(\"Low\") && Target.tag.Contains(\"Low\"))" +"                            || (tag.Contains(\"Top\") && Target.tag.Contains(\"Top\")))" +"                        {" +"                            owner.PlayASpellFromHand(GetComponentInParent<IDHolder>().UniqueID, targetID);" +"                            targetValid = true;" +"                        }" +"                    }" +"                    break;" +"                default:" +"                    Debug.LogWarning(\"Reached default case in DragSpellOnTarget! Suspicious behaviour!!\");" +"                    break;" +"            }" +"        }" +"" +"        if (!targetValid)" +"        {" +"            // not a valid target, return" +"            whereIsThisCard.VisualState = tempVisualState;" +"            whereIsThisCard.SetHandSortingOrder();" +"        }" +"" +"        // return target and arrow to original position" +"        // this position is special for spell cards to show the arrow on top" +"        transform.localPosition = new Vector3(0f, 0f, 0.4f);" +"        sr.enabled = false;" +"        lr.enabled = false;" +"        triangleSR.enabled = false;" +"" +"    }" +"" +"    // NOT USED IN THIS SCRIPT" +"    protected override bool DragSuccessful()" +"    {" +"        return true;" +"    }" +"}" 
  }
,
  {
    "fileName": "BattleStats.cs",
    "relativeFilePath": "Assets/Scripts/Logic/BattleStats.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using System.Collections.Generic;" +"" +"public static class BattleStats " +"{" +"    public static List<CardLogic> PlayerCards = new List<CardLogic>();" +"    public static List<CardLogic> EnemyCards = new List<CardLogic>();" +"" +"    public static List<CreatureLogic> PlayerCreatures = new List<CreatureLogic>();" +"    public static List<CreatureLogic> EnemyCreatures = new List<CreatureLogic>();" +"}" 
  }
,
  {
    "fileName": "Buff.cs",
    "relativeFilePath": "Assets/Scripts/Logic/Buffs/Buff.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"[System.Serializable]" +"public class BuffInfo" +"{" +"    public string BuffClassName;" +"    public int buffHealth;" +"    public int buffAttack;" +"    public int buffManaCost;" +"    // for example: how many cards to draw, for how many points to heal?" +"    public int buffSpecialAmount;" +"}" +"" +"" +"// this script will be attached to a creature or SPELL and " +"// a) affect his stats" +"// b) give him some new powers" +"// c) create a spell effect" +"[System.Serializable]" +"public class Buff" +"{" +"    public int buffHealth;" +"    public int buffAttack;" +"    public int buffManaCost;" +"    // for example: how many cards to draw, for how many points to heal?" +"    public int buffSpecialAmount;" +"" +"    public void SetValuesFromBuffInfo(BuffInfo bi)" +"    {" +"        buffAttack = bi.buffAttack;" +"        buffHealth = bi.buffHealth;" +"        buffManaCost = bi.buffManaCost;" +"        buffSpecialAmount = bi.buffSpecialAmount;" +"    }" +"" +"    public virtual void BuffAction()" +"    {" +"        " +"    }" +"" +"    public virtual void AttachBuffToEvent()" +"    {" +"        " +"    }" +"" +"}" 
  }
,
  {
    "fileName": "CardLogic.cs",
    "relativeFilePath": "Assets/Scripts/Logic/CardLogic.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using System.Collections.Generic;" +"using System;" +"using CG.Cards;" +"" +"[System.Serializable]" +"public class CardLogic: IIdentifiable" +"{" +"    public Player owner;" +"    public int UniqueCardID; " +"" +"    public CardAsset ca;" +"    public GameObject VisualRepresentation;" +"" +"    private int baseManaCost;" +"    public SpellEffect effect;" +"" +"    public int ID" +"    {" +"        get{ return UniqueCardID; }" +"    }" +"" +"    public int CurrentManaCost{ get; set; }" +"" +"    public bool CanBePlayed" +"    {" +"        get" +"        {" +"            bool ownersTurn = (TurnManager.Instance.whoseTurn == owner);" +"            // for spells the amount of characters on the field does not matter" +"            bool fieldNotFull = true;" +"            // but if this is a creature, we have to check if there is room on board (table)" +"            if (ca.MaxHealth > 0)" +"                fieldNotFull = (owner.table.CreaturesOnTable.Count < 7);" +"            //Debug.Log(\"Card: \" + ca.name + \" has params: ownersTurn=\" + ownersTurn + \"fieldNotFull=\" + fieldNotFull + \" hasMana=\" + (CurrentManaCost <= owner.ManaLeft));" +"            return ownersTurn && fieldNotFull && (CurrentManaCost <= owner.ManaLeft);" +"        }" +"    }" +"" +"    public CardLogic(CardAsset ca)" +"    {" +"        this.ca = ca;" +"        UniqueCardID = IDFactory.GetUniqueID();" +"        //UniqueCardID = IDFactory.GetUniqueID();" +"        baseManaCost = ca.ManaCost;" +"        ResetManaCost();" +"        if (ca.SpellScriptName!= null && ca.SpellScriptName!= \"\")" +"        {" +"            effect = SpellFactory.CreateSpell(ca.SpellScriptName);" +"        }" +"        CardsCreatedThisGame.Add(UniqueCardID, this);" +"    }" +"" +"    public void ResetManaCost()" +"    {" +"        CurrentManaCost = baseManaCost;" +"    }" +"" +"    // STATIC (for managing IDs)" +"    public static Dictionary<int, CardLogic> CardsCreatedThisGame = new Dictionary<int, CardLogic>();" +"" +"}" 
  }
,
  {
    "fileName": "Character.cs",
    "relativeFilePath": "Assets/Scripts/Logic/Character.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public interface ICharacter: IIdentifiable" +"{	" +"    int Health { get;    set;}" +"    void Die();" +"}" +"" +"public interface IIdentifiable" +"{" +"    int ID { get; }" +"}" 
  }
,
  {
    "fileName": "CreatureLogic.cs",
    "relativeFilePath": "Assets/Scripts/Logic/CreatureLogic.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using System.Collections.Generic;" +"using CG.Cards;" +"[System.Serializable]" +"public class CreatureLogic: ICharacter " +"{" +"    // PUBLIC FIELDS" +"    public Player owner;" +"    public CardAsset ca;" +"    public CreatureEffect effect;" +"    public int UniqueCreatureID;" +"    public int ID" +"    {" +"        get{ return UniqueCreatureID; }" +"    }" +"    public bool Frozen = false;" +"" +"    // the basic health that we have in CardAsset" +"    private int baseHealth;" +"    // health with all the current buffs taken into account" +"    public int MaxHealth" +"    {" +"        get{ return baseHealth;}" +"    }" +"        " +"    private int health;" +"" +"    public int Health" +"    {" +"        get{ return health; }" +"" +"        set" +"        {" +"            if (value > MaxHealth)" +"                health = baseHealth;" +"            else if (value <= 0)" +"                Die();" +"            else" +"                health = value;" +"        }" +"    }" +"" +"    public bool CanAttack" +"    {" +"        get" +"        {" +"            bool ownersTurn = (TurnManager.Instance.whoseTurn == owner);" +"            return (ownersTurn && (AttacksLeftThisTurn > 0) && !Frozen);" +"        }" +"    }" +"" +"    private int baseAttack;" +"    // attack with buffs" +"    public int Attack" +"    {" +"        get{ return baseAttack; }" +"" +"    }" +"        " +"    private int attacksForOneTurn = 1;" +"    public int AttacksLeftThisTurn" +"    {" +"        get;" +"        set;" +"    }" +"" +"    // CONSTRUCTOR" +"    public CreatureLogic(Player owner, CardAsset ca)" +"    {" +"        this.ca = ca;" +"        baseHealth = ca.MaxHealth;" +"        Health = ca.MaxHealth;" +"        baseAttack = ca.Attack;" +"        attacksForOneTurn = ca.AttacksForOneTurn;" +"        // AttacksLeftThisTurn is now equal to 0" +"        if (ca.Charge)" +"            AttacksLeftThisTurn = attacksForOneTurn;" +"        this.owner = owner;" +"        UniqueCreatureID = IDFactory.GetUniqueID();" +"        if (ca.CreatureScriptName!= null && ca.CreatureScriptName!= \"\")" +"        {" +"            effect = CreatureEffectFactory.CreateCreatureEffect(ca.CreatureScriptName, owner, this, ca.specialCreatureAmount);" +"            effect.RegisterEffect();" +"        }" +"        CreaturesCreatedThisGame.Add(UniqueCreatureID, this);" +"    }" +"" +"    public void OnTurnStart()" +"    {" +"        AttacksLeftThisTurn = attacksForOneTurn;" +"    }" +"" +"    public void Die()" +"    {   " +"        owner.table.CreaturesOnTable.Remove(this);" +"" +"        new CreatureDieCommand(UniqueCreatureID, owner).AddToQueue();" +"    }" +"" +"    public void GoFace()" +"    {" +"        AttacksLeftThisTurn--;" +"        int targetHealthAfter = owner.otherPlayer.Health - Attack;" +"        new CreatureAttackCommand(owner.otherPlayer.PlayerID, UniqueCreatureID, 0, Attack, Health, targetHealthAfter).AddToQueue();" +"        owner.otherPlayer.Health -= Attack;" +"    }" +"" +"    public void AttackCreature (CreatureLogic target)" +"    {" +"        AttacksLeftThisTurn--;" +"        // calculate the values so that the creature does not fire the DIE command before the Attack command is sent" +"        int targetHealthAfter = target.Health - Attack;" +"        int attackerHealthAfter = Health - target.Attack;" +"        new CreatureAttackCommand(target.UniqueCreatureID, UniqueCreatureID, target.Attack, Attack, attackerHealthAfter, targetHealthAfter).AddToQueue();" +"" +"        target.Health -= Attack;" +"        Health -= target.Attack;" +"    }" +"" +"    public void AttackCreatureWithID(int uniqueCreatureID)" +"    {" +"        CreatureLogic target = CreatureLogic.CreaturesCreatedThisGame[uniqueCreatureID];" +"        AttackCreature(target);" +"    }" +"" +"    // STATIC For managing IDs" +"    public static Dictionary<int, CreatureLogic> CreaturesCreatedThisGame = new Dictionary<int, CreatureLogic>();" +"" +"}" 
  }
,
  {
    "fileName": "BiteOwner.cs",
    "relativeFilePath": "Assets/Scripts/Logic/CreatureScripts/BiteOwner.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class BiteOwner : CreatureEffect" +"{  " +"    public BiteOwner(Player owner, CreatureLogic creature, int specialAmount): base(owner, creature, specialAmount)" +"    {}" +"" +"    public override void RegisterEffect()" +"    {" +"        owner.EndTurnEvent += CauseEffect;" +"        Debug.Log(\"Registered bite effect!!!!\");" +"    }" +"" +"    public override void CauseEffect()" +"    {" +"        Debug.Log(\"InCauseEffect: owner: \"+ owner + \" specialAmount: \"+ specialAmount);" +"        new DealDamageCommand(owner.PlayerID, specialAmount, owner.Health - specialAmount).AddToQueue();" +"        owner.Health -= specialAmount;" +"    }" +"" +"" +"}" 
  }
,
  {
    "fileName": "CreatureEffect.cs",
    "relativeFilePath": "Assets/Scripts/Logic/CreatureScripts/CreatureEffect.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public abstract class CreatureEffect " +"{" +"    protected Player owner;" +"    protected CreatureLogic creature;" +"    protected int specialAmount;" +"" +"    public CreatureEffect(Player owner, CreatureLogic creature, int specialAmount)" +"    {" +"        this.creature = creature;" +"        this.owner = owner;" +"        this.specialAmount = specialAmount;" +"    }" +"" +"    public abstract void RegisterEffect();" +"" +"    public abstract void CauseEffect();" +"" +"}" 
  }
,
  {
    "fileName": "CreatureEffectFactory.cs",
    "relativeFilePath": "Assets/Scripts/Logic/CreatureScripts/CreatureEffectFactory.cs",
    "type": "script",
    "content": "using System;" +"using System.Collections;" +"using System.Collections.Generic;" +"using UnityEngine;" +"" +"public static class CreatureEffectFactory" +"{" +"    private static readonly Dictionary<string, Func<Player, CreatureLogic, int, CreatureEffect>> registry =" +"        new Dictionary<string, Func<Player, CreatureLogic, int, CreatureEffect>>();" +"    static CreatureEffectFactory()" +"    {" +"        // RegisterCreatureEffect(\"CreatureEffectType1\", (owner, creature, specialAmount) => new CreatureEffect(owner, creature, specialAmount));" +"        // RegisterCreatureEffect(\"CreatureEffectType2\", (owner, creature, specialAmount) => new CreatureEffect(owner, creature, specialAmount));" +"        // Add other CreatureEffect types here." +"    }" +"    public static void RegisterCreatureEffect(string scriptName, Func<Player, CreatureLogic, int, CreatureEffect> creator)" +"    {" +"        registry.Add(scriptName, creator);" +"    }" +"    public static CreatureEffect CreateCreatureEffect(string scriptName, Player owner, CreatureLogic creature, int specialAmount)" +"    {" +"        if (registry.ContainsKey(scriptName))" +"        {" +"            return registry[scriptName](owner, creature, specialAmount);" +"        }" +"        else" +"        {" +"            // Possibly throw an exception here or handle the case when a creature effect with a given name is not found." +"            return null;" +"        }" +"    }" +"}" 
  }
,
  {
    "fileName": "Deck.cs",
    "relativeFilePath": "Assets/Scripts/Logic/Deck.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using System.Collections.Generic;" +"using CG.Cards;" +"public class Deck : MonoBehaviour {" +"" +"    public List<CardAsset> cards = new List<CardAsset>();" +"" +"    void Awake()" +"    {" +"        cards.Shuffle();" +"    }" +"	" +"}" 
  }
,
  {
    "fileName": "Hand.cs",
    "relativeFilePath": "Assets/Scripts/Logic/Hand.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using System.Collections.Generic;" +"" +"public class Hand : MonoBehaviour " +"{" +"    public List<CardLogic> CardsInHand = new List<CardLogic>(); " +"" +"}" 
  }
,
  {
    "fileName": "IDHolder.cs",
    "relativeFilePath": "Assets/Scripts/Logic/IDHolder.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using System.Collections.Generic;" +"" +"public class IDHolder : MonoBehaviour {" +"" +"    public int UniqueID;" +"    private static List<IDHolder> allIDHolders = new List<IDHolder>();" +"" +"    void Awake()" +"    {" +"        allIDHolders.Add(this);   " +"    }" +"" +"    public static GameObject GetGameObjectWithID(int ID)" +"    {" +"        foreach (IDHolder i in allIDHolders)" +"        {" +"            if (i.UniqueID == ID)" +"                return i.gameObject;" +"        }" +"        return null;" +"    }" +"" +"    public static void ClearIDHoldersList()" +"    {" +"        allIDHolders.Clear();" +"    }" +"}" 
  }
,
  {
    "fileName": "MovesHighlighter.cs",
    "relativeFilePath": "Assets/Scripts/Logic/MovesHighlighter.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class MovesHighlighter : MonoBehaviour {" +"" +"	" +"}" 
  }
,
  {
    "fileName": "Player.cs",
    "relativeFilePath": "Assets/Scripts/Logic/Player.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using CG.Cards;" +"public class Player : MonoBehaviour, ICharacter" +"{" +"    public int PlayerID;" +"    public CharacterAsset charAsset;" +"    public PlayerArea PArea;" +"    public SpellEffect HeroPowerEffect;" +"" +"    public Deck deck;" +"    public Hand hand;" +"    public Table table;" +"" +"    private int bonusManaThisTurn = 0;" +"    public bool usedHeroPowerThisTurn = false;" +"    private int testTracker = 0;" +"" +"    public int ID" +"    {" +"        get{ return PlayerID; }" +"    }" +"" +"    private int manaThisTurn;" +"    public int ManaThisTurn" +"    {" +"        get{ return manaThisTurn;}" +"        set" +"        {" +"            manaThisTurn = value;" +"            //PArea.ManaBar.TotalCrystals = manaThisTurn;" +"            new UpdateManaCrystalsCommand(this, manaThisTurn, manaLeft).AddToQueue();" +"        }" +"    }" +"" +"    private int manaLeft;" +"    public int ManaLeft" +"    {" +"        get" +"        { return manaLeft;}" +"        set" +"        {" +"            manaLeft = value;" +"            //PArea.ManaBar.AvailableCrystals = manaLeft;" +"            new UpdateManaCrystalsCommand(this, ManaThisTurn, manaLeft).AddToQueue();" +"            //Debug.Log(ManaLeft);" +"            if (TurnManager.Instance.whoseTurn == this)" +"                HighlightPlayableCards();" +"        }" +"    }" +"" +"    public Player otherPlayer" +"    {" +"        get" +"        {" +"            if (Players[0] == this)" +"                return Players[1];" +"            else" +"                return Players[0];" +"        }" +"    }" +"" +"    private int health;" +"    public int Health" +"    {" +"        get { return health;}" +"        set" +"        {" +"            health = value;" +"            if (value <= 0)" +"                Die(); " +"        }" +"    }" +"" +"    public delegate void VoidWithNoArguments();" +"    //public event VoidWithNoArguments CreaturePlayedEvent;" +"    //public event VoidWithNoArguments SpellPlayedEvent;" +"    //public event VoidWithNoArguments StartTurnEvent;" +"    public event VoidWithNoArguments EndTurnEvent;" +"" +"    public static Player[] Players;" +"" +"    void Awake()" +"    {" +"        Players = GameObject.FindObjectsOfType<Player>();" +"        PlayerID = IDFactory.GetUniqueID();" +"    }" +"    private void Update() {" +"        if (Input.GetKeyDown(KeyCode.D)) {" +"            DrawACard();" +"        }" +"    }" +"" +"    public virtual void OnTurnStart()" +"    {" +"        // add one mana crystal to the pool;" +"        Debug.Log(\"In ONTURNSTART for \"+ gameObject.name);" +"        usedHeroPowerThisTurn = false;" +"        ManaThisTurn++;" +"        ManaLeft = ManaThisTurn;" +"        foreach (CreatureLogic cl in table.CreaturesOnTable)" +"            cl.OnTurnStart();" +"        PArea.HeroPower.WasUsedThisTurn = false;" +"" +"    }" +"" +"    public void GetBonusMana(int amount)" +"    {" +"        bonusManaThisTurn += amount;" +"        ManaThisTurn += amount;" +"        ManaLeft += amount;" +"    }   " +"" +"    public void OnTurnEnd()" +"    {" +"        if(EndTurnEvent != null)" +"            EndTurnEvent.Invoke();" +"        ManaThisTurn -= bonusManaThisTurn;" +"        bonusManaThisTurn = 0;" +"        GetComponent<TurnMaker>().StopAllCoroutines();" +"    }" +"" +"    public void DrawACard(bool fast = false)" +"    {" +"        if (deck.cards.Count > 0)" +"        {" +"            if (hand.CardsInHand.Count < PArea.handVisual.slots.Children.Length)" +"            {" +"                testTracker++;" +"                // 1) save index to place a visual card into visual hand" +"                int indexToPlaceACard = hand.CardsInHand.Count;" +"                // 2) logic: add card to hand" +"                CardLogic newCard = new CardLogic(deck.cards[0]);" +"                newCard.owner = this;" +"                hand.CardsInHand.Add(newCard);" +"                // Debug.Log(hand.CardsInHand.Count);" +"                // 3) logic: remove the card from the deck" +"                deck.cards.RemoveAt(0);" +"                // 4) create a command" +"                new DrawACardCommand(hand.CardsInHand[indexToPlaceACard], this, indexToPlaceACard, fast, fromDeck: true, testTracker).AddToQueue(); " +"            }" +"        }" +"        else" +"        {" +"            Debug.Log(\"No cards left: \" + deck.cards.Count);" +"            // there are no cards in the deck, take fatigue damage." +"        }" +"       " +"    }" +"" +"    public void DrawACoin()" +"    {" +"        if (hand.CardsInHand.Count < PArea.handVisual.slots.Children.Length)" +"        {" +"            // 1) logic: add card to hand" +"            CardLogic newCard = new CardLogic(GlobalSettings.Instance.CoinCard);" +"            newCard.owner = this;" +"            hand.CardsInHand.Add(newCard);" +"            // 2) send message to the visual Deck" +"            new DrawACardCommand(hand.CardsInHand[hand.CardsInHand.Count - 1], this, hand.CardsInHand.Count - 1, fast: true, fromDeck: false, testTracker).AddToQueue(); " +"        }" +"        // no removal from deck because the coin was not in the deck" +"    }" +"" +"    public void PlayASpellFromHand(int SpellCardUniqueID, int TargetUniqueID)" +"    {" +"        // TODO: !!!" +"        // if TargetUnique ID < 0 , for example = -1, there is no target." +"        if (TargetUniqueID < 0)" +"            PlayASpellFromHand(CardLogic.CardsCreatedThisGame[SpellCardUniqueID], null);" +"        else if (TargetUniqueID == ID)" +"        {" +"            PlayASpellFromHand(CardLogic.CardsCreatedThisGame[SpellCardUniqueID], this);" +"        }" +"        else if (TargetUniqueID == otherPlayer.ID)" +"        {" +"            PlayASpellFromHand(CardLogic.CardsCreatedThisGame[SpellCardUniqueID], this.otherPlayer);" +"        }" +"        else" +"        {" +"            // target is a creature" +"            PlayASpellFromHand(CardLogic.CardsCreatedThisGame[SpellCardUniqueID], CreatureLogic.CreaturesCreatedThisGame[TargetUniqueID]);" +"        }" +"          " +"    }" +"" +"    public void PlayASpellFromHand(CardLogic playedCard, ICharacter target)" +"    {" +"        ManaLeft -= playedCard.CurrentManaCost;" +"        // cause effect instantly:" +"        if (playedCard.effect != null)" +"            playedCard.effect.ActivateEffect(playedCard.ca.specialSpellAmount, target);" +"        else" +"        {" +"            Debug.LogWarning(\"No effect found on card \" + playedCard.ca.name);" +"        }" +"        // no matter what happens, move this card to PlayACardSpot" +"        new PlayASpellCardCommand(this, playedCard).AddToQueue();" +"        // remove this card from hand" +"        hand.CardsInHand.Remove(playedCard);" +"        // check if this is a creature or a spell" +"    }" +"" +"    public void PlayACreatureFromHand(int UniqueID, int tablePos)" +"    {" +"        PlayACreatureFromHand(CardLogic.CardsCreatedThisGame[UniqueID], tablePos);" +"    }" +"" +"    public void PlayACreatureFromHand(CardLogic playedCard, int tablePos)" +"    {" +"        Debug.Log(ManaLeft);" +"        Debug.Log(playedCard.CurrentManaCost);" +"        ManaLeft -= playedCard.CurrentManaCost;" +"        Debug.Log(\"Mana Left after played a creature: \" + ManaLeft);" +"        // create a new creature object and add it to Table" +"        CreatureLogic newCreature = new CreatureLogic(this, playedCard.ca);" +"        table.CreaturesOnTable.Insert(tablePos, newCreature);" +"        // no matter what happens, move this card to PlayACardSpot" +"        new PlayACreatureCommand(playedCard, this, tablePos, newCreature.UniqueCreatureID).AddToQueue();" +"        // remove this card from hand" +"        hand.CardsInHand.Remove(playedCard);" +"        HighlightPlayableCards();" +"    }" +"" +"    public void Die()" +"    {" +"        // game over" +"        // block both players from taking new moves " +"        PArea.ControlsON = false;" +"        otherPlayer.PArea.ControlsON = false;" +"        TurnManager.Instance.StopTheTimer();" +"        new GameOverCommand(this).AddToQueue();" +"    }" +"" +"    // METHODS TO SHOW GLOW HIGHLIGHTS" +"    public void HighlightPlayableCards(bool removeAllHighlights = false)" +"    {" +"        //Debug.Log(\"HighlightPlayable remove: \"+ removeAllHighlights);" +"        foreach (CardLogic cl in hand.CardsInHand)" +"        {" +"            GameObject g = IDHolder.GetGameObjectWithID(cl.UniqueCardID);" +"            if (g!=null)" +"                g.GetComponent<OneCardManager>().CanBePlayedNow = (cl.CurrentManaCost <= ManaLeft) && !removeAllHighlights;" +"        }" +"" +"        foreach (CreatureLogic crl in table.CreaturesOnTable)" +"        {" +"            GameObject g = IDHolder.GetGameObjectWithID(crl.UniqueCreatureID);" +"            if(g!= null)" +"                g.GetComponent<OneCreatureManager>().CanAttackNow = (crl.AttacksLeftThisTurn > 0) && !removeAllHighlights;" +"        }" +"            " +"        // highlight hero power" +"        PArea.HeroPower.Highlighted = (!usedHeroPowerThisTurn) && (ManaLeft > 1) && !removeAllHighlights;" +"    }" +"" +"    // START GAME METHODS" +"    public void LoadCharacterInfoFromAsset()" +"    {" +"        Health = charAsset.MaxHealth;" +"        // change the visuals for portrait, hero power, etc..." +"        PArea.Portrait.charAsset = charAsset;" +"        PArea.Portrait.ApplyLookFromAsset();" +"        // TODO: insert the code to attach hero power script here. " +"        if (charAsset.HeroPowerName != null && charAsset.HeroPowerName != \"\")" +"        {" +"            HeroPowerEffect = System.Activator.CreateInstance(System.Type.GetType(charAsset.HeroPowerName)) as SpellEffect;" +"        }" +"        else" +"        {" +"            Debug.LogWarning(\"Check hero powr name for character \" + charAsset.ClassName);" +"        }" +"    }" +"" +"    public void TransmitInfoAboutPlayerToVisual()" +"    {" +"        PArea.Portrait.GetComponent<IDHolder>().UniqueID = PlayerID;" +"        if (GetComponent<TurnMaker>() is AITurnMaker)" +"        {" +"            // turn off turn making for this character" +"            PArea.AllowedToControlThisPlayer = false;" +"        }" +"        else" +"        {" +"            // allow turn making for this character" +"            PArea.AllowedToControlThisPlayer = true;" +"        }" +"    }" +"" +"    public void UseHeroPower()" +"    {" +"        ManaLeft -= 2;" +"        usedHeroPowerThisTurn = true;" +"        HeroPowerEffect.ActivateEffect();" +"    }" +"}" 
  }
,
  {
    "fileName": "RopeTimer.cs",
    "relativeFilePath": "Assets/Scripts/Logic/RopeTimer.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using UnityEngine.UI;" +"using UnityEngine.Events;" +"using UnityEngine.EventSystems;" +"" +"public class RopeTimer : MonoBehaviour, IEventSystemHandler" +"{" +"    public GameObject RopeGameObject;" +"    public Slider RopeSlider;" +"	public float TimeForOneTurn;" +"    public float RopeBurnTime;" +"    public Text TimerText;" +"" +"    private float timeTillZero;" +"    private bool counting = false;" +"    private bool ropeIsBurning;" +"" +"    [SerializeField]" +"    public UnityEvent TimerExpired = new UnityEvent();" +"" +"    void Awake()" +"    {" +"        if (RopeGameObject != null)" +"        {" +"            RopeSlider.minValue = 0;" +"            RopeSlider.maxValue = RopeBurnTime;" +"            RopeGameObject.SetActive(false);" +"        }" +"    }" +"" +"    public void StartTimer()" +"	{" +"        timeTillZero = TimeForOneTurn;" +"		counting = true;" +"        ropeIsBurning = false;" +"        if (RopeGameObject!=null)" +"            RopeGameObject.SetActive(false);" +"	} " +"" +"	public void StopTimer()" +"	{" +"		counting = false;" +"	}" +"	" +"	// Update is called once per frame" +"	void Update () " +"	{" +"		if (counting) " +"		{" +"			timeTillZero -= Time.deltaTime;" +"            if (TimerText!=null)" +"                TimerText.text = ToString();" +"" +"            if (RopeGameObject != null)" +"            {" +"                // check for rope" +"                if (timeTillZero <= RopeBurnTime && !ropeIsBurning)" +"                {" +"                    ropeIsBurning = true;" +"                    RopeGameObject.SetActive(true);" +"                }" +"                // rope update" +"                if (ropeIsBurning)" +"                {" +"                    RopeSlider.value = timeTillZero;" +"                }" +"            }" +"" +"            // check for TimeExpired" +"			if(timeTillZero<=0)" +"			{" +"				counting = false;" +"                //RopeGameObject.SetActive(false);" +"                TimerExpired.Invoke();" +"			}" +"		}" +"	" +"	}" +"" +"	public override string ToString ()" +"	{" +"		int inSeconds = Mathf.RoundToInt (timeTillZero);" +"		string justSeconds = (inSeconds % 60).ToString ();" +"		if (justSeconds.Length == 1)" +"			justSeconds = \"0\" + justSeconds;" +"		string justMinutes = (inSeconds / 60).ToString ();" +"		if (justMinutes.Length == 1)" +"			justMinutes = \"0\" + justMinutes;" +"" +"		return string.Format (\"{0}:{1}\", justMinutes, justSeconds);" +"	}" +"}" 
  }
,
  {
    "fileName": "DamageAllCreatures.cs",
    "relativeFilePath": "Assets/Scripts/Logic/SpellScripts/DamageAllCreatures.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class DamageAllCreatures : SpellEffect {" +"" +"    public override void ActivateEffect(int specialAmount = 0, ICharacter target = null)" +"    {" +"        CreatureLogic[] CreaturesToDamage = TurnManager.Instance.whoseTurn.otherPlayer.table.CreaturesOnTable.ToArray();" +"        foreach (CreatureLogic cl in CreaturesToDamage)" +"        {" +"            new DealDamageCommand(cl.ID, specialAmount, healthAfter: cl.Health - specialAmount).AddToQueue();" +"            cl.Health -= specialAmount;" +"        }" +"    }" +"}" 
  }
,
  {
    "fileName": "DealDamageToTarget.cs",
    "relativeFilePath": "Assets/Scripts/Logic/SpellScripts/DealDamageToTarget.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class DealDamageToTarget : SpellEffect " +"{" +"    " +"" +"    public override void ActivateEffect(int specialAmount = 0, ICharacter target = null)" +"    {" +"        new DealDamageCommand(target.ID, specialAmount, healthAfter: target.Health - specialAmount).AddToQueue();" +"        target.Health -= specialAmount;" +"    }" +"}" 
  }
,
  {
    "fileName": "GiveManaBonus.cs",
    "relativeFilePath": "Assets/Scripts/Logic/SpellScripts/GiveManaBonus.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class GiveManaBonus: SpellEffect " +"{" +"    public override void ActivateEffect(int specialAmount = 0, ICharacter target = null)" +"    {" +"        TurnManager.Instance.whoseTurn.GetBonusMana(specialAmount);" +"    }" +"}" 
  }
,
  {
    "fileName": "HeroPower2Face.cs",
    "relativeFilePath": "Assets/Scripts/Logic/SpellScripts/HeroPower2Face.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class HeroPower2Face : SpellEffect " +"{" +"" +"    public override void ActivateEffect(int specialAmount = 0, ICharacter target = null)" +"    {" +"        new DealDamageCommand(TurnManager.Instance.whoseTurn.otherPlayer.PlayerID, 2, TurnManager.Instance.whoseTurn.otherPlayer.Health - 2).AddToQueue();" +"        TurnManager.Instance.whoseTurn.otherPlayer.Health -= 2;" +"    }" +"}" 
  }
,
  {
    "fileName": "HeroPowerDrawCardTakeDamage.cs",
    "relativeFilePath": "Assets/Scripts/Logic/SpellScripts/HeroPowerDrawCardTakeDamage.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class HeroPowerDrawCardTakeDamage : SpellEffect {" +"" +"    public override void ActivateEffect(int specialAmount = 0, ICharacter target = null)" +"    {" +"        // Take 2 damage" +"        new DealDamageCommand(TurnManager.Instance.whoseTurn.PlayerID, 2, TurnManager.Instance.whoseTurn.Health - 2).AddToQueue();" +"        TurnManager.Instance.whoseTurn.Health -= 2;" +"        // Draw a card" +"        TurnManager.Instance.whoseTurn.DrawACard();" +"" +"    }" +"}" 
  }
,
  {
    "fileName": "SpellEffect.cs",
    "relativeFilePath": "Assets/Scripts/Logic/SpellScripts/SpellEffect.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class SpellEffect" +"{" +"    public virtual void ActivateEffect(int specialAmount = 0, ICharacter target = null)" +"    {" +"        Debug.Log(\"No Spell effect with this name found! Check for typos in CardAssets\");" +"    }" +"        " +"}" 
  }
,
  {
    "fileName": "SpellFactory.cs",
    "relativeFilePath": "Assets/Scripts/Logic/SpellScripts/SpellFactory.cs",
    "type": "script",
    "content": "using System;" +"using System.Collections;" +"using System.Collections.Generic;" +"using UnityEngine;" +"" +"public static class SpellFactory" +"{" +"    // Start is called before the first frame update" +"    private static Dictionary<string, Func<SpellEffect>> registry = new Dictionary<string, Func<SpellEffect>>();" +"    static SpellFactory()" +"    {" +"        // Register each type of spell with its factory method" +"        // registry[\"Fireball\"] = () => new FireballSpell();" +"        // registry[\"IceBlast\"] = () => new IceBlastSpell();" +"        // ... Add the rest here" +"    }" +"" +"    public static SpellEffect CreateSpell(string spellName)" +"    {" +"        if (registry.TryGetValue(spellName, out Func<SpellEffect> constructor))" +"        {" +"            return constructor();" +"        }" +"        else" +"        {" +"            Debug.Log(\$\"No Spell with the name {spellName} found!\");" +"            return null;" +"        }" +"    }" +"}" 
  }
,
  {
    "fileName": "Table.cs",
    "relativeFilePath": "Assets/Scripts/Logic/Table.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using System.Collections.Generic;" +"" +"public class Table : MonoBehaviour " +"{" +"    public List<CreatureLogic> CreaturesOnTable = new List<CreatureLogic>();" +"" +"    public void PlaceCreatureAt(int index, CreatureLogic creature)" +"    {" +"        CreaturesOnTable.Insert(index, creature);" +"    }" +"        " +"}" 
  }
,
  {
    "fileName": "TurnManager.cs",
    "relativeFilePath": "Assets/Scripts/Logic/TurnManager.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using UnityEngine.UI;" +"using DG.Tweening;" +"" +"// this class will take care of switching turns and counting down time until the turn expires" +"public class TurnManager : MonoBehaviour {" +"" +"    private RopeTimer timer;" +"" +"    // for Singleton Pattern" +"    public static TurnManager Instance;" +"" +"    private Player _whoseTurn;" +"    public Player whoseTurn" +"    {" +"        get" +"        {" +"            return _whoseTurn;" +"        }" +"" +"        set" +"        {" +"            _whoseTurn = value;" +"            timer.StartTimer();" +"" +"            GlobalSettings.Instance.EnableEndTurnButtonOnStart(_whoseTurn);" +"" +"            TurnMaker tm = whoseTurn.GetComponent<TurnMaker>();" +"            // player\`s method OnTurnStart() will be called in tm.OnTurnStart();" +"            tm.OnTurnStart();" +"            if (tm is PlayerTurnMaker)" +"            {" +"                whoseTurn.HighlightPlayableCards();" +"            }" +"            // remove highlights for opponent." +"            whoseTurn.otherPlayer.HighlightPlayableCards(true);" +"                " +"        }" +"    }" +"" +"    void Awake()" +"    {" +"        Instance = this;" +"        timer = GetComponent<RopeTimer>();" +"    }" +"" +"    void Start()" +"    {" +"        OnGameStart();" +"    }" +"" +"    public void OnGameStart()" +"    {" +"        //Debug.Log(\"In TurnManager.OnGameStart()\");" +"" +"        CardLogic.CardsCreatedThisGame.Clear();" +"        CreatureLogic.CreaturesCreatedThisGame.Clear();" +"" +"        foreach (Player p in Player.Players)" +"        {" +"            p.ManaThisTurn = 0;" +"            p.ManaLeft = 0;" +"            p.LoadCharacterInfoFromAsset();" +"            p.TransmitInfoAboutPlayerToVisual();" +"            p.PArea.PDeck.CardsInDeck = p.deck.cards.Count;" +"            // move both portraits to the center" +"            p.PArea.Portrait.transform.position = p.PArea.handVisual.OtherCardDrawSourceTransform.position;" +"        }" +"" +"        Sequence s = DOTween.Sequence();" +"        s.Append(Player.Players[0].PArea.Portrait.transform.DOMove(Player.Players[0].PArea.PortraitPosition.position, 1f).SetEase(Ease.InQuad));" +"        s.Insert(0f, Player.Players[1].PArea.Portrait.transform.DOMove(Player.Players[1].PArea.PortraitPosition.position, 1f).SetEase(Ease.InQuad));" +"        s.PrependInterval(3f);" +"        s.OnComplete(() =>" +"            {" +"                // determine who starts the game." +"                int rnd = Random.Range(0,2);  // 2 is exclusive boundary" +"                // Debug.Log(Player.Players.Length);" +"                Player whoGoesFirst = Player.Players[rnd];" +"                // Debug.Log(whoGoesFirst);" +"                Player whoGoesSecond = whoGoesFirst.otherPlayer;" +"                // Debug.Log(whoGoesSecond);" +"         " +"                // draw 4 cards for first player and 5 for second player" +"                int initDraw = 4;" +"                for (int i = 0; i < initDraw; i++)" +"                {            " +"                    // second player draws a card" +"                    whoGoesSecond.DrawACard(true);" +"                    // first player draws a card" +"                    whoGoesFirst.DrawACard(true);" +"                }" +"                // add one more card to second player\`s hand" +"                whoGoesSecond.DrawACard(true);" +"                //new GivePlayerACoinCommand(null, whoGoesSecond).AddToQueue();" +"                whoGoesSecond.DrawACoin();" +"                new StartATurnCommand(whoGoesFirst).AddToQueue();" +"            });" +"    }" +"" +"    void Update()" +"    {" +"        if (Input.GetKeyDown(KeyCode.Space))" +"            EndTurn();" +"    }" +"" +"    public void EndTurn()" +"    {" +"        // stop timer" +"        timer.StopTimer();" +"        // send all commands in the end of current player\`s turn" +"        whoseTurn.OnTurnEnd();" +"" +"        new StartATurnCommand(whoseTurn.otherPlayer).AddToQueue();" +"    }" +"" +"    public void EndTurnTest() {" +"        timer.StopTimer();" +"        timer.StartTimer();" +"    }" +"    public void StopTheTimer()" +"    {" +"        timer.StopTimer();" +"    }" +"" +"}" +"" 
  }
,
  {
    "fileName": "AITurnMaker.cs",
    "relativeFilePath": "Assets/Scripts/Logic/TurnsAndAI/AITurnMaker.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using CG.Cards;" +"//this class will take all decisions for AI. " +"" +"public class AITurnMaker: TurnMaker {" +"" +"    public override void OnTurnStart()" +"    {" +"        base.OnTurnStart();" +"        // dispay a message that it is enemy\`s turn" +"        new ShowMessageCommand(\"Enemy\`s Turn!\", 2.0f).AddToQueue();" +"        p.DrawACard();" +"        StartCoroutine(MakeAITurn());" +"    }" +"" +"    // THE LOGIC FOR AI" +"    IEnumerator MakeAITurn()" +"    {" +"        bool strategyAttackFirst = false;" +"        if (Random.Range(0, 2) == 0)" +"            strategyAttackFirst = true;" +"" +"        while (MakeOneAIMove(strategyAttackFirst))" +"        {" +"            yield return null;" +"        }" +"" +"        InsertDelay(1f);" +"" +"        TurnManager.Instance.EndTurn();" +"    }" +"" +"    bool MakeOneAIMove(bool attackFirst)" +"    {" +"        if (Command.CardDrawPending())" +"            return true;" +"        else if (attackFirst)" +"            return AttackWithACreature() || PlayACardFromHand() || UseHeroPower();" +"        else " +"            return PlayACardFromHand() || AttackWithACreature() || UseHeroPower();" +"    }" +"" +"    bool PlayACardFromHand()" +"    {" +"        foreach (CardLogic c in p.hand.CardsInHand)" +"        {" +"            if (c.CanBePlayed)" +"            {" +"                if (c.ca.MaxHealth == 0)" +"                {" +"                    // code to play a spell from hand" +"                    // TODO: depending on the targeting options, select a random target." +"                    if (c.ca.Targets == TargetingOptions.NoTarget)" +"                    {" +"                        p.PlayASpellFromHand(c, null);" +"                        InsertDelay(1.5f);" +"                        //Debug.Log(\"Card: \" + c.ca.name + \" can be played\");" +"                        return true;" +"                    }                        " +"                }" +"                else" +"                {" +"                    // it is a creature card" +"                    p.PlayACreatureFromHand(c, 0);" +"                    InsertDelay(1.5f);" +"                    return true;" +"                }" +"" +"            }" +"            //Debug.Log(\"Card: \" + c.ca.name + \" can NOT be played\");" +"        }" +"        return false;" +"    }" +"" +"    bool UseHeroPower()" +"    {" +"        if (p.ManaLeft >= 2 && !p.usedHeroPowerThisTurn)" +"        {" +"            // use HP" +"            p.UseHeroPower();" +"            InsertDelay(1.5f);" +"            //Debug.Log(\"AI used hero power\");" +"            return true;" +"        }" +"        return false;" +"    }" +"" +"    bool AttackWithACreature()" +"    {" +"        foreach (CreatureLogic cl in p.table.CreaturesOnTable)" +"        {" +"            if (cl.AttacksLeftThisTurn > 0)" +"            {" +"                // attack a random target with a creature" +"                if (p.otherPlayer.table.CreaturesOnTable.Count > 0)" +"                {" +"                    int index = Random.Range(0, p.otherPlayer.table.CreaturesOnTable.Count);" +"                    CreatureLogic targetCreature = p.otherPlayer.table.CreaturesOnTable[index];" +"                    cl.AttackCreature(targetCreature);" +"                }                    " +"                else" +"                    cl.GoFace();" +"                " +"                InsertDelay(1f);" +"                //Debug.Log(\"AI attacked with creature\");" +"                return true;" +"            }" +"        }" +"        return false;" +"    }" +"" +"    void InsertDelay(float delay)" +"    {" +"        new DelayCommand(delay).AddToQueue();" +"    }" +"" +"}" 
  }
,
  {
    "fileName": "PlayerTurnMaker.cs",
    "relativeFilePath": "Assets/Scripts/Logic/TurnsAndAI/PlayerTurnMaker.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class PlayerTurnMaker : TurnMaker " +"{" +"    public override void OnTurnStart()" +"    {" +"        base.OnTurnStart();" +"        // dispay a message that it is player\`s turn" +"        new ShowMessageCommand(\"Your Turn!\", 2.0f).AddToQueue();" +"        p.DrawACard();" +"    }" +"}" 
  }
,
  {
    "fileName": "TurnMaker.cs",
    "relativeFilePath": "Assets/Scripts/Logic/TurnsAndAI/TurnMaker.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public abstract class TurnMaker : MonoBehaviour {" +"" +"    protected Player p;" +"" +"    void Awake()" +"    {" +"        p = GetComponent<Player>();" +"    }" +"" +"    public virtual void OnTurnStart()" +"    {" +"        // add one mana crystal to the pool;" +"        p.OnTurnStart();" +"    }" +"" +"}" 
  }
,
  {
    "fileName": "CardAsset.cs",
    "relativeFilePath": "Assets/Scripts/SO Asset Scripts/CardAsset/CardAsset.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using System.Collections.Generic;" +"namespace CG.Cards" +"{" +"     public enum ECardType" +"        {" +"            Creature," +"            Spell," +"            FastSpell," +"            Equipment," +"            Artifact," +"            Hero" +"        }" +"        public enum TargetingOptions" +"        {" +"            NoTarget," +"            AllCreatures," +"            EnemyCreatures," +"            YourCreatures," +"            AllCharacters," +"            EnemyCharacters," +"            YourCharacters" +"        }" +"" +"    [CreateAssetMenu(fileName = \"New Card\", menuName = \"Card Game/Card\")]" +"    public class CardAsset : ScriptableObject" +"    {" +"" +"        // this object will hold the info about the most general card" +"        [Header(\"General info\")]" +"        public CharacterAsset characterAsset;  // if this is null, it\`s a neutral card" +"        [TextArea(2, 3)]" +"        public string Description;  // Description for spell or character" +"        public Sprite CardImage;" +"        public RectTransform CardImageRect;" +"        public int ManaCost;" +"" +"        public ECardType CardType;" +"" +"" +"        [Header(\"Creature Info\")]" +"        public int MaxHealth;" +"        public int Attack;" +"        public int AttacksForOneTurn = 1;" +"        public bool Taunt;" +"        public bool Charge;" +"        public string CreatureScriptName;" +"        public int specialCreatureAmount;" +"" +"        [Header(\"SpellInfo\")]" +"        public string SpellScriptName;" +"        public int specialSpellAmount;" +"        public bool Fast" +"        {" +"            get" +"            {" +"                return CardType == ECardType.FastSpell;" +"            }" +"        }" +"        public TargetingOptions Targets;" +"" +"    }" +"}" +"" 
  }
,
  {
    "fileName": "CardAssetEditor.cs",
    "relativeFilePath": "Assets/Scripts/SO Asset Scripts/CardAsset/Editor/CardAssetEditor.cs",
    "type": "script",
    "content": "using UnityEngine;" +"using UnityEditor;" +"using CG.Cards;" +"namespace CG.Cards" +"{" +"    [CustomEditor(typeof(CardAsset))]" +"    public class CardEditor : Editor" +"    {" +"        public override void OnInspectorGUI()" +"        {" +"            CardAsset card = (CardAsset)target;" +"" +"            // Draw default properties" +"            EditorGUILayout.PropertyField(serializedObject.FindProperty(\"characterAsset\"));" +"            EditorGUILayout.PropertyField(serializedObject.FindProperty(\"Description\"));" +"            EditorGUILayout.PropertyField(serializedObject.FindProperty(\"CardImage\"));" +"            EditorGUILayout.PropertyField(serializedObject.FindProperty(\"ManaCost\"));" +"            EditorGUILayout.PropertyField(serializedObject.FindProperty(\"CardType\"));" +"            EditorGUILayout.PropertyField(serializedObject.FindProperty(\"CardImageRect\"));" +"" +"" +"            // Draw properties specific to the Creature card type" +"            if (card.CardType == ECardType.Creature)" +"            {" +"                EditorGUILayout.PropertyField(serializedObject.FindProperty(\"MaxHealth\"));" +"                EditorGUILayout.PropertyField(serializedObject.FindProperty(\"Attack\"));" +"                EditorGUILayout.PropertyField(serializedObject.FindProperty(\"AttacksForOneTurn\"));" +"                EditorGUILayout.PropertyField(serializedObject.FindProperty(\"Taunt\"));" +"                EditorGUILayout.PropertyField(serializedObject.FindProperty(\"Charge\"));" +"                EditorGUILayout.PropertyField(serializedObject.FindProperty(\"CreatureScriptName\"));" +"                EditorGUILayout.PropertyField(serializedObject.FindProperty(\"specialCreatureAmount\"));" +"" +"            }" +"            if (card.CardType == ECardType.Spell || card.CardType == ECardType.FastSpell)" +"            {" +"                EditorGUILayout.PropertyField(serializedObject.FindProperty(\"SpellScriptName\"));" +"                EditorGUILayout.PropertyField(serializedObject.FindProperty(\"specialSpellAmount\"));" +"                EditorGUILayout.PropertyField(serializedObject.FindProperty(\"Targets\"));" +"            }" +"" +"            // Apply any changes made in the Inspector" +"            serializedObject.ApplyModifiedProperties();" +"        }" +"    }" +"}" 
  }
,
  {
    "fileName": "CardUnityIntegration.cs",
    "relativeFilePath": "Assets/Scripts/SO Asset Scripts/CardAsset/Editor/CardUnityIntegration.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using UnityEditor;" +"" +"static class CardUnityIntegration " +"{" +"" +"	// [MenuItem(\"Assets/Create/CardAsset\")]" +"	// public static void CreateYourScriptableObject() {" +"	// 	ScriptableObjectUtility2.CreateAsset<CardAsset>();" +"	// }" +"" +"}" 
  }
,
  {
    "fileName": "CharacterAsset.cs",
    "relativeFilePath": "Assets/Scripts/SO Asset Scripts/CharacterAsset/CharacterAsset.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public enum CharClass{ Elf, Monk, Warrior, Mage}" +"" +"public class CharacterAsset : ScriptableObject " +"{" +"	public CharClass Class;" +"	public string ClassName;" +"	public int MaxHealth = 30;" +"	public string HeroPowerName;" +"	public Sprite AvatarImage;" +"    public Sprite HeroPowerIconImage;" +"    public Sprite AvatarBGImage;" +"    public Sprite HeroPowerBGImage;" +"    public Color32 AvatarBGTint;" +"    public Color32 HeroPowerBGTint;" +"    public Color32 ClassCardTint;" +"    public Color32 ClassRibbonsTint;" +"}" 
  }
,
  {
    "fileName": "CharacterUnityIntegration.cs",
    "relativeFilePath": "Assets/Scripts/SO Asset Scripts/CharacterAsset/Editor/CharacterUnityIntegration.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using UnityEditor;" +"" +"static class CharacterUnityIntegration {" +"" +"	[MenuItem(\"Assets/Create/CharacterAsset\")]" +"	public static void CreateYourScriptableObject() {" +"		ScriptableObjectUtility2.CreateAsset<CharacterAsset>();" +"	}" +"" +"}" 
  }
,
  {
    "fileName": "ScriptableObjectUtility2.cs",
    "relativeFilePath": "Assets/Scripts/SO Asset Scripts/Editor/ScriptableObjectUtility2.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using UnityEditor;" +"" +"public static class ScriptableObjectUtility2 {" +"	" +"	/// <summary>" +"	/// Create new asset from <see cref=\"ScriptableObject\"/> type with unique name at" +"	/// selected folder in project window. Asset creation can be cancelled by pressing" +"	/// escape key when asset is initially being named." +"	/// </summary>" +"	/// <typeparam name=\"T\">Type of scriptable object.</typeparam>" +"	public static void CreateAsset<T>() where T : ScriptableObject {" +"		var asset = ScriptableObject.CreateInstance<T>();" +"		ProjectWindowUtil.CreateAsset(asset, \"New \" + typeof(T).Name + \".asset\");" +"	}" +"	" +"}" 
  }
,
  {
    "fileName": "BoxOutline.cs",
    "relativeFilePath": "Assets/Scripts/UI/Outlines/BoxOutline.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using UnityEngine.UI;" +"using System.Collections.Generic;" +"" +"public class BoxOutline : ModifiedShadow" +"{" +"    const int maxHalfSampleCount = 20;" +"" +"    [SerializeField] [Range(1, maxHalfSampleCount)]" +"    int m_halfSampleCountX = 1;" +"    [SerializeField] [Range(1, maxHalfSampleCount)]" +"    int m_halfSampleCountY = 1;" +"" +"    public int halfSampleCountX" +"    {" +"        get" +"        {" +"            return m_halfSampleCountX;" +"        }" +"" +"        set" +"        {" +"            m_halfSampleCountX = Mathf.Clamp(value, 1, maxHalfSampleCount);" +"            if (graphic != null)" +"                graphic.SetVerticesDirty();" +"        }" +"    }" +"" +"    public int halfSampleCountY" +"    {" +"        get" +"        {" +"            return m_halfSampleCountY;" +"        }" +"" +"        set" +"        {" +"            m_halfSampleCountY = Mathf.Clamp(value, 1, maxHalfSampleCount);" +"            if (graphic != null)" +"                graphic.SetVerticesDirty();" +"        }" +"    }" +"" +"    public override void ModifyVertices(List<UIVertex> verts)" +"    {" +"        if (!IsActive())" +"            return;" +"" +"        var neededCapacity = verts.Count * (m_halfSampleCountX * 2 + 1) * (m_halfSampleCountY * 2 + 1);" +"        if (verts.Capacity < neededCapacity)" +"            verts.Capacity = neededCapacity;" +"" +"        var original = verts.Count;" +"        var count = 0;" +"        var dx = effectDistance.x / m_halfSampleCountX;" +"        var dy = effectDistance.y / m_halfSampleCountY;" +"        for (int x = -m_halfSampleCountX; x <= m_halfSampleCountX; x++)" +"        {" +"            for (int y = -m_halfSampleCountY; y <= m_halfSampleCountY; y++)" +"            {" +"                if (!(x == 0 && y == 0))" +"                {" +"                    var next = count + original;" +"                    ApplyShadow(verts, effectColor, count, next, dx * x, dy * y);" +"                    count = next;" +"                }" +"            }" +"        }" +"    }" +"}" 
  }
,
  {
    "fileName": "CircleOutline.cs",
    "relativeFilePath": "Assets/Scripts/UI/Outlines/CircleOutline.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using UnityEngine.UI;" +"using System.Collections.Generic;" +"" +"public class CircleOutline : ModifiedShadow" +"{" +"    [SerializeField]" +"    int m_circleCount = 2;" +"    [SerializeField]" +"    int m_firstSample = 4;" +"    [SerializeField]" +"    int m_sampleIncrement = 2;" +"" +"#if UNITY_EDITOR" +"    protected override void OnValidate()" +"    {" +"        base.OnValidate();" +"        circleCount = m_circleCount;" +"        firstSample = m_firstSample;" +"        sampleIncrement = m_sampleIncrement;" +"    }" +"#endif" +"" +"    public int circleCount" +"    {" +"        get" +"        {" +"            return m_circleCount;" +"        }" +"" +"        set" +"        {" +"            m_circleCount = Mathf.Max(value, 1);" +"            if (graphic != null)" +"                graphic.SetVerticesDirty();" +"        }" +"    }" +"" +"    public int firstSample" +"    {" +"        get" +"        {" +"            return m_firstSample;" +"        }" +"" +"        set" +"        {" +"            m_firstSample = Mathf.Max(value, 2);" +"            if (graphic != null)" +"                graphic.SetVerticesDirty();" +"        }" +"    }" +"" +"    public int sampleIncrement" +"    {" +"        get" +"        {" +"            return m_sampleIncrement;" +"        }" +"" +"        set" +"        {" +"            m_sampleIncrement = Mathf.Max(value, 1);" +"            if (graphic != null)" +"                graphic.SetVerticesDirty();" +"        }" +"    }" +"" +"    public override void ModifyVertices(List<UIVertex> verts)" +"    {" +"        if (!IsActive())" +"            return;" +"" +"        var total = (m_firstSample * 2 + m_sampleIncrement * (m_circleCount - 1)) * m_circleCount / 2;" +"        var neededCapacity = verts.Count * (total + 1);" +"        if (verts.Capacity < neededCapacity)" +"            verts.Capacity = neededCapacity;" +"        var original = verts.Count;" +"        var count = 0;" +"        var sampleCount = m_firstSample;" +"        var dx = effectDistance.x / circleCount;" +"        var dy = effectDistance.y / circleCount;" +"        for (int i = 1; i <= m_circleCount; i++)" +"        {" +"            var rx = dx * i;" +"            var ry = dy * i;" +"            var radStep = 2 * Mathf.PI / sampleCount;" +"            var rad = (i % 2) * radStep * 0.5f;" +"            for (int j = 0; j < sampleCount; j++)" +"            {" +"                var next = count + original;" +"                ApplyShadow(verts, effectColor, count, next, rx * Mathf.Cos(rad), ry * Mathf.Sin(rad));" +"                count = next;" +"                rad += radStep;" +"            }" +"            sampleCount += m_sampleIncrement;" +"        }" +"    }" +"}" 
  }
,
  {
    "fileName": "ListPool.cs",
    "relativeFilePath": "Assets/Scripts/UI/Outlines/ListPool.cs",
    "type": "script",
    "content": "﻿using System;" +"using System.Collections.Generic;" +"using UnityEngine;" +"" +"static class ListPool<T>" +"{" +"    // Object pool to avoid allocations." +"    private static readonly ObjectPool<List<T>> s_ListPool = new ObjectPool<List<T>>(null, l => l.Clear());" +"" +"    public static List<T> Get()" +"    {" +"        return s_ListPool.Get();" +"    }" +"" +"    public static void Release(List<T> toRelease)" +"    {" +"        s_ListPool.Release(toRelease);" +"    }" +"}" 
  }
,
  {
    "fileName": "ModifiedShadow.cs",
    "relativeFilePath": "Assets/Scripts/UI/Outlines/ModifiedShadow.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using UnityEngine.UI;" +"using System.Collections.Generic;" +"" +"/// <summary>" +"/// The behaviour of this class is almost the same as the original except:" +"/// 1. It absorbs version differences." +"/// 2. It corrects the calculation of vertex list capacity (Unity 5.3 or older)." +"/// </summary>" +"public class ModifiedShadow : Shadow" +"{" +"#if !UNITY_5_4_OR_NEWER" +"    protected new void ApplyShadow(List<UIVertex> verts, Color32 color, int start, int end, float x, float y)" +"    {" +"        UIVertex vt;" +"" +"        // The capacity calculation of the original version seems wrong." +"        var neededCpacity = verts.Count + (end - start);" +"        if (verts.Capacity < neededCpacity)" +"            verts.Capacity = neededCpacity;" +"" +"        for (int i = start; i < end; ++i)" +"        {" +"            vt = verts[i];" +"            verts.Add(vt);" +"" +"            Vector3 v = vt.position;" +"            v.x += x;" +"            v.y += y;" +"            vt.position = v;" +"            var newColor = color;" +"            if (useGraphicAlpha)" +"                newColor.a = (byte)((newColor.a * verts[i].color.a) / 255);" +"            vt.color = newColor;" +"            verts[i] = vt;" +"        }" +"    }" +"#endif" +"" +"#if UNITY_5_2 && !UNITY_5_2_1pX" +"    public override void ModifyMesh(Mesh mesh)" +"    {" +"        if (!this.IsActive())" +"            return;" +"" +"        using (var vh = new VertexHelper(mesh))" +"        {" +"            ModifyMesh(vh);" +"            vh.FillMesh(mesh);" +"        }" +"    }" +"#endif" +"" +"#if !(UNITY_4_6 || UNITY_4_7 || UNITY_5_0 || UNITY_5_1)" +"#if UNITY_5_2_1pX || UNITY_5_3_OR_NEWER" +"    public override void ModifyMesh(VertexHelper vh)" +"#else" +"    public void ModifyMesh(VertexHelper vh)" +"#endif" +"    {" +"        if (!this.IsActive())" +"            return;" +"" +"        var list = ListPool<UIVertex>.Get();" +"        vh.GetUIVertexStream(list);" +"" +"        ModifyVertices(list);" +"" +"#if UNITY_5_2_1pX || UNITY_5_3_OR_NEWER" +"        vh.Clear();" +"#endif" +"        vh.AddUIVertexTriangleStream(list);" +"        ListPool<UIVertex>.Release(list);" +"    }" +"" +"    public virtual void ModifyVertices(List<UIVertex> verts)" +"    {" +"    }" +"#endif" +"}" 
  }
,
  {
    "fileName": "ObjectPool.cs",
    "relativeFilePath": "Assets/Scripts/UI/Outlines/ObjectPool.cs",
    "type": "script",
    "content": "﻿using System.Collections.Generic;" +"using UnityEngine;" +"using UnityEngine.Events;" +"" +"public class ObjectPool<T> where T : new()" +"{" +"    private readonly Stack<T> m_Stack = new Stack<T>();" +"    private readonly UnityAction<T> m_ActionOnGet;" +"    private readonly UnityAction<T> m_ActionOnRelease;" +"" +"    public int countAll { get; private set; }" +"    public int countActive { get { return countAll - countInactive; } }" +"    public int countInactive { get { return m_Stack.Count; } }" +"" +"    public ObjectPool(UnityAction<T> actionOnGet, UnityAction<T> actionOnRelease)" +"    {" +"        m_ActionOnGet = actionOnGet;" +"        m_ActionOnRelease = actionOnRelease;" +"    }" +"" +"    public T Get()" +"    {" +"        T element;" +"        if (m_Stack.Count == 0)" +"        {" +"            element = new T();" +"            countAll++;" +"        }" +"        else" +"        {" +"            element = m_Stack.Pop();" +"        }" +"        if (m_ActionOnGet != null)" +"            m_ActionOnGet(element);" +"        return element;" +"    }" +"" +"    public void Release(T element)" +"    {" +"        if (m_Stack.Count > 0 && ReferenceEquals(m_Stack.Peek(), element))" +"            Debug.LogError(\"Internal error. Trying to destroy object that is already released to pool.\");" +"        if (m_ActionOnRelease != null)" +"            m_ActionOnRelease(element);" +"        m_Stack.Push(element);" +"    }" +"}" 
  }
,
  {
    "fileName": "Outline8.cs",
    "relativeFilePath": "Assets/Scripts/UI/Outlines/Outline8.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using UnityEngine.UI;" +"using System.Collections.Generic;" +"" +"public class Outline8 : ModifiedShadow" +"{" +"    public override void ModifyVertices(List<UIVertex> verts)" +"    {" +"        if (!IsActive())" +"            return;" +"" +"        var neededCapacity = verts.Count * 9;" +"        if (verts.Capacity < neededCapacity)" +"            verts.Capacity = neededCapacity;" +"" +"        var original = verts.Count;" +"        var count = 0;" +"        for (int x = -1; x <= 1; x++)" +"        {" +"            for (int y = -1; y <= 1; y++)" +"            {" +"                if (!(x == 0 && y == 0))" +"                {" +"                    var next = count + original;" +"                    ApplyShadow(verts, effectColor, count, next, effectDistance.x * x, effectDistance.y * y);" +"                    count = next;" +"                }" +"            }" +"        }" +"    }" +"}" 
  }
,
  {
    "fileName": "ViewportDimensions.cs",
    "relativeFilePath": "Assets/Scripts/ViewportDimensions.cs",
    "type": "script",
    "content": "using UnityEngine;" +"" +"public class ViewportDimensions : MonoBehaviour" +"{ public Camera mainCamera;" +"    public float distanceFromCamera = 5.0f;" +"    public float canvasScale = 0.005f;" +"" +"    void Start()" +"    {" +"        // Calculate the viewport's height and width in world units at the given distance from the camera" +"        float viewportHeight = 2.0f * distanceFromCamera * Mathf.Tan(mainCamera.fieldOfView * 0.5f * Mathf.Deg2Rad);" +"        float viewportWidth = viewportHeight * mainCamera.aspect;" +"" +"        // Calculate the required width and height for the canvas in world units" +"        float canvasWidth = viewportWidth / canvasScale;" +"        float canvasHeight = viewportHeight / canvasScale;" +"" +"        // Set the canvas width and height" +"       Debug.Log(\$\"width: {canvasWidth}, height: {canvasHeight}\");" +"    }" +"    " +"}" 
  }
,
  {
    "fileName": "BetterCardRotation.cs",
    "relativeFilePath": "Assets/Scripts/Visual/BetterCardRotation.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"/// <summary>" +"/// This script should be attached to the card game object to display card\`s rotation correctly." +"/// </summary>" +"" +"[ExecuteInEditMode]" +"public class BetterCardRotation : MonoBehaviour {" +"" +"    // parent game object for all the card face graphics" +"    public RectTransform CardFront;" +"" +"    // parent game object for all the card back graphics" +"    public RectTransform CardBack;" +"" +"    // an empty game object that is placed a bit above the face of the card, in the center of the card" +"    public Transform targetFacePoint;" +"" +"    public LayerMask cardLayer;" +"" +"    // 3d collider attached to the card (2d colliders like BoxCollider2D won\`t work in this case)" +"    [SerializeField]" +"    private Collider col;" +"    private Transform mainCameraTransform;" +"" +"    // if this is true, our players currently see the card Back" +"    private bool showingBack = false;" +"" +"    void Start() {" +"        mainCameraTransform = Camera.main.transform;" +"    }" +"" +"	// Update is called once per frame" +"	void Update () " +"    {" +"        // Raycast from Camera to a target point on the face of the card" +"        // If it passes through the card\`s collider, we should show the back of the card" +"        RaycastHit[] hits;" +"        hits = Physics.RaycastAll(origin: mainCameraTransform.position, " +"                                  direction: (-mainCameraTransform.position + targetFacePoint.position).normalized, " +"            maxDistance: (-mainCameraTransform.position + targetFacePoint.position).magnitude) ;" +"        bool passedThroughColliderOnCard = false;" +"        foreach (RaycastHit h in hits)" +"        {" +"            if (h.collider == col)" +"                passedThroughColliderOnCard = true;" +"        }" +"        //Debug.Log(\"TotalHits: \" + hits.Length); " +"        if (passedThroughColliderOnCard!= showingBack)" +"        {" +"            // something changed" +"            showingBack = passedThroughColliderOnCard;" +"            CardFront.gameObject.SetActive(!showingBack);" +"            CardBack.gameObject.SetActive(showingBack);" +"        }" +"" +"	}" +"}" 
  }
,
  {
    "fileName": "CreatureAttackVisual.cs",
    "relativeFilePath": "Assets/Scripts/Visual/CreatureAttackVisual.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using DG.Tweening;" +"" +"public class CreatureAttackVisual : MonoBehaviour " +"{" +"    private OneCreatureManager manager;" +"    private WhereIsTheCardOrCreature w;" +"" +"    void Awake()" +"    {" +"        manager = GetComponent<OneCreatureManager>();    " +"        w = GetComponent<WhereIsTheCardOrCreature>();" +"    }" +"" +"    public void AttackTarget(int targetUniqueID, int damageTakenByTarget, int damageTakenByAttacker, int attackerHealthAfter, int targetHealthAfter)" +"    {" +"        Debug.Log(targetUniqueID);" +"        manager.CanAttackNow = false;" +"        GameObject target = IDHolder.GetGameObjectWithID(targetUniqueID);" +"" +"        // bring this creature to front sorting-wise." +"        w.BringToFront();" +"        VisualStates tempState = w.VisualState;" +"        w.VisualState = VisualStates.Transition;" +"" +"        transform.DOMove(target.transform.position, 0.5f).SetLoops(2, LoopType.Yoyo).SetEase(Ease.InCubic).OnComplete(() =>" +"            {" +"                if(damageTakenByTarget>0)" +"                    DamageEffect.CreateDamageEffect(target.transform.position, damageTakenByTarget);" +"                if(damageTakenByAttacker>0)" +"                    DamageEffect.CreateDamageEffect(transform.position, damageTakenByAttacker);" +"                " +"                if (targetUniqueID == GlobalSettings.Instance.LowPlayer.PlayerID || targetUniqueID == GlobalSettings.Instance.TopPlayer.PlayerID)" +"                {" +"                    // target is a player" +"                    target.GetComponent<PlayerPortraitVisual>().HealthText.text = targetHealthAfter.ToString();" +"                }" +"                else" +"                    target.GetComponent<OneCreatureManager>().HealthText.text = targetHealthAfter.ToString();" +"" +"                w.SetTableSortingOrder();" +"                w.VisualState = tempState;" +"" +"                manager.HealthText.text = attackerHealthAfter.ToString();" +"                Sequence s = DOTween.Sequence();" +"                s.AppendInterval(1f);" +"                s.OnComplete(Command.CommandExecutionComplete);" +"                //Command.CommandExecutionComplete();" +"            });" +"    }" +"        " +"}" 
  }
,
  {
    "fileName": "DamageEffect.cs",
    "relativeFilePath": "Assets/Scripts/Visual/DamageEffect.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using System.Collections.Generic;" +"using UnityEngine.UI;" +"using DG.Tweening;" +"" +"/// <summary>" +"/// This class will show damage dealt to creatures or payers" +"/// </summary>" +"" +"public class DamageEffect : MonoBehaviour {" +"" +"    // an array of sprites with different blood splash graphics" +"    public Sprite[] Splashes;" +"" +"    // a UI image to show the blood splashes" +"    public Image DamageImage;" +"" +"    // CanvasGropup should be attached to the Canvas of this damage effect" +"    // It is used to fade away the alpha value of this effect" +"" +"    [SerializeField] private CanvasGroup canvasGroup;" +"    [SerializeField] private Text damageText;" +"" +"    private const float displayDuration = 0.7f; // how long to display before starting fade" +"    private const float fadeDuration = 0.3f; // how long to fade" +"" +"" +"    private void Start()" +"    {" +"       // DamageImage.sprite = Splashes[Random.Range(0, Splashes.Length)];  " +"        // Start the sequence immediately when the DamageEffect is instantiated" +"       StartEffectSequence();" +"    }" +"" +"    public void SetDamage(int damage)" +"    {" +"        damageText.text = damage.ToString();" +"    }" +"" +"    private void StartEffectSequence()" +"    {" +"        // Display for a duration then start the fade sequence" +"        DOVirtual.DelayedCall(displayDuration, () =>" +"        {" +"            FadeAndDestroy();" +"        });" +"    }" +"" +"    private void FadeAndDestroy()" +"    {" +"        // Fade out and then destroy the game object" +"        canvasGroup.DOFade(0, fadeDuration).OnComplete(() => Destroy(gameObject));" +"    }" +"" +"   " +"    public static void CreateDamageEffect(Vector3 position, int amount)" +"    {" +"        // Instantiate a DamageEffect from prefab" +"        GameObject newDamageEffect = GameObject.Instantiate(GlobalSettings.Instance.DamageEffectPrefab, position, Quaternion.identity) as GameObject;" +"        // Get DamageEffect component in this new game object" +"        DamageEffect de = newDamageEffect.GetComponent<DamageEffect>();" +"        // Change the amount text to reflect the amount of damage dealt" +"        de.SetDamage(amount);" +"" +"    " +"    }" +"}" 
  }
,
  {
    "fileName": "DamageEffectTest.cs",
    "relativeFilePath": "Assets/Scripts/Visual/DamageEffectTest.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class DamageEffectTest : MonoBehaviour {" +"" +"    public static DamageEffectTest Instance;" +"" +"    void Awake()" +"    {" +"        Instance = this;" +"    }" +"" +"    void Update()" +"    {" +"        if (Input.GetKeyDown(KeyCode.B))" +"            DamageEffect.CreateDamageEffect(transform.position, Random.Range(1, 100));" +"    }" +"}" 
  }
,
  {
    "fileName": "EndTurnButton.cs",
    "relativeFilePath": "Assets/Scripts/Visual/EndTurnButton.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class EndTurnButton : MonoBehaviour {" +"" +"    public void OnClick()" +"    {" +"            TurnManager.Instance.EndTurn();" +"    }" +"" +"}" 
  }
,
  {
    "fileName": "GlobalSettings.cs",
    "relativeFilePath": "Assets/Scripts/Visual/GlobalSettings.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using System.Collections.Generic;" +"using UnityEngine.UI;" +"using CG.Cards;" +"" +"public class GlobalSettings: MonoBehaviour " +"{" +"    [Header(\"Players\")]" +"    public Player TopPlayer;" +"    public Player LowPlayer;" +"    [Header(\"Colors\")]" +"    public Color32 CardBodyStandardColor;" +"    public Color32 CardRibbonsStandardColor;" +"    public Color32 CardGlowColor;" +"    [Header(\"Numbers and Values\")]" +"    public float CardPreviewTime = 1f;" +"    public float CardTransitionTime= 1f;" +"    public float CardPreviewTimeFast = 0.2f;" +"    public float CardTransitionTimeFast = 0.5f;" +"    [Header(\"Prefabs and Assets\")]" +"    public GameObject NoTargetSpellCardPrefab;" +"    public GameObject TargetedSpellCardPrefab;" +"    public GameObject CreatureCardPrefab;" +"    public GameObject CreaturePrefab;" +"    public GameObject DamageEffectPrefab;" +"    public GameObject ExplosionPrefab;" +"    [Header(\"Other\")]" +"    public Button EndTurnButton;" +"    public CardAsset CoinCard;" +"    public GameObject GameOverCanvas;" +"    //public Sprite HeroPowerCrossMark;" +"" +"    public Dictionary<AreaPosition, Player> Players = new Dictionary<AreaPosition, Player>();" +"" +"" +"    // SINGLETON" +"    public static GlobalSettings Instance;" +"" +"    void Awake()" +"    {" +"        Players.Add(AreaPosition.Top, TopPlayer);" +"        Players.Add(AreaPosition.Low, LowPlayer);" +"        Instance = this;" +"    }" +"" +"    public bool CanControlThisPlayer(AreaPosition owner)" +"    {" +"        bool PlayersTurn = (TurnManager.Instance.whoseTurn == Players[owner]);" +"        bool NotDrawingAnyCards = !Command.CardDrawPending();" +"        return Players[owner].PArea.AllowedToControlThisPlayer && Players[owner].PArea.ControlsON && PlayersTurn && NotDrawingAnyCards;" +"    }" +"" +"    public bool CanControlThisPlayer(Player ownerPlayer)" +"    {" +"        bool PlayersTurn = (TurnManager.Instance.whoseTurn == ownerPlayer);" +"        bool NotDrawingAnyCards = !Command.CardDrawPending();" +"        return ownerPlayer.PArea.AllowedToControlThisPlayer && ownerPlayer.PArea.ControlsON && PlayersTurn && NotDrawingAnyCards;" +"    }" +"" +"    public void EnableEndTurnButtonOnStart(Player P)" +"    {" +"        if (P == LowPlayer && CanControlThisPlayer(AreaPosition.Low) ||" +"            P == TopPlayer && CanControlThisPlayer(AreaPosition.Top))" +"            EndTurnButton.interactable = true;" +"        else" +"            EndTurnButton.interactable = false;" +"            " +"    }" +"}" 
  }
,
  {
    "fileName": "GlowBlink.cs",
    "relativeFilePath": "Assets/Scripts/Visual/GlowBlink.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"[ExecuteInEditMode]" +"public class GlowBlink : MonoBehaviour " +"{	" +"    [Range(0,30f)]" +"    public float Padding = 0f;" +"" +"    void Update()" +"    {" +"        RectTransform r = transform as RectTransform;" +"        r.offsetMax = new Vector2(-Padding, -Padding);" +"        r.offsetMin = new Vector2(Padding, Padding);" +"    }" +"}" 
  }
,
  {
    "fileName": "HandVisual.cs",
    "relativeFilePath": "Assets/Scripts/Visual/HandVisual.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using System.Collections.Generic;" +"using DG.Tweening;" +"using CG.Cards;" +"public class HandVisual : MonoBehaviour" +"{" +"    // PUBLIC FIELDS" +"    public AreaPosition owner;" +"    public bool TakeCardsOpenly = true;" +"    public PositionManager slots;" +"    [SerializeField]" +"    public CardAsset testCardAsset;" +"" +"    [Header(\"Transform References\")]" +"    public Transform DrawPreviewSpot;" +"    public Transform DeckTransform;" +"    public Transform OtherCardDrawSourceTransform;" +"    public Transform PlayPreviewSpot;" +"    private int UniqueID;" +"" +"    // PRIVATE : a list of all card visual representations as GameObjects" +"    private List<GameObject> CardsInHand = new List<GameObject>();" +"    // Define the list to track the slots" +"    List<GameObject> slotTracker = new List<GameObject>();" +"    private readonly int MAX_CARDS_IN_HAND = 9;" +"" +"    // ADDING OR REMOVING CARDS FROM HAND" +"    void Start()" +"    {" +"        // Initialize the slot tracker with nulls" +"        for (int i = 0; i < 9; i++)" +"        {" +"            slotTracker.Add(null);" +"        }" +"        UniqueID = 0;" +"    }" +"    void Update()" +"    {" +"" +"        if (Input.GetKeyDown(KeyCode.R) && CardsInHand.Count > 0)" +"        {" +"            int randomIndex = UnityEngine.Random.Range(0, CardsInHand.Count);" +"            GameObject cardToRemove = CardsInHand[randomIndex];" +"            RemoveCard(cardToRemove);" +"        }" +"    }" +"    private void NullifySlots()" +"    {" +"        for (int i = 0; i < 9; i++)" +"        {" +"            slotTracker[i] = null;" +"        }" +"    }" +"    // add a new card GameObject to hand" +"    public int AddCard(GameObject card)" +"    {" +"        CardsInHand.Add(card);" +"" +"        // parent this card to our Slots GameObject" +"        card.transform.SetParent(slots.transform);" +"" +"        // re-calculate the position of the hand" +"        PlaceCardsOnNewSlotsVirtual();" +"        return slotTracker.IndexOf(card);" +"    }" +"" +"    // remove a card GameObject from hand" +"    public void RemoveCard(GameObject card)" +"    {" +"        // remove a card from the list" +"        CardsInHand.Remove(card);" +"        Destroy(card, 0.1f);" +"" +"        // re-calculate the position of the hand" +"        PlaceCardsOnNewSlotsVirtual();" +"        PlaceCardsOnNewSlotsAnimate(0.5f);" +"    }" +"" +"    // remove card with a given index from hand" +"    public void RemoveCardAtIndex(int index)" +"    {" +"        CardsInHand.RemoveAt(index);" +"        // re-calculate the position of the hand" +"        PlaceCardsOnNewSlotsVirtual();" +"    }" +"" +"    // get a card GameObject with a given index in hand" +"    public GameObject GetCardAtIndex(int index)" +"    {" +"        return CardsInHand[index];" +"    }" +"" +"    // MANAGING CARDS AND SLOTS" +"" +"    void PlaceCardsOnNewSlotsVirtual()" +"    {" +"        int middleIndex = 4;" +"        int totalCards = CardsInHand.Count;" +"        int startIndex, endIndex;" +"        bool isEven = totalCards % 2 == 0;" +"" +"        NullifySlots();" +"        if (isEven)" +"        {" +"            startIndex = middleIndex - totalCards / 2;" +"            endIndex = middleIndex + totalCards / 2;" +"        }" +"        else" +"        {" +"            startIndex = middleIndex - totalCards / 2;" +"            endIndex = middleIndex + totalCards / 2 + 1;" +"        }" +"" +"        for (int i = 0; i < totalCards; i++)" +"        {" +"            int targetSlotIndex = startIndex + i;" +"            if (targetSlotIndex == middleIndex && isEven)" +"            {" +"                startIndex++;" +"                targetSlotIndex++;" +"            }" +"            GameObject g = CardsInHand[i];" +"" +"            // Update the slot tracker" +"            slotTracker[targetSlotIndex] = g;" +"" +"            WhereIsTheCardOrCreature w = g.GetComponent<WhereIsTheCardOrCreature>();" +"            w.Slot = targetSlotIndex;" +"            w.SetHandSortingOrder();" +"        }" +"    }" +"" +"    private void PlaceCardsOnNewSlotsAnimate(float duration)" +"    {" +"        // Iterate over the slotTracker list and move the cards in parallel" +"        for (int i = 0; i < slotTracker.Count; i++)" +"        {" +"            GameObject g = slotTracker[i];" +"            if (g != null) // Check that the slot isn't empty" +"            {" +"                if (owner == AreaPosition.Top)" +"                {" +"                    // Use DOMove to move the card to the position of its new slot" +"                    // Quaternion slotRotation = slots.Children[i].transform.rotation;" +"                    // Quaternion newCardRotation = Quaternion.Euler(slotRotation.eulerAngles.x, slotRotation.eulerAngles.y + 180f, slotRotation.eulerAngles.z);" +"                    g.transform.DOMove(slots.Children[i].transform.position, duration);" +"                    g.transform.DORotate(slots.Children[i].transform.rotation.eulerAngles, 0.1f);" +"                }" +"                else" +"                {" +"                    Sequence seq = DOTween.Sequence();" +"                    seq.Append(g.transform.DOMove(slots.Children[i].transform.position, duration));" +"                    seq.Insert(0f, g.transform.DORotate(slots.Children[i].transform.rotation.eulerAngles, 0.1f));" +"                    seq.OnComplete(Command.CommandExecutionComplete);" +"                    // Use DOMove to move the card to the position of its new slot" +"                    // g.transform.DOMove(slots.Children[i].transform.position, duration);" +"                    // g.transform.DORotate(slots.Children[i].transform.rotation.eulerAngles, 0.1f);" +"                    // Command.CommandExecutionComplete();" +"                }" +"" +"            }" +"        }" +"    }" +"" +"    // CARD DRAW METHODS" +"" +"    // creates a card and returns a new card as a GameObject" +"    GameObject CreateACardAtPosition(CardAsset c, Vector3 position, Vector3 eulerAngles)" +"    {" +"        // Instantiate a card depending on its type" +"        GameObject card;" +"        if (c.MaxHealth > 0)" +"        {" +"            // this card is a creature card" +"            card = GameObject.Instantiate(GlobalSettings.Instance.CreatureCardPrefab, position, Quaternion.Euler(eulerAngles)) as GameObject;" +"        }" +"        else" +"        {" +"            // this is a spell: checking for targeted or non-targeted spell" +"            if (c.Targets == TargetingOptions.NoTarget)" +"                card = GameObject.Instantiate(GlobalSettings.Instance.NoTargetSpellCardPrefab, position, Quaternion.Euler(eulerAngles)) as GameObject;" +"            else" +"            {" +"                card = GameObject.Instantiate(GlobalSettings.Instance.TargetedSpellCardPrefab, position, Quaternion.Euler(eulerAngles)) as GameObject;" +"                // pass targeting options to DraggingActions" +"                DragSpellOnTarget dragSpell = card.GetComponentInChildren<DragSpellOnTarget>();" +"                dragSpell.Targets = c.Targets;" +"            }" +"" +"        }" +"" +"        // apply the look of the card based on the info from CardAsset" +"        OneCardManager manager = card.GetComponent<OneCardManager>();" +"        manager.cardAsset = c;" +"        manager.ReadCardFromAsset();" +"" +"        return card;" +"    }" +"" +"    // gives player a new card from a given position" +"    public void GivePlayerACard(CardAsset c, int UniqueID, bool fast = false, bool fromDeck = true)" +"    {" +"        GameObject card;" +"        if (fromDeck)" +"            card = CreateACardAtPosition(c, DeckTransform.position, new Vector3(0f, -179f, 0f));" +"        else" +"            card = CreateACardAtPosition(c, OtherCardDrawSourceTransform.position, new Vector3(0f, -179f, 0f));" +"        // Check if hand is full" +"        // Suppose 'transform' is the Transform you want to change" +"        if (CardsInHand.Count >= MAX_CARDS_IN_HAND) // Assuming MAX_CARDS_IN_HAND is a constant representing max hand size" +"        {" +"            // Shake and destroy the card at the preview spot" +"            Sequence seq = DOTween.Sequence();" +"            seq.Append(card.transform.DOMove(DrawPreviewSpot.position, GlobalSettings.Instance.CardTransitionTime));" +"            if (TakeCardsOpenly)" +"                seq.Append(card.transform.DORotate(Vector3.zero, 0.2f));" +"            seq.Append(card.transform.DOShakePosition(1, 0.5f, 10, 40, true, false)) // Shake for 1 second with a strength of 0.5" +"              .OnComplete(() =>" +"              {" +"                  HoverPreview.PreviewsAllowed = true;" +"                  Destroy(card);" +"              }); // Destroy the card after shaking" +"            return;" +"        }" +"        // Set a tag to reflect where this card is" +"        foreach (Transform t in card.GetComponentsInChildren<Transform>())" +"            t.tag = owner.ToString() + \"Card\";" +"        // pass this card to HandVisual class" +"        int newIndex = AddCard(card);" +"" +"        // Bring card to front while it travels from draw spot to hand" +"        WhereIsTheCardOrCreature w = card.GetComponent<WhereIsTheCardOrCreature>();" +"        w.BringToFront();" +"        w.Slot = newIndex;" +"        w.VisualState = VisualStates.Transition;" +"" +"        // pass a unique ID to this card." +"        IDHolder id = card.AddComponent<IDHolder>();" +"        id.UniqueID = UniqueID;" +"        float slotsAnimate = 0.5f;" +"        // move card to the hand;" +"        Sequence s = DOTween.Sequence();" +"        if (!fast)" +"        {" +"            // Debug.Log (\"Not fast!!!\");" +"            s.Append(card.transform.DOMove(DrawPreviewSpot.position, GlobalSettings.Instance.CardTransitionTime));" +"            if (TakeCardsOpenly)" +"                s.Append(card.transform.DORotate(Vector3.zero, 0.2f));" +"            // else" +"            //     s.Insert(0f, card.transform.DORotate(new Vector3(0f, 179f, 0f), GlobalSettings.Instance.CardTransitionTime));" +"            s.Insert(1f, card.transform.DOScale(2f, 0.05f)); // scale up in half of the transition time" +"            s.AppendInterval(GlobalSettings.Instance.CardPreviewTime);" +"            s.Append(card.transform.DOScale(1f, 0.05f)); // scale up in half of the transition time" +"            // displace the card so that we can select it in the scene easier." +"            //s.Append(card.transform.DOLocalMove(slots.Children[newIndex].transform.position, GlobalSettings.Instance.CardTransitionTime));" +"        }" +"        else" +"        {" +"            // displace the card so that we can select it in the scene easier." +"            //s.Append(card.transform.DOLocalMove(slots.Children[newIndex].transform.localPosition, GlobalSettings.Instance.CardTransitionTimeFast));" +"            transform.rotation = Quaternion.identity;" +"            slotsAnimate = GlobalSettings.Instance.CardTransitionTimeFast;" +"        }" +"" +"        s.OnComplete(() =>" +"        {" +"            ChangeLastCardStatusToInHand(card, w);" +"            PlaceCardsOnNewSlotsAnimate(slotsAnimate);" +"        });" +"    }" +"" +"    // this method will be called when the card arrived to hand " +"    void ChangeLastCardStatusToInHand(GameObject card, WhereIsTheCardOrCreature w)" +"    {" +"        //Debug.Log(\"Changing state to Hand for card: \" + card.gameObject.name);" +"        if (owner == AreaPosition.Low)" +"            w.VisualState = VisualStates.LowHand;" +"        else" +"            w.VisualState = VisualStates.TopHand;" +"" +"        // set correct sorting order" +"        w.SetHandSortingOrder();" +"        // end command execution for DrawACArdCommand" +"        " +"    }" +"" +"" +"    // PLAYING SPELLS" +"" +"    // 2 Overloaded method to show a spell played from hand" +"    public void PlayASpellFromHand(int CardID)" +"    {" +"        GameObject card = IDHolder.GetGameObjectWithID(CardID);" +"        PlayASpellFromHand(card);" +"    }" +"" +"    public void PlayASpellFromHand(GameObject CardVisual)" +"    {" +"        Command.CommandExecutionComplete();" +"        CardVisual.GetComponent<WhereIsTheCardOrCreature>().VisualState = VisualStates.Transition;" +"        RemoveCard(CardVisual);" +"" +"        CardVisual.transform.SetParent(null);" +"" +"        Sequence s = DOTween.Sequence();" +"        s.Append(CardVisual.transform.DOMove(PlayPreviewSpot.position, 1f));" +"        s.Insert(0f, CardVisual.transform.DORotate(Vector3.zero, 1f));" +"        s.AppendInterval(2f);" +"        s.OnComplete(() =>" +"            {" +"                //Command.CommandExecutionComplete();" +"                Destroy(CardVisual);" +"            });" +"    }" +"" +"" +"}" 
  }
,
  {
    "fileName": "HeroPowerButton.cs",
    "relativeFilePath": "Assets/Scripts/Visual/HeroPowerButton.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class HeroPowerButton : MonoBehaviour {" +"" +"    public AreaPosition owner;" +"" +"    public GameObject Front;" +"    public GameObject Back;" +"" +"    public GameObject Glow;" +"" +"    private bool wasUsed = false;" +"    public bool WasUsedThisTurn" +"    { " +"        get" +"        {" +"            return wasUsed;" +"        } " +"        set" +"        {" +"            wasUsed = value;" +"            if (!wasUsed)" +"            {" +"                Front.SetActive(true);" +"                Back.SetActive(false);" +"            }" +"            else" +"            {" +"                Front.SetActive(false);" +"                Back.SetActive(true);" +"                Highlighted = false;" +"            }" +"        }" +"    }" +"" +"    private bool highlighted = false;" +"    public bool Highlighted" +"    {" +"        get{ return highlighted; }" +"" +"        set" +"        {" +"            highlighted = value;" +"            Glow.SetActive(highlighted);" +"        }" +"    }" +"" +"    void OnMouseDown()" +"    {" +"        if (!WasUsedThisTurn && Highlighted)" +"        {" +"            GlobalSettings.Instance.Players[owner].UseHeroPower();" +"            WasUsedThisTurn= !WasUsedThisTurn;" +"        }" +"    }" +"}" 
  }
,
  {
    "fileName": "HoverPreview.cs",
    "relativeFilePath": "Assets/Scripts/Visual/HoverPreview.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using DG.Tweening;" +"using System.Collections.Generic;" +"" +"public class HoverPreview : MonoBehaviour" +"{" +"    // PUBLIC FIELDS" +"    public GameObject TurnThisOffWhenPreviewing;  // if this is null, will not turn off anything " +"    public Vector3 TargetPosition;" +"    public float TargetScale;" +"    public GameObject previewGameObject;" +"    public bool ActivateInAwake = false;" +"" +"    // PRIVATE FIELDS" +"    private static HoverPreview currentlyViewing = null;" +"" +"    // PROPERTIES WITH UNDERLYING PRIVATE FIELDS" +"    private static Dictionary<int, Sequence> runningSequences = new Dictionary<int, Sequence>();" +"" +"     // Add new serialized field for delay" +"    [SerializeField]" +"    private float previewDelay = 0.5f;" +"" +"    // Add private field for coroutine" +"    private Coroutine previewCoroutine;" +"    private static bool _PreviewsAllowed = true;" +"    public static bool PreviewsAllowed" +"    {" +"        get { return _PreviewsAllowed; }" +"" +"        set" +"        {" +"            //Debug.Log(\"Hover Previews Allowed is now: \" + value);" +"            _PreviewsAllowed = value;" +"            if (!_PreviewsAllowed)" +"                StopAllPreviews();" +"        }" +"    }" +"" +"    private bool _thisPreviewEnabled = false;" +"    public bool ThisPreviewEnabled" +"    {" +"        get { return _thisPreviewEnabled; }" +"" +"        set" +"        {" +"            _thisPreviewEnabled = value;" +"            if (!_thisPreviewEnabled)" +"                StopThisPreview();" +"        }" +"    }" +"" +"    public bool OverCollider { get; set; }" +"" +"    // MONOBEHVIOUR METHODS" +"    void Awake()" +"    {" +"        ThisPreviewEnabled = ActivateInAwake;" +"    }" +"" +"    void OnMouseEnter()" +"    {" +"        // OverCollider = true;" +"        // if (PreviewsAllowed && ThisPreviewEnabled)" +"        //     PreviewThisObject();" +"         OverCollider = true;" +"        if (PreviewsAllowed && ThisPreviewEnabled)" +"            previewCoroutine = StartCoroutine(PreviewWithDelay());" +"    }" +"" +"    void OnMouseExit()" +"    {" +"        // OverCollider = false;" +"" +"        // if (!PreviewingSomeCard())" +"        //     StopAllPreviews();" +"         OverCollider = false;" +"" +"        if (!PreviewingSomeCard())" +"            StopAllPreviews();" +"" +"        // If the preview coroutine has started, stop it." +"        if (previewCoroutine != null)" +"        {" +"            StopCoroutine(previewCoroutine);" +"            previewCoroutine = null;" +"        }" +"    }" +"" +"    // Add new method for Coroutine" +"    IEnumerator PreviewWithDelay()" +"    {" +"        // Wait for the specified delay" +"        yield return new WaitForSeconds(previewDelay);" +"" +"        // Then call the preview method" +"        PreviewThisObject();" +"    }" +"" +"    // OTHER METHODS" +"    void PreviewThisObject()" +"    {" +"        StopAllPreviews();" +"" +"        currentlyViewing = this;" +"        if (!PreviewsAllowed) return;" +"        previewGameObject.SetActive(true);" +"" +"        if (TurnThisOffWhenPreviewing != null)" +"            TurnThisOffWhenPreviewing.SetActive(false);" +"" +"        previewGameObject.transform.localPosition = Vector3.zero;" +"        previewGameObject.transform.localScale = Vector3.one;" +"        // Set rotation to match the inverse rotation of the world" +"        Vector3 previewRotation = transform.eulerAngles;" +"        previewRotation.z = 0;" +"        previewRotation.x = 0;" +"        previewGameObject.transform.rotation = Quaternion.Euler(previewRotation);" +"" +"" +"" +"        // Create or restart the sequence for this HoverPreview" +"        if (!runningSequences.ContainsKey(GetInstanceID()))" +"        {" +"            runningSequences[GetInstanceID()] = DOTween.Sequence();" +"        }" +"        else" +"        {" +"            runningSequences[GetInstanceID()].Restart();" +"        }" +"" +"        Sequence mySequence = runningSequences[GetInstanceID()];" +"        mySequence.Kill();" +"        mySequence = DOTween.Sequence();" +"        mySequence.Append(previewGameObject.transform.DOLocalMove(TargetPosition, 1f).SetEase(Ease.OutQuint));" +"        mySequence.Join(previewGameObject.transform.DOScale(TargetScale, 1f).SetEase(Ease.OutQuint));" +"    }" +"" +"    void StopThisPreview()" +"    {" +"        if (runningSequences.ContainsKey(GetInstanceID()))" +"        {" +"            Sequence mySequence = runningSequences[GetInstanceID()];" +"            mySequence.Kill();" +"            mySequence = DOTween.Sequence();" +"            mySequence.Append(previewGameObject.transform.DOLocalMove(Vector3.zero, 0.2f).SetEase(Ease.InQuint));" +"            mySequence.Join(previewGameObject.transform.DOScale(Vector3.one, 0.2f).SetEase(Ease.InQuint));" +"            mySequence.AppendCallback(() =>" +"            {" +"                previewGameObject.SetActive(false);" +"                if (TurnThisOffWhenPreviewing != null)" +"                    TurnThisOffWhenPreviewing.SetActive(true);" +"            });" +"        }" +"        else" +"        {" +"            previewGameObject.SetActive(false);" +"            previewGameObject.transform.localScale = Vector3.one;" +"            previewGameObject.transform.localPosition = Vector3.zero;" +"            if (TurnThisOffWhenPreviewing != null)" +"                TurnThisOffWhenPreviewing.SetActive(true);" +"        }" +"    }" +"" +"    // STATIC METHODS" +"    private static void StopAllPreviews()" +"    {" +"        if (currentlyViewing != null)" +"        {" +"            // Call StopThisPreview() to handle stopping and animations properly" +"            currentlyViewing.StopThisPreview();" +"            // Clear the currentlyViewing variable" +"            currentlyViewing = null;" +"        }" +"" +"    }" +"" +"    private static bool PreviewingSomeCard()" +"    {" +"        if (!PreviewsAllowed)" +"            return false;" +"" +"        HoverPreview[] allHoverBlowups = GameObject.FindObjectsOfType<HoverPreview>();" +"" +"        foreach (HoverPreview hb in allHoverBlowups)" +"        {" +"            if (hb.OverCollider && hb.ThisPreviewEnabled)" +"                return true;" +"        }" +"" +"        return false;" +"    }" +"" +"" +"}" 
  }
,
  {
    "fileName": "IDFactory.cs",
    "relativeFilePath": "Assets/Scripts/Visual/IDFactory.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using System.Collections.Generic;" +"" +"public static class IDFactory {" +"" +"    public static int Count;" +"" +"    public static int GetUniqueID()" +"    {" +"        // Count++ has to go first, otherwise - unreachable code." +"        Count++;" +"        return Count;" +"    }" +"	" +"    public static void ResetIDs()" +"    {" +"        Count = 0;" +"    }" +"" +"" +"}" 
  }
,
  {
    "fileName": "ManaPoolVisual.cs",
    "relativeFilePath": "Assets/Scripts/Visual/ManaPoolVisual.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using UnityEngine.UI;" +"" +"#if UNITY_EDITOR" +"using UnityEditor;" +"#endif" +"[ExecuteInEditMode]" +"public class ManaPoolVisual : MonoBehaviour" +"{" +"    public int TestFullCrystals;" +"    public int TestTotalCrystalsThisTurn;" +"" +"    public Image[] Crystals;" +"    public Text ProgressText;" +"    private int totalCrystals;" +"    public int TotalCrystals" +"    {" +"        get { return totalCrystals; }" +"        set" +"        {" +"            int clampedValue = Mathf.Clamp(value, 0, Crystals.Length);" +"            if (clampedValue != totalCrystals)" +"            {" +"                totalCrystals = clampedValue;" +"                UpdateCrystals();" +"            }" +"        }" +"    }" +"" +"    private int availableCrystals;" +"    public int AvailableCrystals" +"    {" +"        get { return availableCrystals; }" +"        set" +"        {" +"            int clampedValue = Mathf.Clamp(value, 0, totalCrystals);" +"            if (clampedValue != availableCrystals)" +"            {" +"                availableCrystals = clampedValue;" +"                UpdateCrystals();" +"            }" +"        }" +"    }" +"" +"" +"" +"    private readonly string progressTextFormat = \"{0}/{1}\";" +"" +"    void Update()" +"    {" +"#if UNITY_EDITOR" +"        if (Application.isEditor && !Application.isPlaying)" +"        {" +"            TotalCrystals = TestTotalCrystalsThisTurn;" +"            AvailableCrystals = TestFullCrystals;" +"        }" +"#endif" +"    }" +"" +"    private void UpdateCrystals()" +"    {" +"        for (int i = 0; i < Crystals.Length; i++)" +"        {" +"            if (i < totalCrystals)" +"            {" +"                Crystals[i].color = i < availableCrystals ? Color.white : Color.gray;" +"            }" +"            else" +"            {" +"                Crystals[i].color = Color.clear;" +"            }" +"        }" +"" +"        UpdateProgressText();" +"    }" +"" +"    private void UpdateProgressText()" +"    {" +"        ProgressText.text = string.Format(progressTextFormat, availableCrystals, totalCrystals);" +"    }" +"}" 
  }
,
  {
    "fileName": "MessageManager.cs",
    "relativeFilePath": "Assets/Scripts/Visual/MessageManager.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using UnityEngine.UI;" +"using DG.Tweening;" +"" +"public class MessageManager : MonoBehaviour " +"{" +"    public Text MessageText;" +"    public GameObject MessagePanel;" +"    private CanvasGroup canvasGroup;" +"" +"    // Serialized fields" +"    [SerializeField]" +"    private float fadeDuration = 1f; // default value is 1" +"    [SerializeField]" +"    private float scaleDuration = 1f; // default value is 1" +"    [SerializeField]" +"    private float scaleValue = 1.2f; // default value is 1.2" +"" +"    public static MessageManager Instance;" +"" +"    void Awake()" +"    {" +"        Instance = this;" +"        MessagePanel.SetActive(false);" +"        canvasGroup = MessagePanel.GetComponent<CanvasGroup>();" +"    }" +"" +"    public void ShowMessage(string Message, float Duration)" +"    {" +"        StartCoroutine(ShowMessageCoroutine(Message, Duration));" +"        Command.CommandExecutionComplete();" +"    }" +"" +"    IEnumerator ShowMessageCoroutine(string Message, float Duration)" +"    {" +"        MessageText.text = Message;" +"        MessagePanel.SetActive(true);" +"" +"        // Fade in and scale up" +"        canvasGroup.DOFade(1, fadeDuration);" +"        MessageText.transform.DOScale(scaleValue, scaleDuration).SetLoops(2, LoopType.Yoyo);" +"" +"        yield return new WaitForSeconds(Duration);" +"" +"        // Fade out" +"        canvasGroup.DOFade(0, fadeDuration)" +"        .OnComplete(() => {" +"            MessagePanel.SetActive(false);" +"            canvasGroup.alpha = 1f; // reset the transparency to be ready for the next message" +"        });" +"    }" +"    " +"    private void Update() {" +"        if (Input.GetKeyDown(KeyCode.Y)) {" +"            ShowMessage(\"Your Turn\", 3f);" +"        }" +"        if (Input.GetKeyDown(KeyCode.E)) {" +"            ShowMessage(\"Enemy Turn\", 3f);" +"        }" +"    }" +"}" 
  }
,
  {
    "fileName": "MoveAlongPath.cs",
    "relativeFilePath": "Assets/Scripts/Visual/MoveAlongPath.cs",
    "type": "script",
    "content": "using UnityEngine;" +"using DG.Tweening;" +"" +"public class MoveAlongPath : MonoBehaviour" +"{" +"    [SerializeField] private DOTweenPath path;" +"    [SerializeField] private float duration = 5f;" +"" +"    private void Start()" +"    {" +"        Vector3[] pathPoints = path.wps.ToArray();" +"        transform.DOScale(Vector3.zero, 0);" +"        transform.DOPath(pathPoints, duration, path.pathType)" +"            .OnWaypointChange(waypointIndex => {" +"                transform.DOScale(Vector3.one * (waypointIndex + 1) / (float)pathPoints.Length, 0.5f);" +"            });" +"    }" +"}" 
  }
,
  {
    "fileName": "OneCardManager.cs",
    "relativeFilePath": "Assets/Scripts/Visual/OneCardManager.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using UnityEngine.UI;" +"using CG.Cards;" +"using System.Text;" +"// holds the refs to all the Text, Images on the card" +"public class OneCardManager : MonoBehaviour {" +"" +"    public CardAsset cardAsset;" +"    public OneCardManager PreviewManager;" +"    [Header(\"Text Component References\")]" +"    public Text NameText;" +"    public Text ManaCostText;" +"    public Text DescriptionText;" +"    public Text HealthText;" +"    public Text AttackText;" +"    public Text CardTypeText;" +" " +"    [Header(\"Image References\")]" +"    public Image CardTopRibbonImage;" +"    public Image CardLowRibbonImage;" +"    public Image CardGraphicImage;" +"    " +"    public Image CardBodyImage;" +"    public Image CardFaceFrameImage;" +"    public Image CardFaceGlowImage;" +"    public Image CardBackGlowImage;" +"" +"    void Awake()" +"    {" +"        if (cardAsset != null)" +"            ReadCardFromAsset();" +"    }" +"" +"    private bool canBePlayedNow = false;" +"    public bool CanBePlayedNow" +"    {" +"        get" +"        {" +"            return canBePlayedNow;" +"        }" +"" +"        set" +"        {" +"            canBePlayedNow = value;" +"" +"            CardFaceGlowImage.enabled = value;" +"        }" +"    }" +"" +"    public void ReadCardFromAsset()" +"    {" +"        // universal actions for any Card" +"        // 1) apply tint" +"        if (cardAsset.characterAsset != null)" +"        {" +"            CardBodyImage.color = cardAsset.characterAsset.ClassCardTint;" +"            CardFaceFrameImage.color = cardAsset.characterAsset.ClassCardTint;" +"            CardTopRibbonImage.color = cardAsset.characterAsset.ClassRibbonsTint;" +"            CardLowRibbonImage.color = cardAsset.characterAsset.ClassRibbonsTint;" +"        }" +"        else" +"        {" +"            CardFaceFrameImage.color = Color.white;" +"        }" +"        // 2) add card name" +"        NameText.text = cardAsset.name;" +"        // 3) add mana cost" +"        ManaCostText.text = cardAsset.ManaCost.ToString();" +"        // 4) add description" +"        DescriptionText.text = cardAsset.Description;" +"        // 5) Change the card graphic sprite" +"        CardGraphicImage.sprite = cardAsset.CardImage;" +"        CardTypeText.text = EnumToStringWithSpaces(cardAsset.CardType);" +"" +"        if (cardAsset.MaxHealth != 0)" +"        {" +"            // this is a creature" +"            AttackText.text = cardAsset.Attack.ToString();" +"            HealthText.text = cardAsset.MaxHealth.ToString();" +"        }" +"" +"        if (PreviewManager != null)" +"        {" +"            // this is a card and not a preview" +"            // Preview GameObject will have OneCardManager as well, but PreviewManager should be null there" +"            PreviewManager.cardAsset = cardAsset;" +"            PreviewManager.ReadCardFromAsset();" +"        }" +"    }" +"    public static string EnumToStringWithSpaces(ECardType value)" +"{" +"    string input = value.ToString();" +"    StringBuilder output = new StringBuilder();" +"" +"    for (int i = 0; i < input.Length; i++)" +"    {" +"        if (i > 0 && char.IsUpper(input[i]))" +"        {" +"            output.Append(' ');" +"        }" +"        output.Append(input[i]);" +"    }" +"" +"    return output.ToString();" +"}" +"}" 
  }
,
  {
    "fileName": "OneCreatureManager.cs",
    "relativeFilePath": "Assets/Scripts/Visual/OneCreatureManager.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using UnityEngine.UI;" +"using CG.Cards;" +"" +"public class OneCreatureManager : MonoBehaviour " +"{" +"    public CardAsset cardAsset;" +"    public OneCardManager PreviewManager;" +"    [Header(\"Text Component References\")]" +"    public Text HealthText;" +"    public Text AttackText;" +"    [Header(\"Image References\")]" +"    public Image CreatureGraphicImage;" +"    public Image CreatureGlowImage;" +"" +"    void Awake()" +"    {" +"        if (cardAsset != null)" +"            ReadCreatureFromAsset();" +"    }" +"" +"    private bool canAttackNow = false;" +"    public bool CanAttackNow" +"    {" +"        get" +"        {" +"            return canAttackNow;" +"        }" +"" +"        set" +"        {" +"            canAttackNow = value;" +"" +"            CreatureGlowImage.enabled = value;" +"        }" +"    }" +"" +"    public void ReadCreatureFromAsset()" +"    {" +"        // Change the card graphic sprite" +"        CreatureGraphicImage.sprite = cardAsset.CardImage;" +"" +"        AttackText.text = cardAsset.Attack.ToString();" +"        HealthText.text = cardAsset.MaxHealth.ToString();" +"" +"        if (PreviewManager != null)" +"        {" +"            PreviewManager.cardAsset = cardAsset;" +"            PreviewManager.ReadCardFromAsset();" +"        }" +"    }	" +"" +"    public void TakeDamage(int amount, int healthAfter)" +"    {" +"        if (amount > 0)" +"        {" +"            //DamageEffect.CreateDamageEffect(transform.position, amount);" +"            HealthText.text = healthAfter.ToString();" +"        }" +"    }" +"}" 
  }
,
  {
    "fileName": "PlayerArea.cs",
    "relativeFilePath": "Assets/Scripts/Visual/PlayerArea.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public enum AreaPosition{Top, Low}" +"" +"public class PlayerArea : MonoBehaviour " +"{" +"    public AreaPosition owner;" +"    public bool ControlsON = true;" +"    public PlayerDeckVisual PDeck;" +"    public ManaPoolVisual ManaBar;" +"    public HandVisual handVisual;" +"    public PlayerPortraitVisual Portrait;" +"    public HeroPowerButton HeroPower;" +"    public TableVisual tableVisual;" +"    public Transform PortraitPosition;" +"" +"    public bool AllowedToControlThisPlayer" +"    {" +"        get;" +"        set;" +"    }      " +"" +"" +"}" 
  }
,
  {
    "fileName": "PlayerDeckVisual.cs",
    "relativeFilePath": "Assets/Scripts/Visual/PlayerDeckVisual.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using DG.Tweening;" +"" +"// this class should be attached to the deck" +"// generates new cards and places them into the hand" +"public class PlayerDeckVisual : MonoBehaviour {" +"" +"    public AreaPosition owner;" +"    public float HeightOfOneCard = 0.012f;" +"" +"    void Start()" +"    {" +"        CardsInDeck = GlobalSettings.Instance.Players[owner].deck.cards.Count;" +"    }" +"" +"    private int cardsInDeck = 0;" +"    public int CardsInDeck" +"    {" +"        get{ return cardsInDeck; }" +"" +"        set" +"        {" +"            cardsInDeck = value;" +"            transform.position = new Vector3(transform.position.x, transform.position.y, - HeightOfOneCard * value);" +"        }" +"    }" +"   " +"}" 
  }
,
  {
    "fileName": "PlayerPortraitVisual.cs",
    "relativeFilePath": "Assets/Scripts/Visual/PlayerPortraitVisual.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using UnityEngine.UI;" +"using DG.Tweening;" +"" +"public class PlayerPortraitVisual : MonoBehaviour" +"{" +"" +"    // TODO : get ID from players when game starts" +"" +"    public CharacterAsset charAsset;" +"    [Header(\"Text Component References\")]" +"    //public Text NameText;" +"    public Text HealthText;" +"    [Header(\"Image References\")]" +"    public Image HeroPowerIconImage;" +"    public Image HeroPowerBackgroundImage;" +"    public Image PortraitImage;" +"    public Image PortraitBackgroundImage;" +"" +"    private void Awake()" +"    {" +"        if (charAsset != null)" +"        {" +"            ApplyLookFromAsset();" +"        }" +"    }" +"    public void ApplyLookFromAsset()" +"    {" +"        HealthText.text = charAsset.MaxHealth.ToString();" +"        HeroPowerIconImage.sprite = charAsset.HeroPowerIconImage;" +"        HeroPowerBackgroundImage.sprite = charAsset.HeroPowerBGImage;" +"        PortraitImage.sprite = charAsset.AvatarImage;" +"        PortraitBackgroundImage.sprite = charAsset.AvatarBGImage;" +"" +"        HeroPowerBackgroundImage.color = charAsset.HeroPowerBGTint;" +"        PortraitBackgroundImage.color = charAsset.AvatarBGTint;" +"" +"    }" +"" +"    public void TakeDamage(int amount, int healthAfter)" +"    {" +"        if (amount > 0)" +"        {" +"            //DamageEffect.CreateDamageEffect(transform.position, amount);" +"            HealthText.text = healthAfter.ToString();" +"        }" +"    }" +"" +"    public void Explode()" +"    {" +"        /*" +"        Instantiate(GlobalSettings.Instance.ExplosionPrefab, transform.position, Quaternion.identity);" +"        Sequence s = DOTween.Sequence();" +"        s.PrependInterval(2f);" +"        s.OnComplete(() => GlobalSettings.Instance.GameOverCanvas.SetActive(true));" +"        */" +"    }" +"" +"" +"" +"}" 
  }
,
  {
    "fileName": "PositionManager.cs",
    "relativeFilePath": "Assets/Scripts/Visual/PositionManager.cs",
    "type": "script",
    "content": "using UnityEngine;" +"public class PositionManager : MonoBehaviour" +"{" +"    private Transform FirstSlot;" +"    private Transform LastSlot;" +"    private Vector3 firstPos, lastPos;" +"    public Transform[] Children;" +"     public AreaPosition owner;" +"    [SerializeField] private float maxRotation = 20f;  // maximum rotation for first and last cards" +"    [SerializeField] private float radiusFactor = 0.5f;  // adjust this value to control the spread of the cards" +"    [SerializeField] private int angleFactor = 12;" +"    [SerializeField] private float yCorrectionFactor = 2f;" +"    // [SerializeField] private float lengthPerCard = 1f;" +"    // [SerializeField] private float maxHandLength = 8f;" +"" +"    private void Awake()" +"    {" +"        UpdateFirstAndLastSlots();" +"        firstPos = FirstSlot.position;" +"        lastPos = LastSlot.position;" +"        PositionSlots();" +"        " +"    }" +"    private void Update() {" +"        //UpdateFirstAndLastSlots();" +"        //PositionSlots();" +"    }" +"    // private void OnTransformChildrenChanged()" +"    // {" +"    //     //UpdateFirstAndLastSlots();" +"    //     PositionSlots();" +"    // }" +"    " +"    private void PositionSlots()" +"    {" +"" +"        float firstRotZ = maxRotation;" +"        float lastRotZ = -maxRotation;" +"        float radius = ((lastPos - firstPos).magnitude / 2f) * radiusFactor;  // radius of the arc" +"        Vector3 centerPos = (lastPos + firstPos) / 2f;  // center of the arc" +"" +"        for (int i = 0; i < Children.Length; i++)" +"        {" +"            Transform child = transform.GetChild(i);" +"            float t = (float)i / (transform.childCount - 1);" +"" +"            // Calculate angle in radians" +"            float angle = Mathf.Lerp(-Mathf.PI / angleFactor, Mathf.PI / angleFactor, t);" +"" +"            // Calculate position on the arc" +"            Vector3 posOnArc = new Vector3(radius * Mathf.Sin(angle), radius * Mathf.Cos(angle) + centerPos.y * yCorrectionFactor, 0f);" +"            child.position = centerPos + posOnArc;" +"" +"            // Calculate rotation" +"            float rotZ = Mathf.Lerp(firstRotZ, lastRotZ, t);" +"            if (owner == AreaPosition.Top) {" +"                child.rotation = Quaternion.Euler(0, 0, rotZ - 180f);" +"            }" +"            else {" +"                child.rotation = Quaternion.Euler(0, 0, rotZ);" +"            }" +"        }" +"    }" +"    private void UpdateFirstAndLastSlots()" +"    {" +"        if (transform.childCount > 0)" +"        {" +"            FirstSlot = transform.GetChild(0);" +"            LastSlot = transform.GetChild(transform.childCount - 1);" +"        }" +"    }" +"}" 
  }
,
  {
    "fileName": "RaycastExample.cs",
    "relativeFilePath": "Assets/Scripts/Visual/RaycastExample.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class RaycastExample : MonoBehaviour {" +"" +"    void Update () {" +"        if (Input.GetMouseButtonDown (0)) {" +"            Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);" +"            RaycastHit hit;" +"            if (Physics.Raycast(ray, out hit)) {" +"                Debug.Log (\"Name = \" + hit.collider.name);" +"                Debug.Log (\"Tag = \" + hit.collider.tag);" +"                Debug.Log (\"Hit Point = \" + hit.point);" +"                Debug.Log (\"Object position = \" + hit.collider.gameObject.transform.position);" +"                Debug.Log (\"--------------\");" +"            }" +"        }" +"    }" +"}" 
  }
,
  {
    "fileName": "RopeVisual.cs",
    "relativeFilePath": "Assets/Scripts/Visual/RopeVisual.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class RopeVisual : MonoBehaviour {" +"" +"	// Use this for initialization" +"	void Start () {" +"	" +"	}" +"	" +"	// Update is called once per frame" +"	void Update () {" +"	" +"	}" +"}" 
  }
,
  {
    "fileName": "SameDistanceChildren.cs",
    "relativeFilePath": "Assets/Scripts/Visual/SameDistanceChildren.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"// place first and last elements in children array manually" +"// others will be placed automatically with equal distances between first and last elements" +"public class SameDistanceChildren : MonoBehaviour {" +"" +"    public Transform[] Children;" +"" +"	// Use this for initialization" +"	void Awake () " +"    {" +"        Vector3 firstElementPos = Children[0].transform.position;" +"        Vector3 lastElementPos = Children[Children.Length - 1].transform.position;" +"" +"        // dividing by Children.Length - 1 because for example: between 10 points that are 9 segments" +"        float XDist = (lastElementPos.x - firstElementPos.x)/(float)(Children.Length - 1);" +"        float YDist = (lastElementPos.y - firstElementPos.y)/(float)(Children.Length - 1);" +"        float ZDist = (lastElementPos.z - firstElementPos.z)/(float)(Children.Length - 1);" +"" +"        Vector3 Dist = new Vector3(XDist, YDist, ZDist);" +"" +"        for (int i = 1; i < Children.Length; i++)" +"        {" +"            Children[i].transform.position = Children[i - 1].transform.position + Dist;" +"        }" +"	}" +"	" +"	" +"}" 
  }
,
  {
    "fileName": "SceneReloader.cs",
    "relativeFilePath": "Assets/Scripts/Visual/SceneReloader.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using UnityEngine.SceneManagement;" +"" +"public class SceneReloader: MonoBehaviour {" +"" +"    public void ReloadScene()" +"    {" +"        // Command has some static members, so let\`s make sure that there are no commands in the Queue" +"        Debug.Log(\"Scene reloaded\");" +"        // reset all card and creature IDs" +"        IDFactory.ResetIDs();" +"        IDHolder.ClearIDHoldersList();" +"        Command.CommandQueue.Clear();" +"        Command.CommandExecutionComplete();" +"        SceneManager.LoadScene(SceneManager.GetActiveScene().name);" +"    }" +"}" 
  }
,
  {
    "fileName": "ShufflingExtention.cs",
    "relativeFilePath": "Assets/Scripts/Visual/ShufflingExtention.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using System.Collections.Generic;" +"" +"public static class ShufflingExtention {" +"" +"    // not my code!!!!!" +"    // got it here: http://stackoverflow.com/questions/273313/randomize-a-listt/1262619#1262619 " +"    private static System.Random rng = new System.Random();" +"" +"    public static void Shuffle<T>(this IList<T> list)  " +"    {  " +"        int n = list.Count;  " +"        while (n > 1) {  " +"            n--;  " +"            int k = rng.Next(n + 1);  " +"            T value = list[k];  " +"            list[k] = list[n];  " +"            list[n] = value;  " +"        }  " +"    }" +"}" 
  }
,
  {
    "fileName": "TableVisual.cs",
    "relativeFilePath": "Assets/Scripts/Visual/TableVisual.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using System.Collections.Generic;" +"using DG.Tweening;" +"using CG.Cards;" +"" +"public class TableVisual : MonoBehaviour " +"{" +"    // PUBLIC FIELDS" +"" +"    // an enum that mark to whish caracter this table belongs. The alues are - Top or Low" +"    public AreaPosition owner;" +"    public CardAsset testAsset;" +"" +"    // a referense to a game object that marks positions where we should put new Creatures" +"    public SameDistanceChildren slots;" +"" +"    // PRIVATE FIELDS" +"" +"    // list of all the creature cards on the table as GameObjects" +"    private List<GameObject> CreaturesOnTable = new List<GameObject>();" +"" +"    // are we hovering over this table\`s collider with a mouse" +"    private bool cursorOverThisTable = false;" +"" +"    // A 3D collider attached to this game object" +"    private BoxCollider col;" +"    private int UniqueID = 0;" +"    private UniqueIdGenerator generator = new UniqueIdGenerator();" +"    // PROPERTIES" +"" +"    // returns true if we are hovering over any player\`s table collider" +"    public static bool CursorOverSomeTable" +"    {" +"        get" +"        {" +"            TableVisual[] bothTables = GameObject.FindObjectsOfType<TableVisual>();" +"            return (bothTables[0].CursorOverThisTable || bothTables[1].CursorOverThisTable);" +"        }" +"    }" +"" +"    // returns true only if we are hovering over this table\`s collider" +"    public bool CursorOverThisTable" +"    {" +"        get{ return cursorOverThisTable; }" +"    }" +"" +"    // METHODS" +"" +"    // MONOBEHAVIOUR SCRIPTS (mouse over collider detection)" +"    void Awake()" +"    {" +"        col = GetComponent<BoxCollider>();" +"    }" +"" +"    // CURSOR/MOUSE DETECTION" +"    void Update()" +"    {" +"        // we need to Raycast because OnMouseEnter, etc reacts to colliders on cards and cards \"cover\" the table" +"        // create an array of RaycastHits" +"        RaycastHit[] hits;" +"        // raycst to mousePosition and store all the hits in the array" +"        hits = Physics.RaycastAll(Camera.main.ScreenPointToRay(Input.mousePosition), 30f);" +"" +"        bool passedThroughTableCollider = false;" +"        foreach (RaycastHit h in hits)" +"        {" +"            // check if the collider that we hit is the collider on this GameObject" +"            if (h.collider == col)" +"                passedThroughTableCollider = true;" +"        }" +"        cursorOverThisTable = passedThroughTableCollider;" +"" +"        if (Input.GetKeyDown(KeyCode.A))" +"        {" +"            UniqueID++;" +"            AddCreatureAtIndex(testAsset, UniqueID, 0);" +"            " +"        }" +"" +"        if (Input.GetKeyDown(KeyCode.R) && CreaturesOnTable.Count > 0)" +"        {" +"            int randomIndex = generator.GenerateUniqueId(UniqueID);" +"            RemoveCreatureWithID(randomIndex);" +"        }" +"    }" +"   " +"    // method to create a new creature and add it to the table" +"    public void AddCreatureAtIndex(CardAsset ca, int UniqueID ,int index)" +"    {" +"        // create a new creature from prefab" +"        GameObject creature = GameObject.Instantiate(GlobalSettings.Instance.CreaturePrefab, slots.Children[index].transform.position, Quaternion.identity) as GameObject;" +"" +"        // apply the look from CardAsset" +"        OneCreatureManager manager = creature.GetComponent<OneCreatureManager>();" +"        manager.cardAsset = ca;" +"        manager.ReadCreatureFromAsset();" +"" +"        // add tag according to owner" +"        foreach (Transform t in creature.GetComponentsInChildren<Transform>())" +"            t.tag = owner.ToString()+\"Creature\";" +"        " +"        // parent a new creature gameObject to table slots" +"        creature.transform.SetParent(slots.transform);" +"" +"        // add a new creature to the list" +"        CreaturesOnTable.Insert(index, creature);" +"" +"        // let this creature know about its position" +"        WhereIsTheCardOrCreature w = creature.GetComponent<WhereIsTheCardOrCreature>();" +"        w.Slot = index;" +"        w.VisualState = VisualStates.LowTable;" +"" +"        // add our unique ID to this creature" +"        IDHolder id = creature.AddComponent<IDHolder>();" +"        id.UniqueID = UniqueID;" +"" +"        // after a new creature is added update placing of all the other creatures" +"        ShiftSlotsGameObjectAccordingToNumberOfCreatures();" +"        PlaceCreaturesOnNewSlots();" +"" +"        // end command execution" +"        Command.CommandExecutionComplete();" +"    }" +"" +"" +"    // returns an index for a new creature based on mousePosition" +"    // included for placing a new creature to any positon on the table" +"    public int TablePosForNewCreature(float MouseX)" +"    {" +"        // if there are no creatures or if we are pointing to the right of all creatures with a mouse." +"        // right - because the table slots are flipped and 0 is on the right side." +"        if (CreaturesOnTable.Count == 0 || MouseX > slots.Children[0].transform.position.x)" +"            return 0;" +"        else if (MouseX < slots.Children[CreaturesOnTable.Count - 1].transform.position.x) // cursor on the left relative to all creatures on the table" +"            return CreaturesOnTable.Count;" +"        for (int i = 0; i < CreaturesOnTable.Count; i++)" +"        {" +"            if (MouseX < slots.Children[i].transform.position.x && MouseX > slots.Children[i + 1].transform.position.x)" +"                return i + 1;" +"        }" +"        Debug.Log(\"Suspicious behavior. Reached end of TablePosForNewCreature method. Returning 0\");" +"        return 0;" +"    }" +"" +"    // Destroy a creature" +"    public void RemoveCreatureWithID(int IDToRemove)" +"    {" +"        // TODO: This has to last for some time" +"        // Adding delay here did not work because it shows one creature die, then another creature die. " +"        // " +"        //Sequence s = DOTween.Sequence();" +"        //s.AppendInterval(1f);" +"        //s.OnComplete(() =>" +"        //   {" +"                " +"        //    });" +"        GameObject creatureToRemove = IDHolder.GetGameObjectWithID(IDToRemove);" +"        CreaturesOnTable.Remove(creatureToRemove);" +"        Destroy(creatureToRemove);" +"" +"        ShiftSlotsGameObjectAccordingToNumberOfCreatures();" +"        PlaceCreaturesOnNewSlots();" +"        Command.CommandExecutionComplete();" +"    }" +"" +"    /// <summary>" +"    /// Shifts the slots game object according to number of creatures." +"    /// </summary>" +"    void ShiftSlotsGameObjectAccordingToNumberOfCreatures()" +"    {" +"        float posX;" +"        if (CreaturesOnTable.Count > 0)" +"            posX = (slots.Children[0].transform.localPosition.x - slots.Children[CreaturesOnTable.Count - 1].transform.localPosition.x) / 2f;" +"        else" +"            posX = 0f;" +"" +"        slots.gameObject.transform.DOLocalMoveX(posX, 0.3f);  " +"    }" +"" +"    /// <summary>" +"    /// After a new creature is added or an old creature dies, this method" +"    /// shifts all the creatures and places the creatures on new slots." +"    /// </summary>" +"    void PlaceCreaturesOnNewSlots()" +"    {" +"        foreach (GameObject g in CreaturesOnTable)" +"        {" +"            g.transform.DOLocalMoveX(slots.Children[CreaturesOnTable.IndexOf(g)].transform.localPosition.x, 0.3f);" +"            // apply correct sorting order and HandSlot value for later " +"            // TODO: figure out if I need to do something here:" +"            // g.GetComponent<WhereIsTheCardOrCreature>().SetTableSortingOrder() = CreaturesOnTable.IndexOf(g);" +"        }" +"    }" +"" +"}" 
  }
,
  {
    "fileName": "UniqueIdGenerator.cs",
    "relativeFilePath": "Assets/Scripts/Visual/UniqueIdGenerator.cs",
    "type": "script",
    "content": "using System.Collections;" +"using System.Collections.Generic;" +"using UnityEngine;" +"" +"public class UniqueIdGenerator" +"{" +"    private HashSet<int> usedIds;" +"    private int currentMaxId;" +"    private System.Random random;" +"" +"    public UniqueIdGenerator()" +"    {" +"        usedIds = new HashSet<int>();" +"        currentMaxId = 1;" +"        random = new System.Random();" +"    }" +"" +"    public int GenerateUniqueId(int maxId)" +"    {" +"        // If the maxId is greater than the currentMaxId, update the currentMaxId" +"        if(maxId > currentMaxId)" +"        {" +"            currentMaxId = maxId;" +"        }" +"" +"        int newId;" +"        // Generate new ids until we find one that isn't used" +"        do" +"        {" +"            newId = random.Next(1, currentMaxId + 1);" +"        }" +"        while (usedIds.Contains(newId));" +"" +"        // Add the new id to the set of used ids" +"        usedIds.Add(newId);" +"" +"        return newId;" +"    }" +"}" +"" 
  }
,
  {
    "fileName": "WhereIsTheCardOrCreature.cs",
    "relativeFilePath": "Assets/Scripts/Visual/WhereIsTheCardOrCreature.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using System.Collections.Generic;" +"" +"// an enum to store the info about where this object is" +"public enum VisualStates" +"{" +"    Transition," +"    LowHand, " +"    TopHand," +"    LowTable," +"    TopTable," +"    Dragging" +"}" +"" +"public class WhereIsTheCardOrCreature : MonoBehaviour {" +"" +"    // reference to a HoverPreview Component" +"    private HoverPreview hover;" +"" +"    // reference to a canvas on this object to set sorting order" +"    private Canvas canvas;" +"" +"    // a value for canvas sorting order when we want to show this object above everything" +"    private int TopSortingOrder = 500;" +"" +"    // PROPERTIES" +"    private int slot = -1;" +"    public int Slot" +"    {" +"        get{ return slot;}" +"" +"        set" +"        {" +"            slot = value;" +"            /*if (value != -1)" +"            {" +"                canvas.sortingOrder = HandSortingOrder(slot);" +"            }*/" +"        }" +"    }" +"" +"    private VisualStates state;" +"    public VisualStates VisualState" +"    {" +"        get{ return state; }  " +"" +"        set" +"        {" +"            state = value;" +"            switch (state)" +"            {" +"                case VisualStates.LowHand:" +"                    hover.ThisPreviewEnabled = true;" +"                    break;" +"                case VisualStates.LowTable:" +"                case VisualStates.TopTable:" +"                    hover.ThisPreviewEnabled = true;" +"                    break;" +"                case VisualStates.Transition:" +"                    hover.ThisPreviewEnabled = false;" +"                    break;" +"                case VisualStates.Dragging:" +"                    hover.ThisPreviewEnabled = false;" +"                    break;" +"                case VisualStates.TopHand:" +"                    hover.ThisPreviewEnabled = true;" +"                    break;" +"            }" +"        }" +"    }" +"" +"    void Awake()" +"    {" +"        hover = GetComponent<HoverPreview>();" +"        // for characters hover is attached to a child game object" +"        if (hover == null)" +"            hover = GetComponentInChildren<HoverPreview>();" +"        canvas = GetComponentInChildren<Canvas>();" +"    }" +"" +"    public void BringToFront()" +"    {" +"        canvas.sortingOrder = TopSortingOrder;" +"        //TODO" +"        canvas.sortingLayerName = \"AboveEverything\";" +"    }" +"" +"    // not setting sorting order inside of VisualStaes property because when the card is drawn, " +"    // we want to set an index first and set the sorting order only when the card arrives to hand. " +"    public void SetHandSortingOrder()" +"    {" +"        if (slot != -1)" +"            canvas.sortingOrder = HandSortingOrder(slot);" +"        canvas.sortingLayerName = \"Cards\";" +"    }" +"" +"    public void SetTableSortingOrder()" +"    {" +"        canvas.sortingOrder = 0;" +"        canvas.sortingLayerName = \"Creatures\";" +"    }" +"" +"    private int HandSortingOrder(int placeInHand)" +"    {" +"        return ((placeInHand + 1) * 10); " +"    }" +"" +"" +"}" 
  }
]}
