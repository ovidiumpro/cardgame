{"files":[
  {
    "fileName": "BetterCardRotation.cs",
    "relativeFilePath": "Assets/Scripts/Visual/BetterCardRotation.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"/// <summary>" +"/// This script should be attached to the card game object to display card\`s rotation correctly." +"/// </summary>" +"" +"[ExecuteInEditMode]" +"public class BetterCardRotation : MonoBehaviour {" +"" +"    // parent game object for all the card face graphics" +"    public RectTransform CardFront;" +"" +"    // parent game object for all the card back graphics" +"    public RectTransform CardBack;" +"" +"    // an empty game object that is placed a bit above the face of the card, in the center of the card" +"    public Transform targetFacePoint;" +"" +"    public LayerMask cardLayer;" +"" +"    // 3d collider attached to the card (2d colliders like BoxCollider2D won\`t work in this case)" +"    private Collider col;" +"    private Transform mainCameraTransform;" +"" +"    // if this is true, our players currently see the card Back" +"    private bool showingBack = false;" +"" +"    void Start() {" +"        col = GetComponent<BoxCollider>();" +"        mainCameraTransform = Camera.main.transform;" +"    }" +"" +"	// Update is called once per frame" +"	void Update () " +"    {" +"        // Raycast from Camera to a target point on the face of the card" +"        // If it passes through the card\`s collider, we should show the back of the card" +"        RaycastHit[] hits;" +"        hits = Physics.RaycastAll(origin: mainCameraTransform.position, " +"                                  direction: (-mainCameraTransform.position + targetFacePoint.position).normalized, " +"            maxDistance: (-mainCameraTransform.position + targetFacePoint.position).magnitude) ;" +"        bool passedThroughColliderOnCard = false;" +"        foreach (RaycastHit h in hits)" +"        {" +"            if (h.collider == col)" +"                passedThroughColliderOnCard = true;" +"        }" +"        //Debug.Log(\"TotalHits: \" + hits.Length); " +"        if (passedThroughColliderOnCard!= showingBack)" +"        {" +"            // something changed" +"            showingBack = passedThroughColliderOnCard;" +"            CardFront.gameObject.SetActive(!showingBack);" +"            CardBack.gameObject.SetActive(showingBack);" +"        }" +"" +"	}" +"}" 
  }
,
  {
    "fileName": "HoverPreview.cs",
    "relativeFilePath": "Assets/Scripts/Visual/HoverPreview.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using DG.Tweening;" +"using System.Collections.Generic;" +"" +"public class HoverPreview : MonoBehaviour" +"{" +"    // PUBLIC FIELDS" +"    public GameObject TurnThisOffWhenPreviewing;  // if this is null, will not turn off anything " +"    public Vector3 TargetPosition;" +"    public float TargetScale;" +"    public GameObject previewGameObject;" +"    public bool ActivateInAwake = false;" +"" +"    // PRIVATE FIELDS" +"    private static HoverPreview currentlyViewing = null;" +"" +"    // PROPERTIES WITH UNDERLYING PRIVATE FIELDS" +"    private static Dictionary<int, Sequence> runningSequences = new Dictionary<int, Sequence>();" +"    private static bool _PreviewsAllowed = true;" +"    public static bool PreviewsAllowed" +"    {" +"        get { return _PreviewsAllowed; }" +"" +"        set" +"        {" +"            //Debug.Log(\"Hover Previews Allowed is now: \" + value);" +"            _PreviewsAllowed = value;" +"            if (!_PreviewsAllowed)" +"                StopAllPreviews();" +"        }" +"    }" +"" +"    private bool _thisPreviewEnabled = false;" +"    public bool ThisPreviewEnabled" +"    {" +"        get { return _thisPreviewEnabled; }" +"" +"        set" +"        {" +"            _thisPreviewEnabled = value;" +"            if (!_thisPreviewEnabled)" +"                StopThisPreview();" +"        }" +"    }" +"" +"    public bool OverCollider { get; set; }" +"" +"    // MONOBEHVIOUR METHODS" +"    void Awake()" +"    {" +"        ThisPreviewEnabled = ActivateInAwake;" +"    }" +"" +"    void OnMouseEnter()" +"    {" +"        OverCollider = true;" +"        if (PreviewsAllowed && ThisPreviewEnabled)" +"            PreviewThisObject();" +"    }" +"" +"    void OnMouseExit()" +"    {" +"        OverCollider = false;" +"" +"        if (!PreviewingSomeCard())" +"            StopAllPreviews();" +"    }" +"" +"    // OTHER METHODS" +"    void PreviewThisObject()" +"    {" +"        StopAllPreviews();" +"" +"        currentlyViewing = this;" +"" +"        previewGameObject.SetActive(true);" +"" +"        if (TurnThisOffWhenPreviewing != null)" +"            TurnThisOffWhenPreviewing.SetActive(false);" +"" +"        previewGameObject.transform.localPosition = Vector3.zero;" +"        previewGameObject.transform.localScale = Vector3.one;" +"" +"        // Create or restart the sequence for this HoverPreview" +"        if (!runningSequences.ContainsKey(GetInstanceID()))" +"        {" +"            runningSequences[GetInstanceID()] = DOTween.Sequence();" +"        }" +"        else" +"        {" +"            runningSequences[GetInstanceID()].Restart();" +"        }" +"" +"        Sequence mySequence = runningSequences[GetInstanceID()];" +"        mySequence.Kill();" +"        mySequence = DOTween.Sequence();" +"        mySequence.Append(previewGameObject.transform.DOLocalMove(TargetPosition, 1f).SetEase(Ease.OutQuint));" +"        mySequence.Join(previewGameObject.transform.DOScale(TargetScale, 1f).SetEase(Ease.OutQuint));" +"    }" +"" +"    void StopThisPreview()" +"    {" +"        if (runningSequences.ContainsKey(GetInstanceID()))" +"        {" +"            Sequence mySequence = runningSequences[GetInstanceID()];" +"            mySequence.Kill();" +"            mySequence = DOTween.Sequence();" +"            mySequence.Append(previewGameObject.transform.DOLocalMove(Vector3.zero, 0.2f).SetEase(Ease.InQuint));" +"            mySequence.Join(previewGameObject.transform.DOScale(Vector3.one, 0.2f).SetEase(Ease.InQuint));" +"            mySequence.AppendCallback(() =>" +"            {" +"                previewGameObject.SetActive(false);" +"                if (TurnThisOffWhenPreviewing != null)" +"                    TurnThisOffWhenPreviewing.SetActive(true);" +"            });" +"        }" +"        else" +"        {" +"            previewGameObject.SetActive(false);" +"            previewGameObject.transform.localScale = Vector3.one;" +"            previewGameObject.transform.localPosition = Vector3.zero;" +"            if (TurnThisOffWhenPreviewing != null)" +"                TurnThisOffWhenPreviewing.SetActive(true);" +"        }" +"    }" +"" +"    // STATIC METHODS" +"    private static void StopAllPreviews()" +"    {" +"        if (currentlyViewing != null)" +"        {" +"            // Call StopThisPreview() to handle stopping and animations properly" +"            currentlyViewing.StopThisPreview();" +"            // Clear the currentlyViewing variable" +"            currentlyViewing = null;" +"        }" +"" +"    }" +"" +"    private static bool PreviewingSomeCard()" +"    {" +"        if (!PreviewsAllowed)" +"            return false;" +"" +"        HoverPreview[] allHoverBlowups = GameObject.FindObjectsOfType<HoverPreview>();" +"" +"        foreach (HoverPreview hb in allHoverBlowups)" +"        {" +"            if (hb.OverCollider && hb.ThisPreviewEnabled)" +"                return true;" +"        }" +"" +"        return false;" +"    }" +"" +"" +"}" 
  }
,
  {
    "fileName": "ManaPoolVisual.cs",
    "relativeFilePath": "Assets/Scripts/Visual/ManaPoolVisual.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using UnityEngine.UI;" +"" +"#if UNITY_EDITOR" +"using UnityEditor;" +"#endif" +"[ExecuteInEditMode]" +"public class ManaPoolVisual : MonoBehaviour" +"{" +"    public int TestFullCrystals;" +"    public int TestTotalCrystalsThisTurn;" +"" +"    private int totalCrystals;" +"    public int TotalCrystals" +"    {" +"        get { return totalCrystals; }" +"        set" +"        {" +"            int clampedValue = Mathf.Clamp(value, 0, Crystals.Length);" +"            if (clampedValue != totalCrystals)" +"            {" +"                totalCrystals = clampedValue;" +"                UpdateCrystals();" +"            }" +"        }" +"    }" +"" +"    private int availableCrystals;" +"    public int AvailableCrystals" +"    {" +"        get { return availableCrystals; }" +"        set" +"        {" +"            int clampedValue = Mathf.Clamp(value, 0, totalCrystals);" +"            if (clampedValue != availableCrystals)" +"            {" +"                availableCrystals = clampedValue;" +"                UpdateCrystals();" +"            }" +"        }" +"    }" +"" +"    public Image[] Crystals;" +"    public Text ProgressText;" +"" +"    private readonly string progressTextFormat = \"{0}/{1}\";" +"" +"    void Update()" +"    {" +"#if UNITY_EDITOR" +"        if (Application.isEditor && !Application.isPlaying)" +"        {" +"            TotalCrystals = TestTotalCrystalsThisTurn;" +"            AvailableCrystals = TestFullCrystals;" +"        }" +"#endif" +"    }" +"" +"    private void UpdateCrystals()" +"    {" +"        for (int i = 0; i < Crystals.Length; i++)" +"        {" +"            if (i < totalCrystals)" +"            {" +"                Crystals[i].color = i < availableCrystals ? Color.white : Color.gray;" +"            }" +"            else" +"            {" +"                Crystals[i].color = Color.clear;" +"            }" +"        }" +"" +"        UpdateProgressText();" +"    }" +"" +"    private void UpdateProgressText()" +"    {" +"        ProgressText.text = string.Format(progressTextFormat, availableCrystals, totalCrystals);" +"    }" +"}" 
  }
,
  {
    "fileName": "OneCardManager.cs",
    "relativeFilePath": "Assets/Scripts/Visual/OneCardManager.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using UnityEngine.UI;" +"using CG.Cards;" +"using System.Text;" +"// holds the refs to all the Text, Images on the card" +"public class OneCardManager : MonoBehaviour {" +"" +"    public CardAsset cardAsset;" +"    public OneCardManager PreviewManager;" +"    [Header(\"Text Component References\")]" +"    public Text NameText;" +"    public Text ManaCostText;" +"    public Text DescriptionText;" +"    public Text HealthText;" +"    public Text AttackText;" +"    public Text CardTypeText;" +" " +"    [Header(\"Image References\")]" +"    public Image CardTopRibbonImage;" +"    public Image CardLowRibbonImage;" +"    public Image CardGraphicImage;" +"    " +"    public Image CardBodyImage;" +"    public Image CardFaceFrameImage;" +"    public Image CardFaceGlowImage;" +"    public Image CardBackGlowImage;" +"" +"    void Awake()" +"    {" +"        if (cardAsset != null)" +"            ReadCardFromAsset();" +"    }" +"" +"    private bool canBePlayedNow = false;" +"    public bool CanBePlayedNow" +"    {" +"        get" +"        {" +"            return canBePlayedNow;" +"        }" +"" +"        set" +"        {" +"            canBePlayedNow = value;" +"" +"            CardFaceGlowImage.enabled = value;" +"        }" +"    }" +"" +"    public void ReadCardFromAsset()" +"    {" +"        // universal actions for any Card" +"        // 1) apply tint" +"        if (cardAsset.characterAsset != null)" +"        {" +"            CardBodyImage.color = cardAsset.characterAsset.ClassCardTint;" +"            CardFaceFrameImage.color = cardAsset.characterAsset.ClassCardTint;" +"            CardTopRibbonImage.color = cardAsset.characterAsset.ClassRibbonsTint;" +"            CardLowRibbonImage.color = cardAsset.characterAsset.ClassRibbonsTint;" +"        }" +"        else" +"        {" +"            CardFaceFrameImage.color = Color.white;" +"        }" +"        // 2) add card name" +"        NameText.text = cardAsset.name;" +"        // 3) add mana cost" +"        ManaCostText.text = cardAsset.ManaCost.ToString();" +"        // 4) add description" +"        DescriptionText.text = cardAsset.Description;" +"        // 5) Change the card graphic sprite" +"        CardGraphicImage.sprite = cardAsset.CardImage;" +"        CardTypeText.text = EnumToStringWithSpaces(cardAsset.CardType);" +"" +"        if (cardAsset.MaxHealth != 0)" +"        {" +"            // this is a creature" +"            AttackText.text = cardAsset.Attack.ToString();" +"            HealthText.text = cardAsset.MaxHealth.ToString();" +"        }" +"" +"        if (PreviewManager != null)" +"        {" +"            // this is a card and not a preview" +"            // Preview GameObject will have OneCardManager as well, but PreviewManager should be null there" +"            PreviewManager.cardAsset = cardAsset;" +"            PreviewManager.ReadCardFromAsset();" +"        }" +"    }" +"    public static string EnumToStringWithSpaces(ECardType value)" +"{" +"    string input = value.ToString();" +"    StringBuilder output = new StringBuilder();" +"" +"    for (int i = 0; i < input.Length; i++)" +"    {" +"        if (i > 0 && char.IsUpper(input[i]))" +"        {" +"            output.Append(' ');" +"        }" +"        output.Append(input[i]);" +"    }" +"" +"    return output.ToString();" +"}" +"}" 
  }
,
  {
    "fileName": "OneCreatureManager.cs",
    "relativeFilePath": "Assets/Scripts/Visual/OneCreatureManager.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using UnityEngine.UI;" +"using CG.Cards;" +"" +"public class OneCreatureManager : MonoBehaviour " +"{" +"    public CardAsset cardAsset;" +"    public OneCardManager PreviewManager;" +"    [Header(\"Text Component References\")]" +"    public Text HealthText;" +"    public Text AttackText;" +"    [Header(\"Image References\")]" +"    public Image CreatureGraphicImage;" +"    public Image CreatureGlowImage;" +"" +"    void Awake()" +"    {" +"        if (cardAsset != null)" +"            ReadCreatureFromAsset();" +"    }" +"" +"    private bool canAttackNow = false;" +"    public bool CanAttackNow" +"    {" +"        get" +"        {" +"            return canAttackNow;" +"        }" +"" +"        set" +"        {" +"            canAttackNow = value;" +"" +"            CreatureGlowImage.enabled = value;" +"        }" +"    }" +"" +"    public void ReadCreatureFromAsset()" +"    {" +"        // Change the card graphic sprite" +"        CreatureGraphicImage.sprite = cardAsset.CardImage;" +"" +"        AttackText.text = cardAsset.Attack.ToString();" +"        HealthText.text = cardAsset.MaxHealth.ToString();" +"" +"        if (PreviewManager != null)" +"        {" +"            PreviewManager.cardAsset = cardAsset;" +"            PreviewManager.ReadCardFromAsset();" +"        }" +"    }	" +"" +"    public void TakeDamage(int amount, int healthAfter)" +"    {" +"        if (amount > 0)" +"        {" +"            //DamageEffect.CreateDamageEffect(transform.position, amount);" +"            HealthText.text = healthAfter.ToString();" +"        }" +"    }" +"}" 
  }
,
  {
    "fileName": "PositionManager.cs",
    "relativeFilePath": "Assets/Scripts/Visual/PositionManager.cs",
    "type": "script",
    "content": "using UnityEngine;" +"public class PositionManager : MonoBehaviour" +"{" +"    public Transform FirstSlot;" +"    public Transform LastSlot;" +"    private Vector3 firstPos, lastPos;" +"    [SerializeField] private float maxRotation = 20f;  // maximum rotation for first and last cards" +"    [SerializeField] private float radiusFactor = 0.5f;  // adjust this value to control the spread of the cards" +"    [SerializeField] private int angleFactor = 12;" +"    [SerializeField] private float yCorrectionFactor = 2f;" +"" +"    private void Awake()" +"    {" +"        firstPos = FirstSlot.position;" +"        lastPos = LastSlot.position;" +"        PositionSlots();" +"        " +"    }" +"" +"    private void OnTransformChildrenChanged()" +"    {" +"        PositionSlots();" +"    }" +"    " +"    private void PositionSlots()" +"    {" +"        if (transform.childCount < 2)" +"        {" +"            return;" +"        }" +"" +"        float firstRotZ = maxRotation;" +"        float lastRotZ = -maxRotation;" +"        float radius = ((lastPos - firstPos).magnitude / 2f) * radiusFactor;  // radius of the arc" +"        Vector3 centerPos = (lastPos + firstPos) / 2f;  // center of the arc" +"" +"        for (int i = 0; i < transform.childCount; i++)" +"        {" +"            Transform child = transform.GetChild(i);" +"            float t = (float)i / (transform.childCount - 1);" +"" +"            // Calculate angle in radians" +"            float angle = Mathf.Lerp(-Mathf.PI / angleFactor, Mathf.PI / angleFactor, t);" +"" +"            // Calculate position on the arc" +"            Vector3 posOnArc = new Vector3(radius * Mathf.Sin(angle), radius * Mathf.Cos(angle) + centerPos.y * yCorrectionFactor, 0f);" +"            child.position = centerPos + posOnArc;" +"" +"            // Calculate rotation" +"            float rotZ = Mathf.Lerp(firstRotZ, lastRotZ, t);" +"            child.rotation = Quaternion.Euler(0, 0, rotZ);" +"        }" +"    }" +"}" 
  }
]}
