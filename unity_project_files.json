{"files":[
  {
    "fileName": "AllCreaturesDieCommand.cs",
    "relativeFilePath": "Assets/Scripts/Commands/AllCreaturesDieCommand.cs",
    "type": "script",
    "content": "using System.Collections;" +"using System.Collections.Generic;" +"using System.Linq;" +"using UnityEngine;" +"" +"public class AllCreaturesDieCommand : Command" +"{" +"    private List<CreatureLogic> CreaturesToDie;" +"    public AllCreaturesDieCommand(List<CreatureLogic> creatures)" +"    {" +"        this.CreaturesToDie = creatures;" +"" +"    }" +"    public override void StartCommandExecution()" +"    {" +"        if (CreaturesToDie.Count == 0) return;" +"        var creatureGroupsByOwner = CreaturesToDie.GroupBy(creature => creature.owner);" +"        foreach (var group in creatureGroupsByOwner)" +"    {" +"        group.Key.table.RemoveAllFromList(group.ToList());" +"    }" +"        //TODO access each owner's table property and call the RemoveAllFromList(List<CreatureLogic> creatures) method. " +"        Debug.Log(\"Accessing Table Visual to kill creatures\");" +"        TableVisual.MassRemoveCreatures(creatureGroupsByOwner);" +"    }" +"}" 
  }
,
  {
    "fileName": "CallbackCommand.cs",
    "relativeFilePath": "Assets/Scripts/Commands/CallbackCommand.cs",
    "type": "script",
    "content": "using System;" +"using System.Collections;" +"using System.Collections.Generic;" +"using UnityEngine;" +"" +"public class CallbackCommand : Command" +"{" +"    private Action _action;" +"" +"    public CallbackCommand(Action action)" +"    {" +"        Debug.Log(\"Creating callback command\");" +"        _action = action;" +"    }" +"" +"    public override void StartCommandExecution()" +"    {" +"        _action.Invoke();" +"        CommandExecutionComplete();" +"    }" +"}" 
  }
,
  {
    "fileName": "Command.cs",
    "relativeFilePath": "Assets/Scripts/Commands/Command.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using System.Collections.Generic;" +"using System;" +"" +"public class Command" +"{" +"    public static LinkedList<Command> CommandList = new LinkedList<Command>();" +"    public static event Action OnQueueEmpty;" +"    public static bool playingQueue = false;" +"    public static bool queuePaused = false;" +"    //public static bool commandExecuting = false;" +"" +"    public virtual void AddToQueue(bool addToFront = false)" +"    {" +"        Debug.Log(\"Adding command: \" + this.ToString());" +"        if (addToFront)" +"        {" +"            CommandList.AddFirst(this);" +"        }" +"        else" +"        {" +"            CommandList.AddLast(this);" +"        }" +"        if (!playingQueue && !queuePaused)" +"        {" +"            //Debug.Log(\"Playing command from AddToQueue\");" +"            playingQueue = true;" +"            PlayFirstCommandFromQueue();" +"        }" +"" +"    }" +"    // public static void CommandExecutionFlagUpdate() {" +"    //     commandExecuting = false;" +"    // }" +"" +"    public virtual void StartCommandExecution()" +"    {" +"        // list of everything that we have to do with this command (draw a card, play a card, play spell effect, etc...)" +"        // there are 2 options of timing : " +"        // 1) use tween sequences and call CommandExecutionComplete in OnComplete()" +"        // 2) use coroutines (IEnumerator) and WaitFor... to introduce delays, call CommandExecutionComplete() in the end of coroutine" +"    }" +"" +"    public static void CommandExecutionComplete()" +"    {" +"        if (CommandList.Count > 0)" +"        {" +"" +"            PlayFirstCommandFromQueue();" +"        }" +"" +"        else" +"            playingQueue = false;" +"        //Debug.Log(\"Invoking command empty event\");" +"        OnQueueEmpty?.Invoke();" +"        // if (TurnManager.Instance.whoseTurn != null)" +"        //     TurnManager.Instance.whoseTurn.HighlightPlayableObjects();" +"    }" +"" +"    public static void PlayFirstCommandFromQueue()" +"    {" +"        if (queuePaused)" +"        {" +"            playingQueue = false;" +"            return;" +"        }" +"        if (Command.CommandList.Count > 0)" +"        {" +"            playingQueue = true;" +"            Command c = CommandList.First.Value;" +"            CommandList.RemoveFirst();" +"            // commandExecuting = true;" +"            c.StartCommandExecution();" +"        }" +"" +"    }" +"" +"    public static void PauseQueueExecution()" +"    {" +"        queuePaused = true;" +"    }" +"" +"    public static void ResumeQueueExecution()" +"    {" +"        queuePaused = false;" +"        if (!playingQueue)" +"            PlayFirstCommandFromQueue();" +"    }" +"" +"    public static bool CardDrawPending()" +"    {" +"        foreach (Command c in CommandList)" +"        {" +"            if (c is DrawACardCommand)" +"                return true;" +"        }" +"        return false;" +"    }" +"}" 
  }
,
  {
    "fileName": "CreatureAttackCommand.cs",
    "relativeFilePath": "Assets/Scripts/Commands/CreatureAttackCommand.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class CreatureAttackCommand : Command " +"{" +"    // position of creature on enemy\`s table that will be attacked" +"    // if enemyindex == -1 , attack an enemy character " +"    private int TargetUniqueID;" +"    private int AttackerUniqueID;" +"    private int AttackerHealthAfter;" +"    private int TargetHealthAfter;" +"    private int DamageTakenByAttacker;" +"    private int DamageTakenByTarget;" +"" +"    public CreatureAttackCommand(int targetID, int attackerID, int damageTakenByAttacker, int damageTakenByTarget, int attackerHealthAfter, int targetHealthAfter)" +"    {" +"        this.TargetUniqueID = targetID;" +"        this.AttackerUniqueID = attackerID;" +"        this.AttackerHealthAfter = attackerHealthAfter;" +"        this.TargetHealthAfter = targetHealthAfter;" +"        this.DamageTakenByTarget = damageTakenByTarget;" +"        this.DamageTakenByAttacker = damageTakenByAttacker;" +"    }" +"" +"    public override void StartCommandExecution()" +"    {" +"        GameObject Attacker = IDHolder.GetGameObjectWithID(AttackerUniqueID);" +"" +"        //Debug.Log(TargetUniqueID);" +"        Attacker.GetComponent<CreatureAttackVisual>().AttackTarget(TargetUniqueID, DamageTakenByTarget, DamageTakenByAttacker, AttackerHealthAfter, TargetHealthAfter);" +"    }" +"}" 
  }
,
  {
    "fileName": "CreatureDieCommand.cs",
    "relativeFilePath": "Assets/Scripts/Commands/CreatureDieCommand.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class CreatureDieCommand : Command " +"{" +"    private Player p;" +"    private int DeadCreatureID;" +"" +"    public CreatureDieCommand(int CreatureID, Player p)" +"    {" +"        this.p = p;" +"        this.DeadCreatureID = CreatureID;" +"    }" +"" +"    public override void StartCommandExecution()" +"    {" +"        p.PArea.tableVisual.RemoveCreatureWithID(DeadCreatureID);" +"    }" +"}" 
  }
,
  {
    "fileName": "DealDamageCommand.cs",
    "relativeFilePath": "Assets/Scripts/Commands/DealDamageCommand.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class DealDamageCommand : Command {" +"" +"    private int targetID;" +"    private int amount;" +"    private int healthAfter;" +"" +"    public DealDamageCommand( int targetID, int amount, int healthAfter)" +"    {" +"        this.targetID = targetID;" +"        this.amount = amount;" +"        this.healthAfter = healthAfter;" +"    }" +"" +"    public override void StartCommandExecution()" +"    {" +"        Debug.Log(\"In deal damage command!\");" +"" +"        GameObject target = IDHolder.GetGameObjectWithID(targetID);" +"        DamageEffect.CreateDamageEffect(target, amount);" +"        if (targetID == GlobalSettings.Instance.LowPlayer.PlayerID || targetID == GlobalSettings.Instance.TopPlayer.PlayerID)" +"        {" +"            // target is a hero" +"            target.GetComponent<PlayerPortraitVisual>().TakeDamage(amount,healthAfter);" +"        }" +"        else" +"        {" +"            // target is a creature" +"            target.GetComponent<OneCreatureManager>().TakeDamage(amount, healthAfter);" +"            CreatureLogic cl = CreatureLogic.CreaturesCreatedThisGame[targetID];" +"            if (cl != null) {" +"                cl.Health = healthAfter;" +"            }" +"            " +"        }" +"        CommandExecutionComplete();" +"    }" +"}" 
  }
,
  {
    "fileName": "DelayCommand.cs",
    "relativeFilePath": "Assets/Scripts/Commands/DelayCommand.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using DG.Tweening;" +"" +"public class DelayCommand : Command " +"{" +"    float delay;" +"" +"    public DelayCommand(float timeToWait)" +"    {" +"        delay = timeToWait;    " +"    }" +"" +"    public override void StartCommandExecution()" +"    {" +"        Sequence s = DOTween.Sequence();" +"        s.PrependInterval(delay);" +"        s.OnComplete(Command.CommandExecutionComplete);" +"    }" +"}" 
  }
,
  {
    "fileName": "DrawACardCommand.cs",
    "relativeFilePath": "Assets/Scripts/Commands/DrawACardCommand.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using CG.Cards;" +"public class DrawACardCommand : Command {" +"    // first argument" +"    // \"1\" - fast" +"    // \"0\" - normal" +"" +"    private Player p;" +"    private int handPos;" +"    private CardLogic cl;" +"    private bool fast;" +"    private int ID;" +"    private bool fromDeck;" +"" +"" +"    public DrawACardCommand(CardLogic cl, Player p, int positionInHand, bool fast, bool fromDeck)" +"    {        " +"        this.cl = cl;" +"        this.p = p;" +"        handPos = positionInHand;" +"        this.fast = fast;" +"        this.fromDeck = fromDeck;" +"    }" +"" +"    public override void StartCommandExecution()" +"    {" +"        p.PArea.PDeck.CardsInDeck--;" +"        p.PArea.handVisual.GivePlayerACard(cl.ca, cl.UniqueCardID, fast, fromDeck);" +"    }" +"}" 
  }
,
  {
    "fileName": "GameOverCommand.cs",
    "relativeFilePath": "Assets/Scripts/Commands/GameOverCommand.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class GameOverCommand : Command{" +"" +"    private Player looser;" +"" +"    public GameOverCommand(Player looser)" +"    {" +"        this.looser = looser;" +"    }" +"" +"    public override void StartCommandExecution()" +"    {" +"        looser.PArea.Portrait.Explode();" +"    }" +"}" 
  }
,
  {
    "fileName": "PlayACreatureCommand.cs",
    "relativeFilePath": "Assets/Scripts/Commands/PlayACreatureCommand.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using DG.Tweening;" +"" +"public class PlayACreatureCommand : Command" +"{" +"    private CardLogic cl;" +"    private int tablePos;" +"    private Player p;" +"    private int creatureID;" +"" +"    public PlayACreatureCommand(CardLogic cl, Player p, int tablePos, int creatureID)" +"    {" +"        this.p = p;" +"        this.cl = cl;" +"        this.tablePos = tablePos;" +"        this.creatureID = creatureID;" +"    }" +"" +"    public override void StartCommandExecution()" +"    {" +"        // remove and destroy the card in hand " +"        HandVisual PlayerHand = p.PArea.handVisual;" +"        GameObject card = IDHolder.GetGameObjectWithID(cl.UniqueCardID);" +"        PlayerHand.RemoveCard(card);" +"        TableVisual tableVisual = p.PArea.tableVisual;" +"        // Get Slots gameobject" +"        Transform slotsTransform = tableVisual.transform.Find(\"Slots\");" +"" +"        // Get the desired slot position" +"        Transform targetSlot = slotsTransform.GetChild(tablePos);" +"" +"        // Create a sequence for movement and scaling" +"        Sequence seq = DOTween.Sequence();" +"        seq.Append(card.transform.DOMove(targetSlot.position, 0.5f));" +"        seq.Insert(0f,card.transform.DOScale(0.1f, 0.5f));" +"        seq.InsertCallback(0.3f, () => {" +"            HoverPreview.PreviewsAllowed = true;" +"            // move this card to the spot " +"            p.PArea.tableVisual.AddCreatureAtIndex(cl.ca, creatureID, tablePos);" +"        });" +"        // Destroy the card at the end of the sequence" +"        seq.OnComplete(() =>" +"        {" +"            GameObject.Destroy(card);" +"            tableVisual.TriggerOnCreatureEnter(creatureID);" +"            " +"        });" +"        seq.Play();" +"" +"    }" +"}" 
  }
,
  {
    "fileName": "PlayASpellCardCommand.cs",
    "relativeFilePath": "Assets/Scripts/Commands/PlayASpellCardCommand.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class PlayASpellCardCommand: Command" +"{" +"    private CardLogic card;" +"    private Player p;" +"    //private ICharacter target;" +"" +"    public PlayASpellCardCommand(Player p, CardLogic card)" +"    {" +"        this.card = card;" +"        this.p = p;" +"    }" +"" +"    public override void StartCommandExecution()" +"    {" +"        // move this card to the spot" +"        p.PArea.handVisual.PlayASpellFromHand(card.UniqueCardID);" +"        // do all the visual stuff (for each spell separately????)" +"    }" +"}" 
  }
,
  {
    "fileName": "PredictCreatureSlotCommand.cs",
    "relativeFilePath": "Assets/Scripts/Commands/PredictCreatureSlotCommand.cs",
    "type": "script",
    "content": "using System.Collections;" +"using System.Collections.Generic;" +"using UnityEngine;" +"" +"public class PredictCreatureSlotCommand : Command" +"{" +"    private int tablePos;" +"    private Player p;" +"" +"    public PredictCreatureSlotCommand(int tablePos, Player p) {" +"        this.tablePos = tablePos;" +"        this.p = p;" +"    }" +"     public override void StartCommandExecution()" +"    {" +"        // remove and destroy the card in hand " +"        // enable Hover Previews Back" +"        // move this card to the spot " +"        p.PArea.tableVisual.PredictCreatureSlot(tablePos);" +"    }" +"}" 
  }
,
  {
    "fileName": "RemovePlayedSpellCardFromTheScreenCommand.cs",
    "relativeFilePath": "Assets/Scripts/Commands/RemovePlayedSpellCardFromTheScreenCommand.cs",
    "type": "script",
    "content": "using System.Collections;" +"using System.Collections.Generic;" +"using UnityEngine;" +"" +"public class RemovePlayedSpellCardFromTheScreenCommand : Command" +"{" +"    private Player p;" +"    private CardLogic cl;" +"" +"    public RemovePlayedSpellCardFromTheScreenCommand(Player p, CardLogic cl) {" +"        this.p = p;" +"        this.cl = cl;" +"    }" +"     public override void StartCommandExecution()" +"    {" +"        // remove and destroy the card in hand " +"        // enable Hover Previews Back" +"        // move this card to the spot " +"        p.PArea.handVisual.DestroyCardVisual(cl.UniqueCardID);" +"    }" +"}" 
  }
,
  {
    "fileName": "ShowMessageCommand.cs",
    "relativeFilePath": "Assets/Scripts/Commands/ShowMessageCommand.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using System;" +"" +"public class ShowMessageCommand : Command {" +"" +"    string message;" +"    float duration;" +"" +"    public ShowMessageCommand(string message, float duration)" +"    {" +"        this.message = message;" +"        this.duration = duration;" +"    }" +"" +"    public override void StartCommandExecution()" +"    {" +"        MessageManager.Instance.ShowMessage(message, duration);" +"    }" +"}" 
  }
,
  {
    "fileName": "StartATurnCommand.cs",
    "relativeFilePath": "Assets/Scripts/Commands/StartATurnCommand.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class StartATurnCommand : Command {" +"" +"    private Player p;" +"" +"    public StartATurnCommand(Player p)" +"    {" +"        this.p = p;" +"    }" +"" +"    public override void StartCommandExecution()" +"    {" +"        TurnManager.Instance.whoseTurn = p;" +"        // this command is completed instantly" +"        CommandExecutionComplete();" +"    }" +"}" 
  }
,
  {
    "fileName": "SummonCreaturesCommand.cs",
    "relativeFilePath": "Assets/Scripts/Commands/SummonCreaturesCommand.cs",
    "type": "script",
    "content": "using System.Collections;" +"using System.Collections.Generic;" +"using UnityEngine;" +"" +"public class SummonCreaturesCommand : Command" +"{" +"    Player p;" +"    List<CreatureLogic> cl;" +"" +"    public SummonCreaturesCommand(Player p, List<CreatureLogic> cl) " +"    {" +"        this.p = p;" +"        this.cl = cl;" +"    }" +"" +"    public override void StartCommandExecution()" +"    {" +"        TableVisual tableVisual = p.PArea.tableVisual;" +"        List<int> UniqueIds = cl.ConvertAll(c => c.UniqueCreatureID);" +"        tableVisual.SummonCreaturesOnTable(cl[0].ca, UniqueIds);" +"    }" +"}" 
  }
,
  {
    "fileName": "UpdateManaCrystalsCommand.cs",
    "relativeFilePath": "Assets/Scripts/Commands/UpdateManaCrystalsCommand.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class UpdateManaCrystalsCommand : Command {" +"" +"    private Player p;" +"    private int TotalMana;" +"    private int AvailableMana;" +"" +"    public UpdateManaCrystalsCommand(Player p, int TotalMana, int AvailableMana)" +"    {" +"        this.p = p;" +"        this.TotalMana = TotalMana;" +"        this.AvailableMana = AvailableMana;" +"    }" +"" +"    public override void StartCommandExecution()" +"    {" +"        p.PArea.ManaBar.TotalCrystals = TotalMana;" +"        p.PArea.ManaBar.AvailableCrystals = AvailableMana;" +"        CommandExecutionComplete();" +"    }" +"}" 
  }
,
  {
    "fileName": "DragCreatureAttack.cs",
    "relativeFilePath": "Assets/Scripts/Dragging/DragCreatureAttack.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using System.Collections.Generic;" +"using System;" +"using CG.Cards;" +"" +"public class DragCreatureAttack : DraggingActions" +"{" +"" +"    public SpriteRenderer sr;" +"    public Transform TargetGO;" +"    public LineRenderer lr;" +"    // reference to WhereIsTheCardOrCreature to track this object\`s state in the game" +"    private WhereIsTheCardOrCreature whereIsThisCreature;" +"    // the pointy end of the arrow, should be called \"Triangle\" in the Hierarchy" +"    public Transform triangle;" +"    // SpriteRenderer of triangle. We need this to disable the pointy end if the target is too close." +"    public SpriteRenderer triangleSR;" +"    // when we stop dragging, the gameObject that we were targeting will be stored in this variable." +"    private GameObject Target;" +"    // Reference to creature manager, attached to the parent game object" +"    private OneCreatureManager manager;" +"    private Draggable draggable;" +"" +"    private int currentlySelectingTarget = 0;" +"    private EffectTargetData currentTarget;" +"" +"    private List<EffectTargetData> targetsMetadata = new List<EffectTargetData>();" +"    public bool selectingTargets = false;" +"    private List<int> selectedTargetsForEffect = new List<int>();" +"" +"    private int lowPlayerID, topPlayerID;" +"" +"    private List<GameObject> extraLRs = new List<GameObject>();" +"" +"    void Awake()" +"    {" +"" +"        lr.sortingLayerName = \"AboveEverything\";" +"        manager = GetComponentInParent<OneCreatureManager>();" +"        whereIsThisCreature = GetComponentInParent<WhereIsTheCardOrCreature>();" +"        draggable = GetComponent<Draggable>();" +"    }" +"    private void Start() {" +"         lowPlayerID = GlobalSettings.Instance.LowPlayer.ID;" +"        topPlayerID = GlobalSettings.Instance.TopPlayer.ID;" +"    }" +"    public override Transform GetTargetTransform()" +"    {" +"        return TargetGO;" +"    }" +"" +"    public override bool CanDrag" +"    {" +"        get" +"        {" +"            // we can drag this card if " +"            // a) we can control this our player (this is checked in base.canDrag)" +"            // b) creature \"CanAttackNow\" - this info comes from logic part of our code into each creature\`s manager script" +"            return base.CanDrag && manager.CanAttackNow;" +"            //return true;" +"        }" +"    }" +"    private void Update()" +"    {" +"" +"        if (currentTarget == null || !selectingTargets) return;" +"        //enable and update targeting position" +"        //input left mouse button listener to select target" +"        //input right mouse button to cancel effect" +"        draggable.SetTransformPositionToCursor(TargetGO);" +"        UpdateTargetPosition(TargetGO, lr, triangleSR);" +"        if (Input.GetMouseButtonDown(0))" +"        {" +"            OnTargetSelected();" +"        }" +"        if (Input.GetMouseButtonDown(1))" +"        {" +"            lr.positionCount = 0;" +"              // not a valid target, return" +"            DeactivateComponentsAfterAttack();" +"        }" +"    }" +"" +"    private void OnTargetSelected()" +"    {" +"        Target = null;" +"        RaycastHit[] hits = GetRaycastHits();" +"        Target = GetSelectedTargetFromHits(hits);" +"" +"        if (Target != null && isTargetValid(currentTarget))" +"        {" +"            // check of we should play this spell depending on targeting options" +"            int targetID = Target.GetComponent<IDHolder>().UniqueID;" +"            selectedTargetsForEffect.Add(targetID);" +"" +"            if (SelectedAllTargets() || NoEligibleTargetsLeftForNext())" +"            {" +"                selectingTargets = false;" +"                lr.positionCount = 0;" +"                DeactivateComponentsAfterAttack();" +"            }" +"            else" +"            {" +"                //continue with selecting targets by: drawing a line to current target, allowing target to continuously follow cursor untill all targets have been selected" +"                GameObject extraLR = CreateExtraLR(Target);" +"                extraLRs.Add(extraLR);" +"                MessageManager.Instance.RefreshMessagePanel(currentTarget.promptMessage, 0.1f);" +"            }" +"        }" +"        else if (Target == null) {" +"            Debug.Log(\"Not a valid target\");" +"        } " +"        Target = null;" +"        " +"    }" +"    private bool SelectedAllTargets()" +"    {" +"        if (selectedTargetsForEffect.Count == targetsMetadata.Count)" +"        {" +"            return true;" +"        }" +"        else" +"        {" +"            currentlySelectingTarget++;" +"            if (currentlySelectingTarget >= targetsMetadata.Count) return true;" +"            currentTarget = targetsMetadata[currentlySelectingTarget];" +"            return false;" +"        }" +"    }" +"     private bool NoEligibleTargetsLeftForNext()" +"    {" +"        Player owner = GetEffectOwner();" +"        List<int> enemyCreatures = owner.otherPlayer.table.CreaturesOnTable.ConvertAll(cl => cl.ID);" +"        List<int> friendlyCreatures =owner.table.CreaturesOnTable.ConvertAll(cl => cl.ID);" +"        // we also have lowPLayerID and topPlayerID available" +"        // selectedTargets currently holds all ids of selected targets." +"        // currentlySelectingTarget.targetType is of type TargetingOptions" +"        //TODO: based on the value of currentlySelectingTarget.targetType, decide whether there are ny unpicked IDs left to choose from" +"        // Removing already selected targets from the respective lists" +"        enemyCreatures.RemoveAll(id => selectedTargetsForEffect.Contains(id));" +"        friendlyCreatures.RemoveAll(id => selectedTargetsForEffect.Contains(id));" +"        switch (currentTarget.targetType)" +"        {" +"            case TargetingOptions.NoTarget:" +"                return true;  // If there's no target, then there's nothing left to pick" +"" +"            case TargetingOptions.AllCreatures:" +"                // If the union of friendly and enemy creatures list is empty, then there's no target left" +"                return friendlyCreatures.Count == 0 && enemyCreatures.Count == 0;" +"" +"            case TargetingOptions.EnemyCreatures:" +"                // If enemy creatures list is empty, then there's no target left" +"                return enemyCreatures.Count == 0;" +"" +"            case TargetingOptions.YourCreatures:" +"                // If friendly creatures list is empty, then there's no target left" +"                return friendlyCreatures.Count == 0;" +"            case TargetingOptions.AllCharacters:" +"                return (friendlyCreatures.Count == 0 && enemyCreatures.Count == 0) && (selectedTargetsForEffect.Contains(owner.ID) && selectedTargetsForEffect.Contains(owner.otherPlayer.ID));" +"            case TargetingOptions.EnemyCharacters:" +"                return enemyCreatures.Count == 0 && selectedTargetsForEffect.Contains(owner.otherPlayer.ID);" +"            case TargetingOptions.YourCharacters:" +"                // You'll need to include logic here for Characters if they are separate from Creatures" +"                // Assuming that \"Characters\" include both Creatures and Players," +"                // If there's no target left among creatures and the players were already targeted, then return true" +"                return friendlyCreatures.Count == 0 && selectedTargetsForEffect.Contains(owner.ID);" +"        }" +"" +"        return false; // In case none of the options above were matched, you could return either true or false depending on what makes sense for your game. In this case, I chose to return false as a default." +"    }" +"" +"    private GameObject CreateExtraLR(GameObject target)" +"    {" +"        int i = extraLRs.Count;" +"        // Create a new GameObject to hold the LineRenderer for this segment" +"        GameObject segment = new GameObject(\"Line Segment \" + i);" +"        segment.transform.SetParent(transform);" +"        // Add a new LineRenderer to the segment GameObject" +"        LineRenderer segmentLineRenderer = segment.AddComponent<LineRenderer>();" +"" +"        // Set the properties for the segment's LineRenderer" +"        segmentLineRenderer.positionCount = 2;" +"        segmentLineRenderer.SetPosition(0, transform.position);" +"        segmentLineRenderer.SetPosition(1, target.transform.position);" +"        segmentLineRenderer.startWidth = 0.5f;" +"        segmentLineRenderer.endWidth = 0.5f;" +"        segmentLineRenderer.material = lr.material;" +"        Gradient gradient = new Gradient();" +"" +"        // Set up gradient colors, blue at the start and red at the end" +"        GradientColorKey[] colorKey = new GradientColorKey[2];" +"        colorKey[0].color = Color.blue;" +"        colorKey[0].time = 0.0f;" +"        colorKey[1].color = Color.red;" +"        colorKey[1].time = 1.0f;" +"" +"        // Set up alpha, if you want the line to be fully visible you would set alpha to 1" +"        GradientAlphaKey[] alphaKey = new GradientAlphaKey[2];" +"        alphaKey[0].alpha = 1.0f;" +"        alphaKey[0].time = 0.0f;" +"        alphaKey[1].alpha = 1.0f;" +"        alphaKey[1].time = 0.15f;" +"" +"        gradient.SetKeys(colorKey, alphaKey);" +"" +"        segmentLineRenderer.colorGradient = gradient;" +"        segmentLineRenderer.sortingLayerName = \"AboveEverything\";" +"        segmentLineRenderer.sortingOrder = 1;" +"        return segment;" +"" +"    }" +"    private Player GetEffectOwner()" +"    {" +"        // determine an owner of this card" +"            Player owner = null;" +"            if (tag.Contains(\"Low\"))" +"                owner = GlobalSettings.Instance.LowPlayer;" +"            else" +"                owner = GlobalSettings.Instance.TopPlayer;" +"            return owner;" +"    }" +"" +"    public override void OnStartDrag()" +"    {" +"        whereIsThisCreature.VisualState = VisualStates.Dragging;" +"        // enable target graphic" +"        sr.enabled = true;" +"        // enable line renderer to start drawing the line." +"        lr.enabled = true;" +"    }" +"    public void UpdateTargetsMetadataFromEffect(CompositeEffect effect)" +"    {" +"        targetsMetadata = effect?.PollTargetsRequired();" +"        currentlySelectingTarget = 0;" +"        selectedTargetsForEffect.Clear();" +"        if (targetsMetadata.Count == 0) return;" +"        selectingTargets = true;" +"        currentTarget = targetsMetadata[currentlySelectingTarget];" +"        MessageManager.Instance.ShowMessageInstant(currentTarget.promptMessage);" +"        sr.enabled = true;" +"        lr.enabled = true;" +"        draggable.InitializePositions();" +"        " +"    }" +"    public List<int> GetSelectedTargets() {" +"        return selectedTargetsForEffect;" +"    }" +"    public override void OnDraggingInUpdate()" +"    {" +"        UpdateTargetPosition(TargetGO, lr, triangleSR);" +"" +"    }" +"" +"    public override void OnEndDrag()" +"    {" +"        Target = null;" +"        RaycastHit[] hits = GetRaycastHits();" +"        Target = GetTargetForAttack(hits);" +"" +"        bool targetValid = false;" +"" +"        if (Target != null)" +"        {" +"            int targetID = Target.GetComponent<IDHolder>().UniqueID;" +"            Debug.Log(\"Target ID: \" + targetID);" +"            if (targetID == GlobalSettings.Instance.LowPlayer.PlayerID || targetID == GlobalSettings.Instance.TopPlayer.PlayerID)" +"            {" +"                // attack character" +"                Debug.Log(\"Attacking \" + Target);" +"                Debug.Log(\"TargetID: \" + targetID);" +"                CreatureLogic.CreaturesCreatedThisGame[GetComponentInParent<IDHolder>().UniqueID].GoFace();" +"                targetValid = true;" +"            }" +"            else if (CreatureLogic.CreaturesCreatedThisGame[targetID] != null)" +"            {" +"                // if targeted creature is still alive, attack creature" +"                targetValid = !CreatureLogic.CreaturesCreatedThisGame[targetID].isDead;" +"                if (targetValid)" +"                {" +"                    CreatureLogic.CreaturesCreatedThisGame[GetComponentInParent<IDHolder>().UniqueID].AttackCreatureWithID(targetID);" +"                    Debug.Log(\"Attacking \" + Target);" +"                }" +"" +"            }" +"" +"        }" +"" +"        if (!targetValid)" +"        {" +"            // not a valid target, return" +"            whereIsThisCreature.VisualState = VisualStates.LowTable;" +"            whereIsThisCreature.SetTableSortingOrder();" +"        }" +"" +"        DeactivateComponentsAfterAttack();" +"" +"    }" +"" +"    private void DeactivateComponentsAfterAttack()" +"    {" +"        // return target and arrow to original position" +"        TargetGO.localPosition = new Vector3(0f, 0f, -0.1f);" +"        sr.enabled = false;" +"        lr.enabled = false;" +"        triangleSR.enabled = false;" +"        currentTarget = null;" +"         extraLRs.ForEach(g =>" +"        {" +"            Destroy(g);" +"        });" +"        extraLRs.Clear();" +"        targetsMetadata.Clear();" +"        MessageManager.Instance.HideMessageInstant();" +"    }" +"" +"    private GameObject GetTargetForAttack(RaycastHit[] hits)" +"    {" +"        foreach (RaycastHit h in hits)" +"        {" +"            if ((h.transform.tag == \"TopPlayer\" && this.tag == \"LowCreature\") ||" +"                (h.transform.tag == \"LowPlayer\" && this.tag == \"TopCreature\"))" +"            {" +"                // go face" +"                return h.transform.gameObject;" +"            }" +"            else if ((h.transform.tag == \"TopCreature\" && this.tag == \"LowCreature\") ||" +"                    (h.transform.tag == \"LowCreature\" && this.tag == \"TopCreature\"))" +"            {" +"                // hit a creature, save parent transform" +"                return h.transform.gameObject;" +"            }" +"" +"        }" +"        return null;" +"    }" +"    private GameObject GetSelectedTargetFromHits(RaycastHit[] hits)" +"    {" +"        foreach (RaycastHit h in hits)" +"        {" +"            if (h.transform.tag.Contains(\"Player\") || h.transform.tag.Contains(\"Creature\"))" +"            {" +"                return h.transform.gameObject;" +"            }" +"        }" +"        return null;" +"    }" +"" +"    private RaycastHit[] GetRaycastHits()" +"    {" +"        RaycastHit[] hits;" +"        Vector3 origin = Camera.main.transform.position;" +"        Vector3 direction = (-Camera.main.transform.position + TargetGO.position).normalized;" +"        float maxDistance = 30f;" +"        // TODO: raycast here anyway, store the results in " +"        hits = Physics.RaycastAll(origin, direction, maxDistance);" +"        return hits;" +"    }" +"" +"    private bool isTargetValid(EffectTargetData currentTarget)" +"    {" +"        switch (currentTarget.targetType)" +"        {" +"            case TargetingOptions.AllCharacters:" +"                return true;" +"" +"            case TargetingOptions.AllCreatures:" +"                if (Target.tag.Contains(\"Creature\"))" +"                {" +"                    return true;" +"                }" +"                return false;" +"            case TargetingOptions.EnemyCharacters:" +"                if (Target.tag.Contains(\"Creature\") || Target.tag.Contains(\"Player\"))" +"                {" +"                    // had to check that target is not a card" +"                    if ((tag.Contains(\"Low\") && Target.tag.Contains(\"Top\"))" +"                       || (tag.Contains(\"Top\") && Target.tag.Contains(\"Low\")))" +"                    {" +"                        return true;" +"                    }" +"                }" +"                return false;" +"            case TargetingOptions.EnemyCreatures:" +"                if (Target.tag.Contains(\"Creature\"))" +"                {" +"                    // had to check that target is not a card or a player" +"                    if ((tag.Contains(\"Low\") && Target.tag.Contains(\"Top\"))" +"                        || (tag.Contains(\"Top\") && Target.tag.Contains(\"Low\")))" +"                    {" +"                        return true;" +"                    }" +"                }" +"                return false;" +"            case TargetingOptions.YourCharacters:" +"                if (Target.tag.Contains(\"Creature\") || Target.tag.Contains(\"Player\"))" +"                {" +"                    // had to check that target is not a card" +"                    if ((tag.Contains(\"Low\") && Target.tag.Contains(\"Low\"))" +"                        || (tag.Contains(\"Top\") && Target.tag.Contains(\"Top\")))" +"                    {" +"                        return true;" +"                    }" +"                }" +"                return false;" +"            case TargetingOptions.YourCreatures:" +"                if (Target.tag.Contains(\"Creature\"))" +"                {" +"                    // had to check that target is not a card or a player" +"                    if ((tag.Contains(\"Low\") && Target.tag.Contains(\"Low\"))" +"                        || (tag.Contains(\"Top\") && Target.tag.Contains(\"Top\")))" +"                    {" +"                        return true;" +"                    }" +"                }" +"                return false;" +"            default:" +"                Debug.LogWarning(\"Reached default case in DragSpellOnTarget! Suspicious behaviour!!\");" +"                return false;" +"        }" +"    }" +"" +"    // NOT USED IN THIS SCRIPT" +"    protected override bool DragSuccessful()" +"    {" +"        return true;" +"    }" +"}" 
  }
,
  {
    "fileName": "DragCreatureOnTable.cs",
    "relativeFilePath": "Assets/Scripts/Dragging/DragCreatureOnTable.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using DG.Tweening;" +"using System;" +"" +"public class DragCreatureOnTable : DraggingActions {" +"" +"    private int savedHandSlot;" +"    private int currentPredictedSlot = -1;" +"    private WhereIsTheCardOrCreature whereIsCard;" +"    private IDHolder idScript;" +"    private VisualStates tempState;" +"    private OneCardManager manager;" +"    " +"" +"    public override bool CanDrag" +"    {" +"        get" +"        { " +"            // TODO : include full field check" +"            return base.CanDrag && manager.CanBePlayedNow;" +"            // return true;" +"        }" +"    }" +"" +"    void Awake()" +"    {" +"        whereIsCard = GetComponent<WhereIsTheCardOrCreature>();" +"        manager = GetComponent<OneCardManager>();" +"    }" +"" +"     public override Transform GetTargetTransform()" +"    {" +"        return transform;" +"    }" +"    public override void OnStartDrag()" +"    {" +"        savedHandSlot = whereIsCard.Slot;" +"        tempState = whereIsCard.VisualState;" +"        whereIsCard.VisualState = VisualStates.Dragging;" +"        whereIsCard.BringToFront();" +"        Debug.Log(\"Starting drag: \" + this.gameObject.name);" +"" +"    }" +"" +"    public override void OnDraggingInUpdate()" +"    {" +"         //Debug.DrawRay(Camera.main.transform.position, Input.mousePosition, Color.yellow, 15f);" +"         //TODO: Debug the vector3 here by drawing line maybe to see hw this is interpreted, as it's not very accurate" +"        if (DragSuccessful()) {" +"            int tablePos = playerOwner.PArea.tableVisual.TablePosForNewCreature(Camera.main.ScreenToWorldPoint(" +"                new Vector3(Input.mousePosition.x, Input.mousePosition.y, transform.position.z - Camera.main.transform.position.z)).x);" +"            if (tablePos != currentPredictedSlot) {" +"                currentPredictedSlot = tablePos;" +"                new PredictCreatureSlotCommand(tablePos, playerOwner).AddToQueue();" +"                Debug.Log(\"Predicted slot: \"+ currentPredictedSlot);" +"            }" +"            " +"        }" +"    }" +"" +"    public override void OnEndDrag()" +"    {" +"        currentPredictedSlot = -1;" +"        " +"        // 1) Check if we are holding a card over the table" +"        if (DragSuccessful())" +"        {" +"            // determine table position" +"            int tablePos = playerOwner.PArea.tableVisual.TablePosForNewCreature(Camera.main.ScreenToWorldPoint(" +"                new Vector3(Input.mousePosition.x, Input.mousePosition.y, transform.position.z - Camera.main.transform.position.z)).x);" +"            // Debug.Log(\"Table Pos for new Creature: \" + tablePos.ToString());" +"            // play this card" +"            playerOwner.PlayACreatureFromHand(GetComponent<IDHolder>().UniqueID, tablePos);" +"        }" +"        else" +"        {" +"            // Set old sorting order " +"            whereIsCard.SetHandSortingOrder();" +"            whereIsCard.VisualState = tempState;" +"            // Move this card back to its slot position" +"            HandVisual PlayerHand = playerOwner.PArea.handVisual;" +"            Vector3 oldCardPos = PlayerHand.slots.Children[savedHandSlot].transform.localPosition;" +"            transform.DOLocalMove(oldCardPos, 1f);" +"            DragFailed.Invoke();" +"        } " +"    }" +"" +"    protected override bool DragSuccessful()" +"    {" +"        bool TableNotFull = (playerOwner.table.CreaturesOnTable.Count < 8);" +"" +"        return TableVisual.CursorOverSomeTable && TableNotFull;" +"    }" +"}" 
  }
,
  {
    "fileName": "Draggable.cs",
    "relativeFilePath": "Assets/Scripts/Dragging/Draggable.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using DG.Tweening;" +"" +"/// <summary>" +"/// This class enables Drag and Drop Behaviour for the game object it is attached to. " +"/// It uses other script - DraggingActions to determine whether we can drag this game object now or not and " +"/// whether the drop was successful or not." +"/// </summary>" +"" +"public class Draggable : MonoBehaviour" +"{" +"" +"    // PRIVATE FIELDS" +"" +"    // a flag to know if we are currently dragging this GameObject" +"    private Transform targetTransform;" +"    private bool dragging = false;" +"" +"    // distance from the center of this Game Object to the point where we clicked to start dragging " +"    private Vector3 pointerDisplacement;" +"" +"    // distance from camera to mouse on Z axis " +"    private float zDisplacement;" +"" +"    // reference to DraggingActions script. Dragging Actions should be attached to the same GameObject." +"    private DraggingActions da;" +"" +"    // STATIC property that returns the instance of Draggable that is currently being dragged" +"    private static Draggable _draggingThis;" +"    public static Draggable DraggingThis" +"    {" +"        get { return _draggingThis; }" +"    }" +"" +"    // MONOBEHAVIOUR METHODS" +"    void Awake()" +"    {" +"        da = GetComponent<DraggingActions>();" +"        targetTransform = da.GetTargetTransform();" +"    }" +"" +"    void OnMouseDown()" +"    {" +"        Debug.Log(\"On mouse down\");" +"        if (da != null && da.CanDrag)" +"        {" +"            dragging = true;" +"            // when we are dragging something, all previews should be off" +"            HoverPreview.PreviewsAllowed = false;" +"            _draggingThis = this;" +"            da.OnStartDrag();" +"            zDisplacement = -Camera.main.transform.position.z + targetTransform.position.z;" +"            pointerDisplacement = -targetTransform.position + MouseInWorldCoords();" +"        }" +"    }" +"" +"    // Update is called once per frame" +"    void Update()" +"    {" +"        if (dragging)" +"        {" +"            UpdateTargetTransformPosition();" +"" +"            da.OnDraggingInUpdate();" +"        }" +"    }" +"" +"    void OnMouseUp()" +"    {" +"        if (dragging)" +"        {" +"            dragging = false;" +"            // turn all previews back on" +"            HoverPreview.PreviewsAllowed = true;" +"            _draggingThis = null;" +"            da.OnEndDrag();" +"        }" +"    }" +"" +"    // returns mouse position in World coordinates for our GameObject to follow. " +"    private Vector3 MouseInWorldCoords()" +"    {" +"        var screenMousePos = Input.mousePosition;" +"        //Debug.Log(screenMousePos);" +"        screenMousePos.z = zDisplacement;" +"        return Camera.main.ScreenToWorldPoint(screenMousePos);" +"    }" +"    public void SetTransformPositionToCursor(Transform targetTransform)" +"    {" +"        Vector3 mousePos = MouseInWorldCoords();" +"        Debug.Log(mousePos);" +"        targetTransform.position = new Vector3(mousePos.x - pointerDisplacement.x, mousePos.y - pointerDisplacement.y, targetTransform.position.z);" +"    }" +"    public void UpdateTargetTransformPosition()" +"    {" +"        Vector3 mousePos = MouseInWorldCoords();" +"        //Debug.Log(mousePos);" +"        targetTransform.position = new Vector3(mousePos.x - pointerDisplacement.x, mousePos.y - pointerDisplacement.y, targetTransform.position.z);" +"    }" +"    public void InitializePositions() {" +"        zDisplacement = -Camera.main.transform.position.z + targetTransform.position.z;" +"            pointerDisplacement = Vector3.zero;" +"    }" +"" +"}" 
  }
,
  {
    "fileName": "DraggingActions.cs",
    "relativeFilePath": "Assets/Scripts/Dragging/DraggingActions.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using System;" +"" +"public abstract class DraggingActions : MonoBehaviour {" +"" +"    private Transform TargetTransform;" +"" +"    public abstract Transform GetTargetTransform();" +"    public abstract void OnStartDrag();" +"" +"    public abstract void OnEndDrag();" +"" +"    public abstract void OnDraggingInUpdate();" +"" +"    public static Action DragFailed =delegate {};" +"" +"    public virtual bool CanDrag" +"    {" +"        get" +"        {            " +"            return GlobalSettings.Instance.CanControlThisPlayer(playerOwner);" +"        }" +"    }" +"" +"    protected virtual Player playerOwner" +"    {" +"        get{" +"            " +"            if (tag.Contains(\"Low\"))" +"                return GlobalSettings.Instance.LowPlayer;" +"            else if (tag.Contains(\"Top\"))" +"                return GlobalSettings.Instance.TopPlayer;" +"            else" +"            {" +"                Debug.LogError(\"Untagged Card or creature \" + transform.parent.name);" +"                return null;" +"            }" +"        }" +"    }" +"" +"    protected abstract bool DragSuccessful();" +"" +"    public void UpdateTargetPosition(Transform TargetGO, LineRenderer lr, SpriteRenderer triangleSR) {" +"        // This code only draws the arrow" +"        Vector3 notNormalized = TargetGO.position - transform.position;" +"        Vector3 direction = notNormalized.normalized;" +"        float distanceToTarget = (direction * 2.3f).magnitude;" +"        if (notNormalized.magnitude > distanceToTarget)" +"        {" +"            // draw a line between the creature and the target" +"            lr.SetPositions(new Vector3[] { transform.position, TargetGO.position - direction * 2.3f });" +"            lr.enabled = true;" +"" +"            // position the end of the arrow between near the target." +"            triangleSR.enabled = true;" +"            triangleSR.transform.position = TargetGO.position - 1.5f * direction;" +"" +"            // proper rotarion of arrow end" +"            float rot_z = Mathf.Atan2(notNormalized.y, notNormalized.x) * Mathf.Rad2Deg;" +"            triangleSR.transform.rotation = Quaternion.Euler(0f, 0f, rot_z - 90);" +"        }" +"        else" +"        {" +"            // if the target is not far enough from creature, do not show the arrow" +"            lr.enabled = false;" +"            triangleSR.enabled = false;" +"        }" +"    }" +"    " +"}" 
  }
,
  {
    "fileName": "DraggableTest.cs",
    "relativeFilePath": "Assets/Scripts/Dragging/DraggingTest/DraggableTest.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class DraggableTest : MonoBehaviour " +"{" +"    public bool UsePointerDisplacement = true;" +"    // PRIVATE FIELDS" +"    // a flag to know if we are currently dragging this GameObject" +"    private bool dragging = false;" +"" +"    // distance from the center of this Game Object to the point where we clicked to start dragging " +"    private Vector3 pointerDisplacement = Vector3.zero;" +"" +"    // distance from camera to mouse on Z axis " +"    private float zDisplacement;" +"" +"    // MONOBEHAVIOUR METHODS" +"    void OnMouseDown()" +"    {" +"        dragging = true;" +"        zDisplacement = -Camera.main.transform.position.z + transform.position.z;" +"        if (UsePointerDisplacement)" +"            pointerDisplacement = -transform.position + MouseInWorldCoords();" +"        else" +"            pointerDisplacement = Vector3.zero;" +"    }" +"" +"    // Update is called once per frame" +"    void Update ()" +"    {" +"        if (dragging)" +"        { " +"            Vector3 mousePos = MouseInWorldCoords();" +"            //Debug.Log(mousePos);" +"            transform.position = new Vector3(mousePos.x - pointerDisplacement.x, mousePos.y - pointerDisplacement.y, transform.position.z);   " +"        }" +"    }" +"" +"    void OnMouseUp()" +"    {" +"        if (dragging)" +"        {" +"            dragging = false;" +"        }" +"    }   " +"" +"    // returns mouse position in World coordinates for our GameObject to follow. " +"    private Vector3 MouseInWorldCoords()" +"    {" +"        var screenMousePos = Input.mousePosition;" +"        //Debug.Log(screenMousePos);" +"        screenMousePos.z = zDisplacement;" +"        return Camera.main.ScreenToWorldPoint(screenMousePos);" +"    }" +"" +"}" 
  }
,
  {
    "fileName": "DraggableTestWithActions.cs",
    "relativeFilePath": "Assets/Scripts/Dragging/DraggingTest/DraggableTestWithActions.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class DraggableTestWithActions : MonoBehaviour {" +"" +"    public bool UsePointerDisplacement = true;" +"    // PRIVATE FIELDS" +"    // a reference to a DraggingActionsTest script" +"    private DraggingActionsTest da;" +"" +"    // a flag to know if we are currently dragging this GameObject" +"    private bool dragging = false;" +"" +"    // distance from the center of this Game Object to the point where we clicked to start dragging " +"    private Vector3 pointerDisplacement = Vector3.zero;" +"" +"    // distance from camera to mouse on Z axis " +"    private float zDisplacement;" +"" +"    // MONOBEHAVIOUR METHODS" +"    void Awake()" +"    {" +"        da = GetComponent<DraggingActionsTest>();" +"    }" +"" +"    void OnMouseDown()" +"    {" +"        if (da.CanDrag)" +"        {" +"            dragging = true;" +"            HoverPreview.PreviewsAllowed = false;" +"            da.OnStartDrag();" +"            zDisplacement = -Camera.main.transform.position.z + transform.position.z;" +"            if (UsePointerDisplacement)" +"                pointerDisplacement = -transform.position + MouseInWorldCoords();" +"            else" +"                pointerDisplacement = Vector3.zero;" +"        }" +"    }" +"" +"    // Update is called once per frame" +"    void Update ()" +"    {" +"        if (dragging)" +"        { " +"            Vector3 mousePos = MouseInWorldCoords();" +"            da.OnDraggingInUpdate();" +"            //Debug.Log(mousePos);" +"            transform.position = new Vector3(mousePos.x - pointerDisplacement.x, mousePos.y - pointerDisplacement.y, transform.position.z);   " +"        }" +"    }" +"" +"    void OnMouseUp()" +"    {" +"        if (dragging)" +"        {" +"            dragging = false;" +"            HoverPreview.PreviewsAllowed = true;" +"            da.OnEndDrag();" +"        }" +"    }   " +"" +"    // returns mouse position in World coordinates for our GameObject to follow. " +"    private Vector3 MouseInWorldCoords()" +"    {" +"        var screenMousePos = Input.mousePosition;" +"        //Debug.Log(screenMousePos);" +"        screenMousePos.z = zDisplacement;" +"        return Camera.main.ScreenToWorldPoint(screenMousePos);" +"    }" +"}" 
  }
,
  {
    "fileName": "DraggingActionsTest.cs",
    "relativeFilePath": "Assets/Scripts/Dragging/DraggingTest/DraggingActionsTest.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public abstract class DraggingActionsTest : MonoBehaviour {" +"" +"    public abstract void OnStartDrag();" +"" +"    public abstract void OnEndDrag();" +"" +"    public abstract void OnDraggingInUpdate();" +"" +"    public virtual bool CanDrag" +"    {" +"        get" +"        {            " +"            return true;" +"        }" +"    }" +"" +"    protected abstract bool DragSuccessful();" +"}" 
  }
,
  {
    "fileName": "DraggingActionsTestReturn.cs",
    "relativeFilePath": "Assets/Scripts/Dragging/DraggingTest/DraggingActionsTestReturn.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using DG.Tweening;" +"" +"public class DraggingActionsTestReturn : DraggingActionsTest " +"{" +"    private Vector3 savedPos;" +"" +"    public override void OnStartDrag()" +"    {" +"        savedPos = transform.position;" +"    }" +"" +"    public override void OnEndDrag()" +"    {" +"        // transform.DOMove(savedPos, 1f);" +"        // transform.DOMove(savedPos, 1f).SetEase(Ease.OutBounce, 0.5f, 0.1f);" +"        transform.DOMove(savedPos, 1f).SetEase(Ease.OutQuint);//, 0.5f, 0.1f);" +"    }" +"" +"    public override void OnDraggingInUpdate(){}" +"" +"    protected override bool DragSuccessful()" +"    {" +"        return true;" +"    }" +"}" 
  }
,
  {
    "fileName": "DragOnTargetTest.cs",
    "relativeFilePath": "Assets/Scripts/Dragging/DraggingTest/DragOnTargetTest.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using DG.Tweening;" +"using CG.Cards;" +"public class DragOnTargetTest : DraggingActionsTest" +"{" +"    public TargetingOptions Targets = TargetingOptions.AllCharacters;" +"    private SpriteRenderer sr;" +"    private LineRenderer lr;" +"    private Transform triangle;" +"    private SpriteRenderer triangleSR;" +"    private GameObject Target;" +"" +"    void Awake()" +"    {" +"        sr = GetComponent<SpriteRenderer>();" +"        lr = GetComponentInChildren<LineRenderer>();" +"        //lr.sortingLayerName = \"EverythingElse\";" +"        triangle = transform.Find(\"Triangle\");" +"        triangleSR = triangle.GetComponent<SpriteRenderer>();" +"    }" +"" +"    public override void OnStartDrag()" +"    {" +"        sr.enabled = true;" +"        lr.enabled = true;" +"    }" +"" +"    public override void OnDraggingInUpdate()" +"    {" +"        // This code only draws the arrow" +"        Vector3 notNormalized = transform.position - transform.parent.position;" +"        Vector3 direction = notNormalized.normalized;" +"        float distanceToTarget = (direction*2.3f).magnitude;" +"        if (notNormalized.magnitude > distanceToTarget)" +"        {" +"            // draw a line between the creature and the target" +"            lr.SetPositions(new Vector3[]{ transform.parent.position, transform.position - direction*2.3f });" +"            lr.enabled = true;" +"" +"            // position the end of the arrow between near the target." +"            triangleSR.enabled = true;" +"            triangleSR.transform.position = transform.position - 1.5f*direction;" +"" +"            // proper rotarion of arrow end" +"            float rot_z = Mathf.Atan2(notNormalized.y, notNormalized.x) * Mathf.Rad2Deg;" +"            triangleSR.transform.rotation = Quaternion.Euler(0f, 0f, rot_z - 90);" +"        }" +"        else" +"        {" +"            // if the target is not far enough from creature, do not show the arrow" +"            lr.enabled = false;" +"            triangleSR.enabled = false;" +"        }" +"" +"    }" +"" +"    public override void OnEndDrag()" +"    {" +"" +"        // return target and arrow to original position" +"        // this position is special for spell cards to show the arrow on top" +"        transform.localPosition = new Vector3(0f, 0f, -0.1f);" +"        sr.enabled = false;" +"        lr.enabled = false;" +"        triangleSR.enabled = false;" +"" +"    }" +"" +"    // NOT USED IN THIS SCRIPT" +"    protected override bool DragSuccessful()" +"    {" +"        return true;" +"    }" +"}" 
  }
,
  {
    "fileName": "DragHeroPowerActions.cs",
    "relativeFilePath": "Assets/Scripts/Dragging/DragHeroPowerActions.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using DG.Tweening;" +"using CG.Cards;" +"" +"public class DragHeroPowerActions : DraggingActions {" +"" +"    public TargetingOptions Options;" +"" +"    public override void OnStartDrag()" +"    {" +"       " +"    }" +"" +"    public override void OnDraggingInUpdate()" +"    {" +"" +"    }" +"     public override Transform GetTargetTransform()" +"    {" +"        return transform;" +"    }" +"" +"    public override void OnEndDrag()" +"    {" +"" +"        // 1) Check if we are holding a card over the table" +"        if (DragSuccessful())" +"        {" +"            " +"        }" +"        else" +"        {" +"            " +"        } " +"    }" +"" +"    protected override bool DragSuccessful()" +"    {" +"        bool TableNotFull = (TurnManager.Instance.whoseTurn.table.CreaturesOnTable.Count < 8);" +"" +"        return TableVisual.CursorOverSomeTable&& TableNotFull;" +"    }" +"}" 
  }
,
  {
    "fileName": "DragSpellNoTarget.cs",
    "relativeFilePath": "Assets/Scripts/Dragging/DragSpellNoTarget.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using DG.Tweening;" +"" +"public class DragSpellNoTarget: DraggingActions{" +"" +"    private int savedHandSlot;" +"    private WhereIsTheCardOrCreature whereIsCard;" +"" +"    void Awake()" +"    {" +"        whereIsCard = GetComponent<WhereIsTheCardOrCreature>();" +"    }" +"" +"    public override void OnStartDrag()" +"    {" +"        savedHandSlot = whereIsCard.Slot;" +"" +"        whereIsCard.VisualState = VisualStates.Dragging;" +"        whereIsCard.BringToFront();" +"" +"    }" +"" +"    public override void OnDraggingInUpdate()" +"    {" +"        " +"    }" +"" +"    public override void OnEndDrag()" +"    {" +"        // 1) Check if we are holding a card over the table" +"        if (DragSuccessful())" +"        {" +"            // play this card" +"            playerOwner.PlayASpellFromHand(GetComponent<IDHolder>().UniqueID, null);" +"        }" +"        else" +"        {" +"            // Set old sorting order " +"            whereIsCard.Slot = savedHandSlot;" +"            whereIsCard.VisualState = VisualStates.LowHand;" +"            // Move this card back to its slot position" +"            HandVisual PlayerHand = TurnManager.Instance.whoseTurn.PArea.handVisual;" +"            Vector3 oldCardPos = PlayerHand.slots.Children[savedHandSlot].transform.localPosition;" +"            transform.DOLocalMove(oldCardPos, 1f);" +"        } " +"    }" +"" +"    protected override bool DragSuccessful()" +"    {" +"        //bool TableNotFull = (TurnManager.Instance.whoseTurn.table.CreaturesOnTable.Count < 8);" +"" +"        return TableVisual.CursorOverSomeTable; //&& TableNotFull;" +"    }" +"" +"     public override Transform GetTargetTransform()" +"    {" +"        return transform;" +"    }" +"" +"" +"}" 
  }
,
  {
    "fileName": "DragSpellOnTarget.cs",
    "relativeFilePath": "Assets/Scripts/Dragging/DragSpellOnTarget.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using DG.Tweening;" +"using CG.Cards;" +"using System.Collections.Generic;" +"using System;" +"" +"public class DragSpellOnTarget : DraggingActions" +"{" +"" +"    public TargetingOptions Targets = TargetingOptions.AllCharacters;" +"    public SpriteRenderer sr;" +"    public Transform TargetGO;" +"    public LineRenderer lr;" +"    private WhereIsTheCardOrCreature whereIsThisCard;" +"    private VisualStates tempVisualState;" +"    public Transform triangle;" +"    public SpriteRenderer triangleSR;" +"    private GameObject Target;" +"    private CardAsset ca;" +"    private int currentlySelectingTarget = 0;" +"    private EffectTargetData currentTarget;" +"    private OneCardManager cm;" +"    private Draggable draggable;" +"" +"    private List<GameObject> extraLRs = new List<GameObject>();" +"" +"    // List of targets selected" +"    private List<int> selectedTargets = new List<int>();" +"    private List<EffectTargetData> targetsMetadata = new List<EffectTargetData>();" +"    private int lowPlayerID, topPlayerID;" +"" +"    void Awake()" +"    {" +"        // sr = GetComponent<SpriteRenderer>();" +"        // lr = GetComponentInChildren<LineRenderer>();" +"" +"        // triangle = transform.Find(\"Triangle\");" +"        // triangleSR = triangle.GetComponent<SpriteRenderer>();" +"        lr.sortingLayerName = \"AboveEverything\";" +"        cm = GetComponent<OneCardManager>();" +"        draggable = GetComponent<Draggable>();" +"        whereIsThisCard = GetComponent<WhereIsTheCardOrCreature>();" +"        cm.OnCardLoaded += ReadCardAsset;" +"    }" +"    void Start()" +"    {" +"        " +"        lowPlayerID = GlobalSettings.Instance.LowPlayer.ID;" +"        topPlayerID = GlobalSettings.Instance.TopPlayer.ID;" +"    }" +"    private void Update() {" +"        if (selectedTargets.Count > 0) {" +"            draggable.SetTransformPositionToCursor(TargetGO);" +"            OnDraggingInUpdate();" +"        }" +"    }" +"    private void OnDestroy() {" +"        cm.OnCardLoaded -= ReadCardAsset;    " +"    }" +"    private void ReadCardAsset() {" +"        ca = cm.cardAsset;" +"        targetsMetadata = ca.SpellEffect?.PollTargetsRequired();" +"    }" +"" +"    public override void OnStartDrag()" +"    {" +"        tempVisualState = whereIsThisCard.VisualState;" +"        whereIsThisCard.VisualState = VisualStates.Dragging;" +"        sr.enabled = true;" +"        lr.enabled = true;" +"        currentlySelectingTarget = 0;" +"        if (targetsMetadata.Count == 0) return;" +"        currentTarget = targetsMetadata[currentlySelectingTarget];" +"        MessageManager.Instance.ShowMessageInstant(currentTarget.promptMessage);" +"" +"    }" +"" +"    public override void OnDraggingInUpdate()" +"    {" +"        UpdateTargetPosition(TargetGO, lr, triangleSR);" +"        // Right click cancels the operation" +"        if (Input.GetMouseButtonDown(1))" +"        {" +"            lr.positionCount = 0;" +"            DeactivateComponents();" +"        }" +"        if (selectedTargets.Count > 0 && Input.GetMouseButtonDown(0)) {" +"            OnEndDrag();" +"        }" +"    }" +"" +"    public override void OnEndDrag()" +"    {" +"        Target = null;" +"        RaycastHit[] hits;" +"        // TODO: raycast here anyway, store the results in " +"        hits = Physics.RaycastAll(origin: Camera.main.transform.position," +"            direction: (-Camera.main.transform.position + this.TargetGO.position).normalized," +"            maxDistance: 30f);" +"" +"        foreach (RaycastHit h in hits)" +"        {" +"            if (h.transform.tag.Contains(\"Player\"))" +"            {" +"                // selected a Player" +"                Target = h.transform.gameObject;" +"            }" +"            else if (h.transform.tag.Contains(\"Creature\"))" +"            {" +"                // hit a creature, save parent transform" +"                Target = h.transform.gameObject;" +"            }" +"        }" +"" +"" +"        if (Target != null && isTargetValid(currentTarget))" +"        {" +"            // determine an owner of this card" +"            Player owner = null;" +"            if (tag.Contains(\"Low\"))" +"                owner = GlobalSettings.Instance.LowPlayer;" +"            else" +"                owner = GlobalSettings.Instance.TopPlayer;" +"" +"            // check of we should play this spell depending on targeting options" +"            int targetID = Target.GetComponent<IDHolder>().UniqueID;" +"            selectedTargets.Add(targetID);" +"" +"            if (SelectedAllTargets() || NoEligibleTargetsLeftForNext())" +"            {" +"                //End effect here" +"                owner.PlayASpellFromHand(GetComponent<IDHolder>().UniqueID, selectedTargets);" +"                DeactivateComponents();" +"            }" +"            else" +"            {" +"                //continue with selecting targets by: drawing a line to current target, allowing target to continuously follow cursor untill all targets have been selected" +"                GameObject extraLR = CreateExtraLR(Target);" +"                extraLRs.Add(extraLR);" +"                MessageManager.Instance.RefreshMessagePanel(currentTarget.promptMessage, 0.1f);" +"            }" +"        }" +"        else" +"        {" +"            // not a valid target, return" +"            whereIsThisCard.VisualState = tempVisualState;" +"            whereIsThisCard.SetHandSortingOrder();" +"            DeactivateComponents();" +"        }" +"    }" +"" +"    private GameObject CreateExtraLR(GameObject target)" +"    {" +"        int i = extraLRs.Count;" +"        // Create a new GameObject to hold the LineRenderer for this segment" +"        GameObject segment = new GameObject(\"Line Segment \" + i);" +"        segment.transform.SetParent(transform);" +"        // Add a new LineRenderer to the segment GameObject" +"        LineRenderer segmentLineRenderer = segment.AddComponent<LineRenderer>();" +"" +"        // Set the properties for the segment's LineRenderer" +"        segmentLineRenderer.positionCount = 2;" +"        segmentLineRenderer.SetPosition(0, transform.position);" +"        segmentLineRenderer.SetPosition(1, target.transform.position);" +"        segmentLineRenderer.startWidth = 0.5f;" +"        segmentLineRenderer.endWidth = 0.5f;" +"        segmentLineRenderer.material = lr.material;" +"        Gradient gradient = new Gradient();" +"" +"        // Set up gradient colors, blue at the start and red at the end" +"        GradientColorKey[] colorKey = new GradientColorKey[2];" +"        colorKey[0].color = Color.blue;" +"        colorKey[0].time = 0.0f;" +"        colorKey[1].color = Color.red;" +"        colorKey[1].time = 1.0f;" +"" +"        // Set up alpha, if you want the line to be fully visible you would set alpha to 1" +"        GradientAlphaKey[] alphaKey = new GradientAlphaKey[2];" +"        alphaKey[0].alpha = 1.0f;" +"        alphaKey[0].time = 0.0f;" +"        alphaKey[1].alpha = 1.0f;" +"        alphaKey[1].time = 0.15f;" +"" +"        gradient.SetKeys(colorKey, alphaKey);" +"" +"        segmentLineRenderer.colorGradient = gradient;" +"        segmentLineRenderer.sortingLayerName = \"AboveEverything\";" +"        segmentLineRenderer.sortingOrder = 1;" +"        return segment;" +"" +"    }" +"" +"    private bool NoEligibleTargetsLeftForNext()" +"    {" +"        List<int> enemyCreatures = GlobalSettings.Instance.TopPlayer.table.CreaturesOnTable.ConvertAll(cl => cl.ID);" +"        List<int> friendlyCreatures = GlobalSettings.Instance.LowPlayer.table.CreaturesOnTable.ConvertAll(cl => cl.ID);" +"        // we also have lowPLayerID and topPlayerID available" +"        // selectedTargets currently holds all ids of selected targets." +"        // currentlySelectingTarget.targetType is of type TargetingOptions" +"        //TODO: based on the value of currentlySelectingTarget.targetType, decide whether there are ny unpicked IDs left to choose from" +"        // Removing already selected targets from the respective lists" +"        enemyCreatures.RemoveAll(id => selectedTargets.Contains(id));" +"        friendlyCreatures.RemoveAll(id => selectedTargets.Contains(id));" +"        switch (currentTarget.targetType)" +"        {" +"            case TargetingOptions.NoTarget:" +"                return true;  // If there's no target, then there's nothing left to pick" +"" +"            case TargetingOptions.AllCreatures:" +"                // If the union of friendly and enemy creatures list is empty, then there's no target left" +"                return friendlyCreatures.Count == 0 && enemyCreatures.Count == 0;" +"" +"            case TargetingOptions.EnemyCreatures:" +"                // If enemy creatures list is empty, then there's no target left" +"                return enemyCreatures.Count == 0;" +"" +"            case TargetingOptions.YourCreatures:" +"                // If friendly creatures list is empty, then there's no target left" +"                return friendlyCreatures.Count == 0;" +"            case TargetingOptions.AllCharacters:" +"                return (friendlyCreatures.Count == 0 && enemyCreatures.Count == 0) && (selectedTargets.Contains(lowPlayerID) && selectedTargets.Contains(topPlayerID));" +"            case TargetingOptions.EnemyCharacters:" +"                return enemyCreatures.Count == 0 && selectedTargets.Contains(topPlayerID);" +"            case TargetingOptions.YourCharacters:" +"                // You'll need to include logic here for Characters if they are separate from Creatures" +"                // Assuming that \"Characters\" include both Creatures and Players," +"                // If there's no target left among creatures and the players were already targeted, then return true" +"                return friendlyCreatures.Count == 0 && selectedTargets.Contains(lowPlayerID);" +"        }" +"" +"        return false; // In case none of the options above were matched, you could return either true or false depending on what makes sense for your game. In this case, I chose to return false as a default." +"    }" +"" +"    private bool SelectedAllTargets()" +"    {" +"        if (selectedTargets.Count == targetsMetadata.Count)" +"        {" +"            return true;" +"        }" +"        else" +"        {" +"            currentlySelectingTarget++;" +"            if (currentlySelectingTarget >= targetsMetadata.Count) return true;" +"            currentTarget = targetsMetadata[currentlySelectingTarget];" +"            return false;" +"        }" +"    }" +"" +"    private bool isTargetValid(EffectTargetData currentTarget)" +"    {" +"        switch (currentTarget.targetType)" +"        {" +"            case TargetingOptions.AllCharacters:" +"                return true;" +"" +"            case TargetingOptions.AllCreatures:" +"                if (Target.tag.Contains(\"Creature\"))" +"                {" +"                    return true;" +"                }" +"                return false;" +"            case TargetingOptions.EnemyCharacters:" +"                if (Target.tag.Contains(\"Creature\") || Target.tag.Contains(\"Player\"))" +"                {" +"                    // had to check that target is not a card" +"                    if ((tag.Contains(\"Low\") && Target.tag.Contains(\"Top\"))" +"                       || (tag.Contains(\"Top\") && Target.tag.Contains(\"Low\")))" +"                    {" +"                        return true;" +"                    }" +"                }" +"                return false;" +"            case TargetingOptions.EnemyCreatures:" +"                if (Target.tag.Contains(\"Creature\"))" +"                {" +"                    // had to check that target is not a card or a player" +"                    if ((tag.Contains(\"Low\") && Target.tag.Contains(\"Top\"))" +"                        || (tag.Contains(\"Top\") && Target.tag.Contains(\"Low\")))" +"                    {" +"                        return true;" +"                    }" +"                }" +"                return false;" +"            case TargetingOptions.YourCharacters:" +"                if (Target.tag.Contains(\"Creature\") || Target.tag.Contains(\"Player\"))" +"                {" +"                    // had to check that target is not a card" +"                    if ((tag.Contains(\"Low\") && Target.tag.Contains(\"Low\"))" +"                        || (tag.Contains(\"Top\") && Target.tag.Contains(\"Top\")))" +"                    {" +"                        return true;" +"                    }" +"                }" +"                return false;" +"            case TargetingOptions.YourCreatures:" +"                if (Target.tag.Contains(\"Creature\"))" +"                {" +"                    // had to check that target is not a card or a player" +"                    if ((tag.Contains(\"Low\") && Target.tag.Contains(\"Low\"))" +"                        || (tag.Contains(\"Top\") && Target.tag.Contains(\"Top\")))" +"                    {" +"                        return true;" +"                    }" +"                }" +"                return false;" +"            default:" +"                Debug.LogWarning(\"Reached default case in DragSpellOnTarget! Suspicious behaviour!!\");" +"                return false;" +"        }" +"    }" +"" +"    private void DeactivateComponents()" +"    {" +"        // return target and arrow to original position" +"        // this position is special for spell cards to show the arrow on top" +"        TargetGO.localPosition = new Vector3(0f, 0f, -0.1f);" +"        sr.enabled = false;" +"        lr.enabled = false;" +"        triangleSR.enabled = false;" +"        extraLRs.ForEach(g =>" +"        {" +"            Destroy(g);" +"        });" +"        extraLRs.Clear();" +"        selectedTargets.Clear();" +"        MessageManager.Instance.HideMessageInstant();" +"    }" +"" +"    // NOT USED IN THIS SCRIPT" +"    protected override bool DragSuccessful()" +"    {" +"        return true;" +"    }" +"" +"    public override Transform GetTargetTransform()" +"    {" +"        return TargetGO;" +"    }" +"}" 
  }
,
  {
    "fileName": "BattleStats.cs",
    "relativeFilePath": "Assets/Scripts/Logic/BattleStats.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using System.Collections.Generic;" +"" +"public static class BattleStats " +"{" +"    public static List<CardLogic> PlayerCards = new List<CardLogic>();" +"    public static List<CardLogic> EnemyCards = new List<CardLogic>();" +"" +"    public static List<CreatureLogic> PlayerCreatures = new List<CreatureLogic>();" +"    public static List<CreatureLogic> EnemyCreatures = new List<CreatureLogic>();" +"}" 
  }
,
  {
    "fileName": "Buff.cs",
    "relativeFilePath": "Assets/Scripts/Logic/Buffs/Buff.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"[System.Serializable]" +"public class BuffInfo" +"{" +"    public string BuffClassName;" +"    public int buffHealth;" +"    public int buffAttack;" +"    public int buffManaCost;" +"    // for example: how many cards to draw, for how many points to heal?" +"    public int buffSpecialAmount;" +"}" +"" +"" +"// this script will be attached to a creature or SPELL and " +"// a) affect his stats" +"// b) give him some new powers" +"// c) create a spell effect" +"[System.Serializable]" +"public class Buff" +"{" +"    public int buffHealth;" +"    public int buffAttack;" +"    public int buffManaCost;" +"    // for example: how many cards to draw, for how many points to heal?" +"    public int buffSpecialAmount;" +"" +"    public void SetValuesFromBuffInfo(BuffInfo bi)" +"    {" +"        buffAttack = bi.buffAttack;" +"        buffHealth = bi.buffHealth;" +"        buffManaCost = bi.buffManaCost;" +"        buffSpecialAmount = bi.buffSpecialAmount;" +"    }" +"" +"    public virtual void BuffAction()" +"    {" +"        " +"    }" +"" +"    public virtual void AttachBuffToEvent()" +"    {" +"        " +"    }" +"" +"}" 
  }
,
  {
    "fileName": "CardLogic.cs",
    "relativeFilePath": "Assets/Scripts/Logic/CardLogic.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using System.Collections.Generic;" +"using System;" +"using CG.Cards;" +"" +"[System.Serializable]" +"public class CardLogic: IIdentifiable" +"{" +"    public Player owner;" +"    public int UniqueCardID; " +"" +"    public CardAsset ca;" +"    public GameObject VisualRepresentation;" +"" +"    private int baseManaCost;" +"    public CompositeEffect effect;" +"" +"    public int ID" +"    {" +"        get{ return UniqueCardID; }" +"    }" +"" +"    public int CurrentManaCost{ get; set; }" +"" +"    public bool CanBePlayed" +"    {" +"        get" +"        {" +"            bool ownersTurn = (TurnManager.Instance.whoseTurn == owner);" +"            // for spells the amount of characters on the field does not matter" +"            bool fieldNotFull = true;" +"            // but if this is a creature, we have to check if there is room on board (table)" +"            if (ca.MaxHealth > 0)" +"                fieldNotFull = (owner.table.CreaturesOnTable.Count < 7);" +"            //Debug.Log(\"Card: \" + ca.name + \" has params: ownersTurn=\" + ownersTurn + \"fieldNotFull=\" + fieldNotFull + \" hasMana=\" + (CurrentManaCost <= owner.ManaLeft));" +"            return ownersTurn && fieldNotFull && (CurrentManaCost <= owner.ManaLeft);" +"        }" +"    }" +"" +"    public CardLogic(CardAsset ca)" +"    {" +"        this.ca = ca;" +"        UniqueCardID = IDFactory.GetUniqueID();" +"        //UniqueCardID = IDFactory.GetUniqueID();" +"        baseManaCost = ca.ManaCost;" +"        ResetManaCost();" +"        if (ca.SpellEffect != null)" +"        {" +"            effect = ca.SpellEffect;" +"        }" +"        CardsCreatedThisGame.Add(UniqueCardID, this);" +"    }" +"" +"    public void ResetManaCost()" +"    {" +"        CurrentManaCost = baseManaCost;" +"    }" +"" +"    // STATIC (for managing IDs)" +"    public static Dictionary<int, CardLogic> CardsCreatedThisGame = new Dictionary<int, CardLogic>();" +"" +"}" 
  }
,
  {
    "fileName": "Character.cs",
    "relativeFilePath": "Assets/Scripts/Logic/Character.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public interface ICharacter: IIdentifiable" +"{	" +"    int Health { get;    set;}" +"    void Die();" +"}" +"" +"public interface IIdentifiable" +"{" +"    int ID { get; }" +"}" 
  }
,
  {
    "fileName": "CreatureLogic.cs",
    "relativeFilePath": "Assets/Scripts/Logic/CreatureLogic.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using System.Collections.Generic;" +"using CG.Cards;" +"[System.Serializable]" +"public class CreatureLogic : ICharacter" +"{" +"    //TODO: This needs to hold ref to all creatures that are about to die and it needs to trigger die for all  with one command." +"    //TODO: This new command has to be triggered at a certain point, maybe after the Command.Queue is empty?" +"    // PUBLIC FIELDS" +"    public Player owner;" +"    public CardAsset ca;" +"    public CreatureEffect effect;" +"    private static List<CreatureLogic> CreaturesToDie = new List<CreatureLogic>();" +"    public int UniqueCreatureID;" +"    public int ID" +"    {" +"        get { return UniqueCreatureID; }" +"    }" +"    public bool Frozen = false;" +"" +"    // the basic health that we have in CardAsset" +"    private int baseHealth;" +"    // health with all the current buffs taken into account" +"    public int MaxHealth" +"    {" +"        get { return baseHealth; }" +"    }" +"" +"    private int health;" +"" +"    public int Health" +"    {" +"        get { return health; }" +"" +"        set" +"        {" +"            health = Mathf.Min(value, MaxHealth);" +"            if (value <= 0)" +"            {" +"                CreaturesToDie.Add(this);" +"                isDead = true;" +"            }" +"" +"" +"        }" +"    }" +"    private bool IsDead = false;" +"    public bool isDead" +"    {" +"        get { return IsDead; }" +"        set" +"        {" +"            IsDead = value;" +"        }" +"    }" +"" +"    public bool CanAttack" +"    {" +"        get" +"        {" +"            bool ownersTurn = (TurnManager.Instance.whoseTurn == owner);" +"            return (ownersTurn && (AttacksLeftThisTurn > 0) && !Frozen);" +"        }" +"    }" +"" +"    private int baseAttack;" +"    // attack with buffs" +"    public int Attack" +"    {" +"        get { return baseAttack; }" +"" +"    }" +"" +"    private int attacksForOneTurn = 1;" +"    public int AttacksLeftThisTurn" +"    {" +"        get;" +"        set;" +"    }" +"" +"    // CONSTRUCTOR" +"    public CreatureLogic(Player owner, CardAsset ca)" +"    {" +"        this.ca = ca;" +"        baseHealth = ca.MaxHealth;" +"        Health = ca.MaxHealth;" +"        baseAttack = ca.Attack;" +"        attacksForOneTurn = ca.AttacksForOneTurn;" +"        // AttacksLeftThisTurn is now equal to 0" +"        if (ca.Charge)" +"            AttacksLeftThisTurn = attacksForOneTurn;" +"        this.owner = owner;" +"        UniqueCreatureID = IDFactory.GetUniqueID();" +"        if (ca.CreatureScriptName != null && ca.CreatureScriptName != \"\")" +"        {" +"            effect = CreatureEffectFactory.CreateCreatureEffect(ca.CreatureScriptName, owner, this, ca.specialCreatureAmount);" +"            effect.RegisterEffect();" +"        }" +"        CreaturesCreatedThisGame.Add(UniqueCreatureID, this);" +"    }" +"    static CreatureLogic()" +"    {" +"        // Subscribe to the OnQueueEmpty event with a static method" +"        Command.OnQueueEmpty += HandleQueueEmpty;" +"    }" +"" +"" +"    public void OnTurnStart()" +"    {" +"        AttacksLeftThisTurn = attacksForOneTurn;" +"    }" +"" +"    public static void HandleQueueEmpty()" +"    {" +"        //Debug.Log(\"Calling Command Empty event handler\");" +"        // Handle the event. Create a CreaturesDieCommand when the event is raised." +"        if (CreatureLogic.CreaturesToDie.Count > 0)" +"        {" +"            Debug.Log(\"Creatures need to die\");" +"            List<CreatureLogic> creaturesToDieCopy = new List<CreatureLogic>(CreatureLogic.CreaturesToDie);" +"            new AllCreaturesDieCommand(creaturesToDieCopy).AddToQueue(true);" +"            CreatureLogic.CreaturesToDie.Clear();" +"        }" +"    }" +"    public void Die()" +"    {" +"        owner.table.CreaturesOnTable.Remove(this);" +"" +"        new CreatureDieCommand(UniqueCreatureID, owner).AddToQueue();" +"    }" +"" +"    public void GoFace()" +"    {" +"        AttacksLeftThisTurn--;" +"        int targetHealthAfter = owner.otherPlayer.Health - Attack;" +"        new CreatureAttackCommand(owner.otherPlayer.PlayerID, UniqueCreatureID, 0, Attack, Health, targetHealthAfter).AddToQueue();" +"        owner.otherPlayer.Health -= Attack;" +"    }" +"" +"    public void AttackCreature(CreatureLogic target)" +"    {" +"            AttacksLeftThisTurn--;" +"        // calculate the values so that the creature does not fire the DIE command before the Attack command is sent" +"        int targetHealthAfter = target.Health - Attack;" +"        int attackerHealthAfter = Health - target.Attack;" +"        new CreatureAttackCommand(target.UniqueCreatureID, UniqueCreatureID, target.Attack, Attack, attackerHealthAfter, targetHealthAfter).AddToQueue();" +"" +"        target.Health -= Attack;" +"        Health -= target.Attack;" +"    }" +"" +"    public void AttackCreatureWithID(int uniqueCreatureID)" +"    {" +"        CreatureLogic target = CreatureLogic.CreaturesCreatedThisGame[uniqueCreatureID];" +"        AttackCreature(target);" +"    }" +"" +"    // STATIC For managing IDs" +"    public static Dictionary<int, CreatureLogic> CreaturesCreatedThisGame = new Dictionary<int, CreatureLogic>();" +"" +"}" 
  }
,
  {
    "fileName": "BiteOwner.cs",
    "relativeFilePath": "Assets/Scripts/Logic/CreatureScripts/BiteOwner.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class BiteOwner : CreatureEffect" +"{  " +"    public BiteOwner(Player owner, CreatureLogic creature, int specialAmount): base(owner, creature, specialAmount)" +"    {}" +"" +"    public override void RegisterEffect()" +"    {" +"        owner.EndTurnEvent += CauseEffect;" +"        Debug.Log(\"Registered bite effect!!!!\");" +"    }" +"" +"    public override void CauseEffect()" +"    {" +"        Debug.Log(\"InCauseEffect: owner: \"+ owner + \" specialAmount: \"+ specialAmount);" +"        new DealDamageCommand(owner.PlayerID, specialAmount, owner.Health - specialAmount).AddToQueue();" +"        owner.Health -= specialAmount;" +"    }" +"" +"" +"}" 
  }
,
  {
    "fileName": "CreatureEffect.cs",
    "relativeFilePath": "Assets/Scripts/Logic/CreatureScripts/CreatureEffect.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public abstract class CreatureEffect " +"{" +"    protected Player owner;" +"    protected CreatureLogic creature;" +"    protected int specialAmount;" +"" +"    public CreatureEffect(Player owner, CreatureLogic creature, int specialAmount)" +"    {" +"        this.creature = creature;" +"        this.owner = owner;" +"        this.specialAmount = specialAmount;" +"    }" +"" +"    public abstract void RegisterEffect();" +"" +"    public abstract void CauseEffect();" +"" +"}" 
  }
,
  {
    "fileName": "CreatureEffectFactory.cs",
    "relativeFilePath": "Assets/Scripts/Logic/CreatureScripts/CreatureEffectFactory.cs",
    "type": "script",
    "content": "using System;" +"using System.Collections;" +"using System.Collections.Generic;" +"using UnityEngine;" +"" +"public static class CreatureEffectFactory" +"{" +"    private static readonly Dictionary<string, Func<Player, CreatureLogic, int, CreatureEffect>> registry =" +"        new Dictionary<string, Func<Player, CreatureLogic, int, CreatureEffect>>();" +"    static CreatureEffectFactory()" +"    {" +"        // RegisterCreatureEffect(\"CreatureEffectType1\", (owner, creature, specialAmount) => new CreatureEffect(owner, creature, specialAmount));" +"        // RegisterCreatureEffect(\"CreatureEffectType2\", (owner, creature, specialAmount) => new CreatureEffect(owner, creature, specialAmount));" +"        // Add other CreatureEffect types here." +"    }" +"    public static void RegisterCreatureEffect(string scriptName, Func<Player, CreatureLogic, int, CreatureEffect> creator)" +"    {" +"        registry.Add(scriptName, creator);" +"    }" +"    public static CreatureEffect CreateCreatureEffect(string scriptName, Player owner, CreatureLogic creature, int specialAmount)" +"    {" +"        if (registry.ContainsKey(scriptName))" +"        {" +"            return registry[scriptName](owner, creature, specialAmount);" +"        }" +"        else" +"        {" +"            // Possibly throw an exception here or handle the case when a creature effect with a given name is not found." +"            return null;" +"        }" +"    }" +"}" 
  }
,
  {
    "fileName": "Deck.cs",
    "relativeFilePath": "Assets/Scripts/Logic/Deck.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using System.Collections.Generic;" +"using CG.Cards;" +"public class Deck : MonoBehaviour {" +"" +"    public List<CardAsset> cards = new List<CardAsset>();" +"" +"    void Awake()" +"    {" +"        cards.Shuffle();" +"    }" +"	" +"}" 
  }
,
  {
    "fileName": "FindByType.cs",
    "relativeFilePath": "Assets/Scripts/Logic/FindByType.cs",
    "type": "script",
    "content": "using System.Collections;" +"using System.Collections.Generic;" +"using UnityEngine;" +"" +"public class FindByType : MonoBehaviour" +"{" +"   void Start()" +"    {" +"        // This will find all GameObjects in the scene that are using the YourTargetScript as a component." +"        DamageEffect[] objects = FindObjectsOfType<DamageEffect>();" +"        " +"        foreach (DamageEffect obj in objects)" +"        {" +"            Debug.Log(obj.gameObject.name);" +"        }" +"    }" +"}" 
  }
,
  {
    "fileName": "Hand.cs",
    "relativeFilePath": "Assets/Scripts/Logic/Hand.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using System.Collections.Generic;" +"" +"public class Hand : MonoBehaviour " +"{" +"    public List<CardLogic> CardsInHand = new List<CardLogic>(); " +"" +"}" 
  }
,
  {
    "fileName": "IDHolder.cs",
    "relativeFilePath": "Assets/Scripts/Logic/IDHolder.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using System.Collections.Generic;" +"using System;" +"" +"public class IDHolder : MonoBehaviour {" +"" +"    private int uniqueId;" +"    public int UniqueID {" +"        get {" +"            return uniqueId;" +"        }" +"        set {" +"            uniqueId = value;" +"            allIDHolders.Add(uniqueId, this);   " +"" +"        }" +"    }" +"    private static Dictionary<int, IDHolder> allIDHolders = new Dictionary<int, IDHolder>();" +"" +"    void Awake()" +"    {" +"       " +"    }" +"" +"    public static GameObject GetGameObjectWithID(int ID)" +"    {" +"        IDHolder thing = allIDHolders.GetValueOrDefault(ID, null);" +"        if (thing != null) {" +"            return thing.gameObject;" +"        }" +"        Debug.Log(\"Thing not found: \" + ID);" +"        //Debug.Log(\"Call Stack: \" + Environment.StackTrace);" +"        return null;" +"    }" +"    public static List<GameObject> GetGameObjects(List<int> IDs) {" +"        List<GameObject> objects = new List<GameObject>();" +"        IDs.ForEach(id => {" +"            GameObject thing = GetGameObjectWithID(id);" +"            if (thing != null) objects.Add(thing);" +"        });" +"        return objects;" +"    }" +"" +"    public static void ClearIDHoldersList()" +"    {" +"        allIDHolders.Clear();" +"    }" +"}" 
  }
,
  {
    "fileName": "MovesHighlighter.cs",
    "relativeFilePath": "Assets/Scripts/Logic/MovesHighlighter.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class MovesHighlighter : MonoBehaviour {" +"" +"	" +"}" 
  }
,
  {
    "fileName": "Player.cs",
    "relativeFilePath": "Assets/Scripts/Logic/Player.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using System.Collections.Generic;" +"using CG.Cards;" +"using DG.Tweening;" +"using System;" +"" +"public class Player : MonoBehaviour, ICharacter" +"{" +"    public int PlayerID;" +"    public CharacterAsset charAsset;" +"    public PlayerArea PArea;" +"    public SpellEffect HeroPowerEffect;" +"" +"    public Deck deck;" +"    public Hand hand;" +"    public Table table;" +"" +"    private int bonusManaThisTurn = 0;" +"    public bool usedHeroPowerThisTurn = false;" +"    private int testTracker = 0;" +"" +"    public int ID" +"    {" +"        get { return PlayerID; }" +"    }" +"" +"    private int manaThisTurn;" +"    public int ManaThisTurn" +"    {" +"        get { return manaThisTurn; }" +"        set" +"        {" +"            manaThisTurn = value;" +"            //PArea.ManaBar.TotalCrystals = manaThisTurn;" +"            new UpdateManaCrystalsCommand(this, manaThisTurn, manaLeft).AddToQueue();" +"        }" +"    }" +"" +"    private int manaLeft;" +"    public int ManaLeft" +"    {" +"        get" +"        { return manaLeft; }" +"        set" +"        {" +"            manaLeft = value;" +"            //PArea.ManaBar.AvailableCrystals = manaLeft;" +"            new UpdateManaCrystalsCommand(this, ManaThisTurn, manaLeft).AddToQueue();" +"            //Debug.Log(ManaLeft);" +"            // if (TurnManager.Instance.whoseTurn == this)" +"            //     HighlightPlayableObjects();" +"        }" +"    }" +"" +"    public Player otherPlayer" +"    {" +"        get" +"        {" +"            if (Players[0] == this)" +"                return Players[1];" +"            else" +"                return Players[0];" +"        }" +"    }" +"" +"    private int health;" +"    public int Health" +"    {" +"        get { return health; }" +"        set" +"        {" +"            health = value;" +"            if (value <= 0)" +"                Die();" +"        }" +"    }" +"" +"    public delegate void VoidWithNoArguments();" +"    //public event VoidWithNoArguments CreaturePlayedEvent;" +"    //public event VoidWithNoArguments SpellPlayedEvent;" +"    //public event VoidWithNoArguments StartTurnEvent;" +"    public event VoidWithNoArguments EndTurnEvent;" +"" +"    public static Player[] Players;" +"" +"    void Awake()" +"    {" +"        Players = GameObject.FindObjectsOfType<Player>();" +"        PlayerID = IDFactory.GetUniqueID();" +"    }" +"" +"    public void RegisterEvents()" +"    {" +"        this.PArea.tableVisual.OnTableChange += HighlightCreatures;" +"        this.PArea.handVisual.OnHandChange += HighlightCards;" +"        this.PArea.handVisual.OnHandChange += HighlightHeroPower;" +"    }" +"" +"    public virtual void OnTurnStart()" +"    {" +"        // add one mana crystal to the pool;" +"        Debug.Log(\"In ONTURNSTART for \" + gameObject.name);" +"        usedHeroPowerThisTurn = false;" +"        ManaThisTurn++;" +"        ManaLeft = ManaThisTurn;" +"        foreach (CreatureLogic cl in table.CreaturesOnTable)" +"            cl.OnTurnStart();" +"        PArea.HeroPower.WasUsedThisTurn = false;" +"        HighlightPlayableObjects();" +"" +"    }" +"" +"    public void GetBonusMana(int amount)" +"    {" +"        bonusManaThisTurn += amount;" +"        ManaThisTurn += amount;" +"        ManaLeft += amount;" +"    }" +"" +"    public void OnTurnEnd()" +"    {" +"        if (EndTurnEvent != null)" +"            EndTurnEvent.Invoke();" +"        ManaThisTurn -= bonusManaThisTurn;" +"        bonusManaThisTurn = 0;" +"        GetComponent<TurnMaker>().StopAllCoroutines();" +"        RemoveHighlights();" +"    }" +"" +"" +"    public void DrawACard(bool fast = false, bool addToFront = false)" +"    {" +"        if (deck.cards.Count > 0)" +"        {" +"            if (hand.CardsInHand.Count < PArea.handVisual.slots.Children.Length)" +"            {" +"                // 1) save index to place a visual card into visual hand" +"                int indexToPlaceACard = hand.CardsInHand.Count;" +"                // 2) logic: add card to hand" +"                CardLogic newCard = new CardLogic(deck.cards[0]);" +"                newCard.owner = this;" +"                hand.CardsInHand.Add(newCard);" +"                // Debug.Log(hand.CardsInHand.Count);" +"                // 3) logic: remove the card from the deck" +"                deck.cards.RemoveAt(0);" +"                // 4) create a command" +"                new DrawACardCommand(hand.CardsInHand[indexToPlaceACard], this, indexToPlaceACard, fast, fromDeck: true).AddToQueue(addToFront);" +"            }" +"        }" +"        else" +"        {" +"            Debug.Log(\"No cards left: \" + deck.cards.Count);" +"            // there are no cards in the deck, take fatigue damage." +"        }" +"" +"    }" +"    public void DrawCards(int nr, bool addToFront = false)" +"    {" +"        bool fast = nr > 3;" +"        for (int i = 0; i < nr; i++)" +"        {" +"            DrawACard(fast, addToFront );" +"        }" +"" +"" +"    }" +"    public void SummonCreatures(CardAsset creature, int nr)" +"    {" +"        List<CreatureLogic> summons = new List<CreatureLogic>();" +"        for (int i = 0; i < nr; i++)" +"        {" +"            CreatureLogic cl = new CreatureLogic(this, creature);" +"            table.AddCreature(cl);" +"            summons.Add(cl);" +"        }" +"" +"        //Invoke a command to inform visual layer about changes. (have to create new)" +"        new SummonCreaturesCommand(this, summons).AddToQueue();" +"    }" +"" +"    public void DrawACoin()" +"    {" +"        if (hand.CardsInHand.Count < PArea.handVisual.slots.Children.Length)" +"        {" +"            // 1) logic: add card to hand" +"            CardLogic newCard = new CardLogic(GlobalSettings.Instance.CoinCard);" +"            newCard.owner = this;" +"            hand.CardsInHand.Add(newCard);" +"            // 2) send message to the visual Deck" +"            new DrawACardCommand(hand.CardsInHand[hand.CardsInHand.Count - 1], this, hand.CardsInHand.Count - 1, fast: true, fromDeck: false).AddToQueue();" +"        }" +"        // no removal from deck because the coin was not in the deck" +"    }" +"" +"    public void PlayASpellFromHand(int SpellCardUniqueID, List<int> ids)" +"    {" +"        // ManaLeft -= playedCard.CurrentManaCost;" +"        GameObject card = IDHolder.GetGameObjectWithID(SpellCardUniqueID);" +"        // Assuming \`gameObject\` is your GameObject" +"        BetterCardRotation betterCardRotation = card.GetComponent<BetterCardRotation>();" +"        List<int> idBackups = null;" +"        if (ids != null)" +"            idBackups = new List<int>(ids);" +"        // Check if the component exists" +"        if (betterCardRotation != null)" +"        {" +"            // Disable the script" +"            betterCardRotation.enabled = false;" +"        }" +"        Sequence seq = CreateMoveToPlayPositionSequence(card, 0.25f, 1f, () =>" +"        {" +"                " +"           " +"                PlayASpellFromHand(CardLogic.CardsCreatedThisGame[SpellCardUniqueID], GetCharactersFromIds(idBackups));" +"        });" +"        seq.Play();" +"    }" +"" +"    private List<IIdentifiable> GetCharactersFromIds(List<int> ids)" +"    {" +"        if (ids == null || ids.Count == 0) return null;" +"        List<IIdentifiable> chars = new List<IIdentifiable>();" +"        foreach (int id in ids)" +"        {" +"            if (id == ID)" +"            {" +"                chars.Add(this);" +"                continue;" +"            }" +"            if (id == otherPlayer.ID)" +"            {" +"                chars.Add(this.otherPlayer);" +"                continue;" +"            }" +"            chars.Add(CreatureLogic.CreaturesCreatedThisGame[id]);" +"        }" +"        return chars;" +"    }" +"" +"    public void PlayASpellFromHand(CardLogic playedCard, List<IIdentifiable> targets)" +"    {" +"        ManaLeft -= playedCard.CurrentManaCost;" +"        //Visually and logically remove the card from hand before activating the effects" +"        // remove this card from hand" +"        hand.CardsInHand.Remove(playedCard);" +"        // no matter what happens, move this card to PlayACardSpot" +"        new PlayASpellCardCommand(this, playedCard).AddToQueue();" +"        " +"        if (playedCard.effect != null)" +"        {" +"            Queue<IIdentifiable> targetsQueue = new Queue<IIdentifiable>();" +"            if (targets != null ) {" +"                targets.ForEach(t => targetsQueue.Enqueue(t));" +"            }" +"            Command.PauseQueueExecution();" +"            playedCard.effect.ActivateEffects(targetsQueue);" +"            Command.ResumeQueueExecution();" +"        }" +"" +"        else" +"        {" +"            Debug.LogWarning(\"No effect found on card \" + playedCard.ca.name);" +"        }" +"        " +"        new RemovePlayedSpellCardFromTheScreenCommand(this, playedCard).AddToQueue();" +"        // check if this is a creature or a spell" +"    }" +"" +"    public void PlayACreatureFromHand(int UniqueID, int tablePos)" +"    {" +"        PlayACreatureFromHand(CardLogic.CardsCreatedThisGame[UniqueID], tablePos);" +"    }" +"" +"    public void PlayACreatureFromHand(CardLogic playedCard, int tablePos)" +"    {" +"        //Debug.Log(ManaLeft);" +"        //Debug.Log(playedCard.CurrentManaCost);" +"        ManaLeft -= playedCard.CurrentManaCost;" +"        GameObject card = IDHolder.GetGameObjectWithID(playedCard.UniqueCardID);" +"        // Assuming \`gameObject\` is your GameObject" +"        BetterCardRotation betterCardRotation = card.GetComponent<BetterCardRotation>();" +"" +"        // Check if the component exists" +"        if (betterCardRotation != null)" +"        {" +"            // Disable the script" +"            betterCardRotation.enabled = false;" +"        }" +"        Sequence seq = CreateMoveToPlayPositionSequence(card, 0.25f, 1f, () =>" +"        {" +"            // Debug.Log(\"Mana Left after played a creature: \" + ManaLeft);" +"            // create a new creature object and add it to Table" +"            CreatureLogic newCreature = new CreatureLogic(this, playedCard.ca);" +"            table.CreaturesOnTable.Insert(tablePos, newCreature);" +"            // no matter what happens, move this card to PlayACardSpot" +"            // remove this card from hand" +"            hand.CardsInHand.Remove(playedCard);" +"            new PlayACreatureCommand(playedCard, this, tablePos, newCreature.UniqueCreatureID).AddToQueue();" +"            " +"            //TODO: Creature effect trigger here" +"            //HighlightPlayableObjects();" +"        });" +"        seq.Play();" +"    }" +"    private Sequence CreateMoveToPlayPositionSequence(GameObject card, float transitionTime, float waitTime, Action onCompleteCallback)" +"    {" +"        Sequence seq = DOTween.Sequence();" +"        seq.Append(card.transform.DOMove(PArea.PlayCardStackPosition.position, transitionTime));" +"        seq.Insert(0f, card.transform.DORotate(Vector3.zero, transitionTime));" +"        seq.AppendInterval(waitTime);" +"        seq.OnComplete(() => onCompleteCallback());" +"        return seq;" +"    }" +"    public void PredictNewSlotForCreatureOnTable(int tablePos)" +"    {" +"" +"    }" +"" +"    public void Die()" +"    {" +"        // game over" +"        // block both players from taking new moves " +"        PArea.ControlsON = false;" +"        otherPlayer.PArea.ControlsON = false;" +"        TurnManager.Instance.StopTheTimer();" +"        new GameOverCommand(this).AddToQueue();" +"    }" +"" +"    private void RemoveHighlights()" +"    {" +"        PArea.HeroPower.Highlighted = false;" +"        foreach (CreatureLogic crl in table.CreaturesOnTable)" +"        {" +"            GameObject g = IDHolder.GetGameObjectWithID(crl.UniqueCreatureID);" +"            if (g != null)" +"                g.GetComponent<OneCreatureManager>().CanAttackNow = false;" +"        }" +"        foreach (CardLogic cl in hand.CardsInHand)" +"        {" +"            GameObject g = IDHolder.GetGameObjectWithID(cl.UniqueCardID);" +"            if (g != null)" +"                g.GetComponent<OneCardManager>().CanBePlayedNow = false;" +"        }" +"" +"    }" +"    // METHODS TO SHOW GLOW HIGHLIGHTS" +"    public void HighlightPlayableObjects(bool removeAllHighlights = false)" +"    {" +"        HighlightCards();" +"        HighlightCreatures();" +"        HighlightHeroPower();" +"    }" +"" +"    private void HighlightHeroPower()" +"    {" +"        if (TurnManager.Instance.whoseTurn != this) return;" +"        // highlight hero power" +"        PArea.HeroPower.Highlighted = (!usedHeroPowerThisTurn) && (ManaLeft > 1);" +"    }" +"" +"    private void HighlightCreatures()" +"    {" +"        if (TurnManager.Instance.whoseTurn != this) return;" +"        foreach (CreatureLogic crl in table.CreaturesOnTable)" +"        {" +"            GameObject g = IDHolder.GetGameObjectWithID(crl.UniqueCreatureID);" +"            if (g != null)" +"                g.GetComponent<OneCreatureManager>().CanAttackNow = crl.CanAttack;" +"        }" +"    }" +"" +"    private void HighlightCards()" +"    {" +"        if (TurnManager.Instance.whoseTurn != this) return;" +"        //TODO: Fix bug, after spell played that summons, some summoned creatures show up highlighted." +"        //Debug.Log(\"HighlightPlayable remove: \"+ removeAllHighlights);" +"        foreach (CardLogic cl in hand.CardsInHand)" +"        {" +"            GameObject g = IDHolder.GetGameObjectWithID(cl.UniqueCardID);" +"            if (g != null)" +"                g.GetComponent<OneCardManager>().CanBePlayedNow = (cl.CurrentManaCost <= ManaLeft);" +"        }" +"    }" +"" +"    // START GAME METHODS" +"    public void LoadCharacterInfoFromAsset()" +"    {" +"        Health = charAsset.MaxHealth;" +"        // change the visuals for portrait, hero power, etc..." +"        PArea.Portrait.charAsset = charAsset;" +"        PArea.Portrait.ApplyLookFromAsset();" +"        // TODO: insert the code to attach hero power script here. " +"        if (charAsset.HeroPowerName != null && charAsset.HeroPowerName != \"\")" +"        {" +"            // HeroPowerEffect = System.Activator.CreateInstance(System.Type.GetType(charAsset.HeroPowerName)) as SpellEffect;" +"        }" +"        else" +"        {" +"            Debug.LogWarning(\"Check hero powr name for character \" + charAsset.ClassName);" +"        }" +"    }" +"" +"    public void TransmitInfoAboutPlayerToVisual()" +"    {" +"        PArea.Portrait.gameObject.AddComponent<IDHolder>().UniqueID = PlayerID;" +"        if (GetComponent<TurnMaker>() is AITurnMaker)" +"        {" +"            // turn off turn making for this character" +"            PArea.AllowedToControlThisPlayer = false;" +"        }" +"        else" +"        {" +"            // allow turn making for this character" +"            PArea.AllowedToControlThisPlayer = true;" +"        }" +"    }" +"" +"    public void UseHeroPower()" +"    {" +"        ManaLeft -= 2;" +"        usedHeroPowerThisTurn = true;" +"        HeroPowerEffect.ActivateEffect();" +"    }" +"}" 
  }
,
  {
    "fileName": "RopeTimer.cs",
    "relativeFilePath": "Assets/Scripts/Logic/RopeTimer.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using UnityEngine.UI;" +"using UnityEngine.Events;" +"using UnityEngine.EventSystems;" +"" +"public class RopeTimer : MonoBehaviour, IEventSystemHandler" +"{" +"    public GameObject RopeGameObject;" +"    public Slider RopeSlider;" +"	public float TimeForOneTurn;" +"    public float RopeBurnTime;" +"    public Text TimerText;" +"" +"    private float timeTillZero;" +"    private bool counting = false;" +"    private bool ropeIsBurning;" +"" +"    [SerializeField]" +"    public UnityEvent TimerExpired = new UnityEvent();" +"" +"    void Awake()" +"    {" +"        if (RopeGameObject != null)" +"        {" +"            RopeSlider.minValue = 0;" +"            RopeSlider.maxValue = RopeBurnTime;" +"            RopeGameObject.SetActive(false);" +"        }" +"    }" +"" +"    public void StartTimer()" +"	{" +"        timeTillZero = TimeForOneTurn;" +"		counting = true;" +"        ropeIsBurning = false;" +"        if (RopeGameObject!=null)" +"            RopeGameObject.SetActive(false);" +"	} " +"" +"	public void StopTimer()" +"	{" +"		counting = false;" +"	}" +"	" +"	// Update is called once per frame" +"	void Update () " +"	{" +"		if (counting) " +"		{" +"			timeTillZero -= Time.deltaTime;" +"            if (TimerText!=null)" +"                TimerText.text = ToString();" +"" +"            if (RopeGameObject != null)" +"            {" +"                // check for rope" +"                if (timeTillZero <= RopeBurnTime && !ropeIsBurning)" +"                {" +"                    ropeIsBurning = true;" +"                    RopeGameObject.SetActive(true);" +"                }" +"                // rope update" +"                if (ropeIsBurning)" +"                {" +"                    RopeSlider.value = timeTillZero;" +"                }" +"            }" +"" +"            // check for TimeExpired" +"			if(timeTillZero<=0)" +"			{" +"				counting = false;" +"                //RopeGameObject.SetActive(false);" +"                TimerExpired.Invoke();" +"			}" +"		}" +"	" +"	}" +"" +"	public override string ToString ()" +"	{" +"		int inSeconds = Mathf.RoundToInt (timeTillZero);" +"		string justSeconds = (inSeconds % 60).ToString ();" +"		if (justSeconds.Length == 1)" +"			justSeconds = \"0\" + justSeconds;" +"		string justMinutes = (inSeconds / 60).ToString ();" +"		if (justMinutes.Length == 1)" +"			justMinutes = \"0\" + justMinutes;" +"" +"		return string.Format (\"{0}:{1}\", justMinutes, justSeconds);" +"	}" +"}" 
  }
,
  {
    "fileName": "DamageAllCreatures.cs",
    "relativeFilePath": "Assets/Scripts/Logic/SpellScripts/DamageAllCreatures.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class DamageAllCreatures : SpellEffect {" +"" +"    public override void ActivateEffect(int specialAmount = 0, ICharacter target = null)" +"    {" +"        CreatureLogic[] CreaturesToDamage = TurnManager.Instance.whoseTurn.otherPlayer.table.CreaturesOnTable.ToArray();" +"        foreach (CreatureLogic cl in CreaturesToDamage)" +"        {" +"            new DealDamageCommand(cl.ID, specialAmount, healthAfter: cl.Health - specialAmount).AddToQueue();" +"            cl.Health -= specialAmount;" +"        }" +"    }" +"}" 
  }
,
  {
    "fileName": "DealDamageToTarget.cs",
    "relativeFilePath": "Assets/Scripts/Logic/SpellScripts/DealDamageToTarget.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class DealDamageToTarget : SpellEffect " +"{" +"    " +"" +"    public override void ActivateEffect(int specialAmount = 0, ICharacter target = null)" +"    {" +"        new DealDamageCommand(target.ID, specialAmount, healthAfter: target.Health - specialAmount).AddToQueue();" +"        target.Health -= specialAmount;" +"    }" +"}" 
  }
,
  {
    "fileName": "GiveManaBonus.cs",
    "relativeFilePath": "Assets/Scripts/Logic/SpellScripts/GiveManaBonus.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class GiveManaBonus: SpellEffect " +"{" +"    public override void ActivateEffect(int specialAmount = 0, ICharacter target = null)" +"    {" +"        TurnManager.Instance.whoseTurn.GetBonusMana(specialAmount);" +"    }" +"}" 
  }
,
  {
    "fileName": "HeroPower2Face.cs",
    "relativeFilePath": "Assets/Scripts/Logic/SpellScripts/HeroPower2Face.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class HeroPower2Face : SpellEffect " +"{" +"" +"    public override void ActivateEffect(int specialAmount = 0, ICharacter target = null)" +"    {" +"        new DealDamageCommand(TurnManager.Instance.whoseTurn.otherPlayer.PlayerID, 2, TurnManager.Instance.whoseTurn.otherPlayer.Health - 2).AddToQueue();" +"        TurnManager.Instance.whoseTurn.otherPlayer.Health -= 2;" +"    }" +"}" 
  }
,
  {
    "fileName": "HeroPowerDrawCardTakeDamage.cs",
    "relativeFilePath": "Assets/Scripts/Logic/SpellScripts/HeroPowerDrawCardTakeDamage.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class HeroPowerDrawCardTakeDamage : SpellEffect {" +"" +"    public override void ActivateEffect(int specialAmount = 0, ICharacter target = null)" +"    {" +"        // Take 2 damage" +"        new DealDamageCommand(TurnManager.Instance.whoseTurn.PlayerID, 2, TurnManager.Instance.whoseTurn.Health - 2).AddToQueue();" +"        TurnManager.Instance.whoseTurn.Health -= 2;" +"        // Draw a card" +"        TurnManager.Instance.whoseTurn.DrawACard();" +"" +"    }" +"}" 
  }
,
  {
    "fileName": "SpellEffect.cs",
    "relativeFilePath": "Assets/Scripts/Logic/SpellScripts/SpellEffect.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class SpellEffect" +"{" +"    public virtual void ActivateEffect(int specialAmount = 0, ICharacter target = null)" +"    {" +"        Debug.Log(\"No Spell effect with this name found! Check for typos in CardAssets\");" +"    }" +"        " +"}" 
  }
,
  {
    "fileName": "SpellFactory.cs",
    "relativeFilePath": "Assets/Scripts/Logic/SpellScripts/SpellFactory.cs",
    "type": "script",
    "content": "using System;" +"using System.Collections;" +"using System.Collections.Generic;" +"using UnityEngine;" +"" +"public static class SpellFactory" +"{" +"    // Start is called before the first frame update" +"    private static Dictionary<string, Func<SpellEffect>> registry = new Dictionary<string, Func<SpellEffect>>();" +"    static SpellFactory()" +"    {" +"        // Register each type of spell with its factory method" +"        // registry[\"Fireball\"] = () => new FireballSpell();" +"        // registry[\"IceBlast\"] = () => new IceBlastSpell();" +"        // ... Add the rest here" +"    }" +"" +"    public static SpellEffect CreateSpell(string spellName)" +"    {" +"        if (registry.TryGetValue(spellName, out Func<SpellEffect> constructor))" +"        {" +"            return constructor();" +"        }" +"        else" +"        {" +"            Debug.Log(\$\"No Spell with the name {spellName} found!\");" +"            return null;" +"        }" +"    }" +"}" 
  }
,
  {
    "fileName": "Table.cs",
    "relativeFilePath": "Assets/Scripts/Logic/Table.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using System.Collections.Generic;" +"" +"public class Table : MonoBehaviour" +"{" +"    public List<CreatureLogic> CreaturesOnTable = new List<CreatureLogic>();" +"    private int maxCreatures = 8;" +"" +"    public void PlaceCreatureAt(int index, CreatureLogic creature)" +"    {" +"        if (canAddCreature())" +"        {" +"            CreaturesOnTable.Insert(index, creature);" +"        }" +"    }" +"" +"    public void AddCreature(CreatureLogic creature)" +"    {" +"        if (canAddCreature())" +"        {" +"            CreaturesOnTable.Add(creature);" +"        }" +"    }" +"    private bool canAddCreature() {" +"        return CreaturesOnTable.Count < maxCreatures;" +"    }" +"    public void RemoveCreatureAt(int index) {" +"        if (index >=0 && index < CreaturesOnTable.Count) {" +"            CreaturesOnTable.RemoveAt(index);" +"        }" +"    }" +"    public void RemoveAllFromList(List<CreatureLogic> creaturesToRemove)" +"    {" +"        foreach (var creature in creaturesToRemove)" +"        {" +"            CreaturesOnTable.Remove(creature);" +"        }" +"    }" +"}" +"        " 
  }
,
  {
    "fileName": "TargetType.cs",
    "relativeFilePath": "Assets/Scripts/Logic/TargetType.cs",
    "type": "script",
    "content": "public enum TargetType" +"{" +"    EnemyCreature," +"    PlayerCreature," +"    EnemyCard," +"    PlayerCard," +"    EnemyHero," +"    PlayerHero" +"}" +"" 
  }
,
  {
    "fileName": "TurnManager.cs",
    "relativeFilePath": "Assets/Scripts/Logic/TurnManager.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using UnityEngine.UI;" +"using DG.Tweening;" +"using System;" +"" +"// this class will take care of switching turns and counting down time until the turn expires" +"public class TurnManager : MonoBehaviour" +"{" +"" +"    private RopeTimer timer;" +"" +"    // for Singleton Pattern" +"    public static TurnManager Instance;" +"" +"    private Player _whoseTurn;" +"    public Player whoseTurn" +"    {" +"        get" +"        {" +"            return _whoseTurn;" +"        }" +"" +"        set" +"        {" +"            _whoseTurn = value;" +"            timer.StartTimer();" +"" +"            GlobalSettings.Instance.EnableEndTurnButtonOnStart(_whoseTurn);" +"" +"            TurnMaker tm = whoseTurn.GetComponent<TurnMaker>();" +"            // player\`s method OnTurnStart() will be called in tm.OnTurnStart();" +"            tm.OnTurnStart();" +"            // if (tm is PlayerTurnMaker)" +"            // {" +"            //     whoseTurn.HighlightPlayableObjects();" +"            // }" +"            // remove highlights for opponent." +"            // whoseTurn.otherPlayer.HighlightPlayableObjects(true);" +"" +"        }" +"    }" +"" +"    void Awake()" +"    {" +"        Instance = this;" +"        timer = GetComponent<RopeTimer>();" +"    }" +"" +"    void Start()" +"    {" +"        OnGameStart();" +"    }" +"" +"    public void OnGameStart()" +"    {" +"        Debug.Log(\"In TurnManager.OnGameStart()\");" +"" +"        CardLogic.CardsCreatedThisGame.Clear();" +"        CreatureLogic.CreaturesCreatedThisGame.Clear();" +"" +"        foreach (Player p in Player.Players)" +"        {" +"            p.ManaThisTurn = 0;" +"            p.ManaLeft = 0;" +"            p.LoadCharacterInfoFromAsset();" +"            p.TransmitInfoAboutPlayerToVisual();" +"            p.PArea.PDeck.CardsInDeck = p.deck.cards.Count;" +"            // move both portraits to the center" +"            p.PArea.Portrait.transform.position = p.PArea.handVisual.OtherCardDrawSourceTransform.position;" +"        }" +"" +"        Sequence s = DOTween.Sequence();" +"        s.Append(Player.Players[0].PArea.Portrait.transform.DOMove(Player.Players[0].PArea.PortraitPosition.position, 1f).SetEase(Ease.InQuad));" +"        s.Insert(0f, Player.Players[1].PArea.Portrait.transform.DOMove(Player.Players[1].PArea.PortraitPosition.position, 1f).SetEase(Ease.InQuad));" +"        s.PrependInterval(1f);" +"        s.OnComplete(() =>" +"            {" +"                // determine who starts the game." +"                int rnd = UnityEngine.Random.Range(0,2);  // 2 is exclusive boundary" +"                // Debug.Log(Player.Players.Length);" +"                Player whoGoesFirst = Player.Players[rnd];" +"                // Debug.Log(whoGoesFirst);" +"                Player whoGoesSecond = whoGoesFirst.otherPlayer;" +"                // Debug.Log(whoGoesSecond);" +"" +"                // draw 4 cards for first player and 5 for second player" +"                int initDraw = 4;" +"                for (int i = 0; i < initDraw; i++)" +"                {" +"                    // second player draws a card" +"                    whoGoesSecond.DrawACard(true);" +"                    // first player draws a card" +"                    whoGoesFirst.DrawACard(true);" +"                }" +"                // add one more card to second player\`s hand" +"                whoGoesSecond.DrawACard();" +"                //new GivePlayerACoinCommand(null, whoGoesSecond).AddToQueue();" +"                whoGoesSecond.DrawACoin();" +"                //TODO: Execute these 3 lines of code after a 0.3sec delay" +"                StartCoroutine(ExecuteAfterTime(0.3f, () =>" +"                {" +"                    whoGoesFirst.RegisterEvents();" +"                    whoGoesSecond.RegisterEvents();" +"                    new StartATurnCommand(whoGoesFirst).AddToQueue();" +"                }));" +"" +"" +"            });" +"    }" +"    private IEnumerator ExecuteAfterTime(float time, Action task)" +"    {" +"        yield return new WaitForSeconds(time);" +"        task();" +"    }" +"    void Update()" +"    {" +"        if (Input.GetKeyDown(KeyCode.Space))" +"            EndTurn();" +"    }" +"" +"    public void EndTurn()" +"    {" +"        // stop timer" +"        timer.StopTimer();" +"        // send all commands in the end of current player\`s turn" +"        whoseTurn.OnTurnEnd();" +"" +"        new StartATurnCommand(whoseTurn.otherPlayer).AddToQueue();" +"    }" +"" +"    public void EndTurnTest()" +"    {" +"        timer.StopTimer();" +"        timer.StartTimer();" +"    }" +"    public void StopTheTimer()" +"    {" +"        timer.StopTimer();" +"    }" +"" +"}" +"" 
  }
,
  {
    "fileName": "AITurnMaker.cs",
    "relativeFilePath": "Assets/Scripts/Logic/TurnsAndAI/AITurnMaker.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using CG.Cards;" +"//this class will take all decisions for AI. " +"" +"public class AITurnMaker: TurnMaker {" +"" +"    public override void OnTurnStart()" +"    {" +"        base.OnTurnStart();" +"        // dispay a message that it is enemy\`s turn" +"        new ShowMessageCommand(\"Enemy\`s Turn!\", 2.0f).AddToQueue();" +"        p.DrawACard();" +"        StartCoroutine(MakeAITurn());" +"    }" +"" +"    // THE LOGIC FOR AI" +"    IEnumerator MakeAITurn()" +"    {" +"        bool strategyAttackFirst = false;" +"        if (Random.Range(0, 2) == 0)" +"            strategyAttackFirst = true;" +"" +"        while (MakeOneAIMove(strategyAttackFirst))" +"        {" +"            yield return null;" +"        }" +"" +"        InsertDelay(1f);" +"" +"        TurnManager.Instance.EndTurn();" +"    }" +"" +"    bool MakeOneAIMove(bool attackFirst)" +"    {" +"        if (Command.CardDrawPending())" +"            return true;" +"        else if (attackFirst)" +"            return AttackWithACreature() || PlayACardFromHand() || UseHeroPower();" +"        else " +"            return PlayACardFromHand() || AttackWithACreature() || UseHeroPower();" +"    }" +"" +"    bool PlayACardFromHand()" +"    {" +"        foreach (CardLogic c in p.hand.CardsInHand)" +"        {" +"            if (c.CanBePlayed)" +"            {" +"                if (c.ca.MaxHealth == 0)" +"                {" +"                    // code to play a spell from hand" +"                    // TODO: depending on the targeting options, select a random target." +"                    if (c.ca.Targets == TargetingOptions.NoTarget)" +"                    {" +"                        p.PlayASpellFromHand(c, null);" +"                        InsertDelay(1.5f);" +"                        //Debug.Log(\"Card: \" + c.ca.name + \" can be played\");" +"                        return true;" +"                    }                        " +"                }" +"                else" +"                {" +"                    // it is a creature card" +"                    p.PlayACreatureFromHand(c, 0);" +"                    InsertDelay(1.5f);" +"                    return true;" +"                }" +"" +"            }" +"            //Debug.Log(\"Card: \" + c.ca.name + \" can NOT be played\");" +"        }" +"        return false;" +"    }" +"" +"    bool UseHeroPower()" +"    {" +"        if (p.ManaLeft >= 2 && !p.usedHeroPowerThisTurn)" +"        {" +"            // use HP" +"            p.UseHeroPower();" +"            InsertDelay(1.5f);" +"            //Debug.Log(\"AI used hero power\");" +"            return true;" +"        }" +"        return false;" +"    }" +"" +"    bool AttackWithACreature()" +"    {" +"        foreach (CreatureLogic cl in p.table.CreaturesOnTable)" +"        {" +"            if (cl.AttacksLeftThisTurn > 0)" +"            {" +"                // attack a random target with a creature" +"                if (p.otherPlayer.table.CreaturesOnTable.Count > 0)" +"                {" +"                    int index = Random.Range(0, p.otherPlayer.table.CreaturesOnTable.Count);" +"                    CreatureLogic targetCreature = p.otherPlayer.table.CreaturesOnTable[index];" +"                    cl.AttackCreature(targetCreature);" +"                }                    " +"                else" +"                    cl.GoFace();" +"                " +"                InsertDelay(1f);" +"                //Debug.Log(\"AI attacked with creature\");" +"                return true;" +"            }" +"        }" +"        return false;" +"    }" +"" +"    void InsertDelay(float delay)" +"    {" +"        new DelayCommand(delay).AddToQueue();" +"    }" +"" +"}" 
  }
,
  {
    "fileName": "PlayerTurnMaker.cs",
    "relativeFilePath": "Assets/Scripts/Logic/TurnsAndAI/PlayerTurnMaker.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class PlayerTurnMaker : TurnMaker " +"{" +"    public override void OnTurnStart()" +"    {" +"        base.OnTurnStart();" +"        // dispay a message that it is player\`s turn" +"        new ShowMessageCommand(\"Your Turn!\", 1.5f).AddToQueue();" +"        p.DrawACard();" +"    }" +"}" 
  }
,
  {
    "fileName": "TurnMaker.cs",
    "relativeFilePath": "Assets/Scripts/Logic/TurnsAndAI/TurnMaker.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public abstract class TurnMaker : MonoBehaviour {" +"" +"    protected Player p;" +"" +"    void Awake()" +"    {" +"        p = GetComponent<Player>();" +"    }" +"" +"    public virtual void OnTurnStart()" +"    {" +"        // add one mana crystal to the pool;" +"        p.OnTurnStart();" +"    }" +"" +"}" 
  }
,
  {
    "fileName": "CardAsset.cs",
    "relativeFilePath": "Assets/Scripts/SO Asset Scripts/CardAsset/CardAsset.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using System.Collections.Generic;" +"namespace CG.Cards" +"{" +"     public enum ECardType" +"        {" +"            Creature," +"            Spell," +"            FastSpell," +"            Equipment," +"            Artifact," +"            Hero" +"        }" +"        public enum TargetingOptions" +"        {" +"            NoTarget," +"            AllCreatures," +"            EnemyCreatures," +"            YourCreatures," +"            AllCharacters," +"            EnemyCharacters," +"            YourCharacters" +"        }" +"" +"    [CreateAssetMenu(fileName = \"New Card\", menuName = \"Card Game/Card\")]" +"    public class CardAsset : ScriptableObject" +"    {" +"" +"        // this object will hold the info about the most general card" +"        [Header(\"General info\")]" +"        public CharacterAsset characterAsset;  // if this is null, it\`s a neutral card" +"        [TextArea(2, 3)]" +"        public string Description;  // Description for spell or character" +"        public Sprite CardImage;" +"        " +"        public RectTransform CardImageRect;" +"        public int ManaCost;" +"" +"        public ECardType CardType;" +"" +"" +"        [Header(\"Creature Info\")]" +"        public int MaxHealth;" +"        public int Attack;" +"        public int AttacksForOneTurn = 1;" +"        public bool Taunt;" +"        public bool Charge;" +"        public string CreatureScriptName;" +"        public int specialCreatureAmount;" +"        public Sprite CreatureImage;" +"" +"        public CompositeEffect OnCreatureEnterEffect;" +"" +"        [Header(\"SpellInfo\")]" +"        public CompositeEffect SpellEffect;" +"        public bool Fast" +"        {" +"            get" +"            {" +"                return CardType == ECardType.FastSpell;" +"            }" +"        }" +"        public TargetingOptions Targets;" +"" +"    }" +"}" +"" 
  }
,
  {
    "fileName": "CardAssetEditor.cs",
    "relativeFilePath": "Assets/Scripts/SO Asset Scripts/CardAsset/Editor/CardAssetEditor.cs",
    "type": "script",
    "content": "using UnityEngine;" +"using UnityEditor;" +"using CG.Cards;" +"namespace CG.Cards" +"{" +"    [CustomEditor(typeof(CardAsset))]" +"    public class CardEditor : Editor" +"    {" +"        public override void OnInspectorGUI()" +"        {" +"            CardAsset card = (CardAsset)target;" +"" +"            // Draw default properties" +"            EditorGUILayout.PropertyField(serializedObject.FindProperty(\"characterAsset\"));" +"            EditorGUILayout.PropertyField(serializedObject.FindProperty(\"Description\"));" +"            EditorGUILayout.PropertyField(serializedObject.FindProperty(\"CardImage\"));" +"            EditorGUILayout.PropertyField(serializedObject.FindProperty(\"ManaCost\"));" +"            EditorGUILayout.PropertyField(serializedObject.FindProperty(\"CardType\"));" +"            EditorGUILayout.PropertyField(serializedObject.FindProperty(\"CardImageRect\"));" +"" +"" +"            // Draw properties specific to the Creature card type" +"            if (card.CardType == ECardType.Creature)" +"            {" +"                EditorGUILayout.PropertyField(serializedObject.FindProperty(\"MaxHealth\"));" +"                EditorGUILayout.PropertyField(serializedObject.FindProperty(\"Attack\"));" +"                EditorGUILayout.PropertyField(serializedObject.FindProperty(\"AttacksForOneTurn\"));" +"                EditorGUILayout.PropertyField(serializedObject.FindProperty(\"Taunt\"));" +"                EditorGUILayout.PropertyField(serializedObject.FindProperty(\"Charge\"));" +"                EditorGUILayout.PropertyField(serializedObject.FindProperty(\"CreatureImage\"));" +"                EditorGUILayout.PropertyField(serializedObject.FindProperty(\"OnCreatureEnterEffect\"));" +"                // EditorGUILayout.PropertyField(serializedObject.FindProperty(\"CreatureScriptName\"));" +"                // EditorGUILayout.PropertyField(serializedObject.FindProperty(\"specialCreatureAmount\"));" +"" +"            }" +"            if (card.CardType == ECardType.Spell || card.CardType == ECardType.FastSpell)" +"            {" +"                EditorGUILayout.PropertyField(serializedObject.FindProperty(\"SpellEffect\"));" +"                EditorGUILayout.PropertyField(serializedObject.FindProperty(\"Targets\"));" +"            }" +"" +"            // Apply any changes made in the Inspector" +"            serializedObject.ApplyModifiedProperties();" +"        }" +"    }" +"}" 
  }
,
  {
    "fileName": "CardUnityIntegration.cs",
    "relativeFilePath": "Assets/Scripts/SO Asset Scripts/CardAsset/Editor/CardUnityIntegration.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using UnityEditor;" +"using CG.Cards;" +"static class CardUnityIntegration " +"{" +"" +"	[MenuItem(\"Assets/Create/CardAsset\")]" +"	public static void CreateYourScriptableObject() {" +"		ScriptableObjectUtility2.CreateAsset<CardAsset>();" +"	}" +"" +"}" 
  }
,
  {
    "fileName": "CharacterAsset.cs",
    "relativeFilePath": "Assets/Scripts/SO Asset Scripts/CharacterAsset/CharacterAsset.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public enum CharClass{ Elf, Monk, Warrior, Mage}" +"" +"public class CharacterAsset : ScriptableObject " +"{" +"	public CharClass Class;" +"	public string ClassName;" +"	public int MaxHealth = 30;" +"	public string HeroPowerName;" +"	public Sprite AvatarImage;" +"    public Sprite HeroPowerIconImage;" +"    public Sprite AvatarBGImage;" +"    public Sprite HeroPowerBGImage;" +"    public Color32 AvatarBGTint;" +"    public Color32 HeroPowerBGTint;" +"    public Color32 ClassCardTint;" +"    public Color32 ClassRibbonsTint;" +"}" 
  }
,
  {
    "fileName": "CharacterUnityIntegration.cs",
    "relativeFilePath": "Assets/Scripts/SO Asset Scripts/CharacterAsset/Editor/CharacterUnityIntegration.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using UnityEditor;" +"" +"static class CharacterUnityIntegration {" +"" +"	[MenuItem(\"Assets/Create/CharacterAsset\")]" +"	public static void CreateYourScriptableObject() {" +"		ScriptableObjectUtility2.CreateAsset<CharacterAsset>();" +"	}" +"" +"}" 
  }
,
  {
    "fileName": "Condition.cs",
    "relativeFilePath": "Assets/Scripts/SO Asset Scripts/Conditions/Condition.cs",
    "type": "script",
    "content": "using System.Collections;" +"using System.Collections.Generic;" +"using UnityEngine;" +"" +"public abstract class Condition : ScriptableObject" +"{" +"   public abstract bool ConditionSatisfied(int specialAmount = 0, Queue<IIdentifiable> targets = null, TargetType targetType = TargetType.EnemyCreature);" +"}" 
  }
,
  {
    "fileName": "OnTargetDeadCondition.cs",
    "relativeFilePath": "Assets/Scripts/SO Asset Scripts/Conditions/ConditionImpls/OnTargetDeadCondition.cs",
    "type": "script",
    "content": "using System.Collections;" +"using System.Collections.Generic;" +"using UnityEngine;" +"[CreateAssetMenu(menuName = \"Conditions/OnTargetDead\")]" +"public class OnTargetDeadCondition : Condition" +"{" +"    public override bool ConditionSatisfied(int specialAmount = 0, Queue<IIdentifiable> targets = null, TargetType targetType = TargetType.EnemyCreature)" +"    {" +"        IIdentifiable obj;" +"        if (targets == null || !targets.TryPeek(out obj)) {" +"            return false;" +"        }" +"        if (obj is CreatureLogic creature) {" +"            return creature.Health <= 0;" +"        }" +"        return false;" +"" +"    }" +"}" 
  }
,
  {
    "fileName": "ScriptableObjectUtility2.cs",
    "relativeFilePath": "Assets/Scripts/SO Asset Scripts/Editor/ScriptableObjectUtility2.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using UnityEditor;" +"" +"public static class ScriptableObjectUtility2 {" +"	" +"	/// <summary>" +"	/// Create new asset from <see cref=\"ScriptableObject\"/> type with unique name at" +"	/// selected folder in project window. Asset creation can be cancelled by pressing" +"	/// escape key when asset is initially being named." +"	/// </summary>" +"	/// <typeparam name=\"T\">Type of scriptable object.</typeparam>" +"	public static void CreateAsset<T>() where T : ScriptableObject {" +"		var asset = ScriptableObject.CreateInstance<T>();" +"		ProjectWindowUtil.CreateAsset(asset, \"New \" + typeof(T).Name + \".asset\");" +"	}" +"	" +"}" 
  }
,
  {
    "fileName": "AtomicEffect.cs",
    "relativeFilePath": "Assets/Scripts/SO Asset Scripts/EffectAsset/AtomicEffect.cs",
    "type": "script",
    "content": "using System.Collections;" +"using System.Collections.Generic;" +"using CG.Cards;" +"using UnityEngine;" +"" +"public abstract class AtomicEffect : ScriptableObject" +"{" +"     public bool propagateTarget = false;" +"     public TargetingOptions targetingOptions = TargetingOptions.NoTarget;" +"     public bool canDestroyCreatures = false;" +"    public abstract void ActivateEffect(int specialAmount = 0, Queue<IIdentifiable> targets = null, TargetType targetType = TargetType.EnemyCreature);" +"    public abstract EffectTargetData TargetInfo();" +"}" 
  }
,
  {
    "fileName": "DamageAtomicEffect.cs",
    "relativeFilePath": "Assets/Scripts/SO Asset Scripts/EffectAsset/AtomicEffects/DamageAtomicEffect.cs",
    "type": "script",
    "content": "using System.Collections;" +"using System.Collections.Generic;" +"using System.Linq;" +"using UnityEngine;" +"" +"[CreateAssetMenu(menuName = \"Effects/DamageEffect\")]" +"public class DamageAtomicEffect : AtomicEffect" +"{" +"" +"    public override void ActivateEffect(int specialAmount = 0, Queue<IIdentifiable> targets = null, TargetType targetType = TargetType.EnemyCreature)" +"    {" +"        Debug.Log(\"Activating Deal Damage Effect\");" +"        IIdentifiable target;" +"        if (!targets.Any())" +"        {" +"            return;" +"        }" +"        if (propagateTarget)" +"            target = targets.Peek();" +"        else target = targets.Dequeue();" +"        if (target is ICharacter characterTarget)" +"        {" +"            new DealDamageCommand(characterTarget.ID, specialAmount, healthAfter: characterTarget.Health - specialAmount).AddToQueue();" +"        }" +"    }" +"" +"    public override EffectTargetData TargetInfo()" +"    {" +"        return new EffectTargetData(targetingOptions, \"Deal damage to a character. \");" +"    }" +"}" 
  }
,
  {
    "fileName": "DrawCardAtomicEffect.cs",
    "relativeFilePath": "Assets/Scripts/SO Asset Scripts/EffectAsset/AtomicEffects/DrawCardAtomicEffect.cs",
    "type": "script",
    "content": "using System.Collections;" +"using System.Collections.Generic;" +"using UnityEngine;" +"" +"[CreateAssetMenu(menuName = \"Effects/DrawCardEffect\")]" +"public class DrawCardAtomicEffect : AtomicEffect" +"{" +"    public override void ActivateEffect(int specialAmount = 0, Queue<IIdentifiable> targets = null, TargetType targetType = TargetType.PlayerCard)" +"    {" +"        // Assuming there is a method to handle drawing cards" +"        DrawCards(specialAmount);" +"    }" +"" +"    public override EffectTargetData TargetInfo()" +"    {" +"        return null;" +"    }" +"" +"    private void DrawCards(int amount)" +"    {" +"        Player p = TurnManager.Instance.whoseTurn;" +"        p.DrawCards(amount, true);" +"        //Debug.Log(\"Player \" + p.gameObject.name + \" should draw \" + specialAmount + \" cards.\");" +"    }" +"}" 
  }
,
  {
    "fileName": "DrawCardsWithConditions.cs",
    "relativeFilePath": "Assets/Scripts/SO Asset Scripts/EffectAsset/AtomicEffects/DrawCardsWithConditions.cs",
    "type": "script",
    "content": "using System.Collections;" +"using System.Collections.Generic;" +"using System.Linq;" +"using UnityEngine;" +"[CreateAssetMenu(menuName = \"Effects/DrawCardConditionedEffect\")]" +"public class DrawCardsWithConditions : AtomicEffect" +"{" +"" +"    [SerializeField] private List<Condition> conditions;" +"    public override void ActivateEffect(int specialAmount = 0, Queue<IIdentifiable> targets = null, TargetType targetType = TargetType.EnemyCreature)" +"    {" +"        CallbackCommand drawCardIfConditionCommand = new CallbackCommand(() =>" +"        {" +"            Debug.Log(\"Activating Draw Card with Condition Effect\");" +"            // Check that each condition returns true using All LINQ method" +"            if (!conditions.All(condition => condition.ConditionSatisfied(specialAmount, targets, targetType)))" +"            {" +"                Debug.Log(\"A condition was not satisfied. Effect will not be activated.\");" +"                return;" +"            }" +"            Player p = TurnManager.Instance.whoseTurn;" +"            p.DrawCards(specialAmount, true);" +"            //Debug.Log(\"Player \" + p.gameObject.name + \" should draw \" + specialAmount + \" cards.\");" +"        });" +"" +"        drawCardIfConditionCommand.AddToQueue();" +"" +"    }" +"" +"    public override EffectTargetData TargetInfo()" +"    {" +"        return null;" +"    }" +"}" 
  }
,
  {
    "fileName": "FreezeAtomicEffect.cs",
    "relativeFilePath": "Assets/Scripts/SO Asset Scripts/EffectAsset/AtomicEffects/FreezeAtomicEffect.cs",
    "type": "script",
    "content": "using System.Collections;" +"using System.Collections.Generic;" +"using UnityEngine;" +"" +"[CreateAssetMenu(menuName = \"Effects/FreezeEffect\")]" +"public class FreezeAtomicEffect : AtomicEffect" +"{" +"    public override void ActivateEffect(int specialAmount = 0, Queue<IIdentifiable> targets = null, TargetType targetType = TargetType.EnemyCreature)" +"    {" +"        // code to freeze target" +"    }" +"" +"    public override EffectTargetData TargetInfo()" +"    {" +"        throw new System.NotImplementedException();" +"    }" +"}" 
  }
,
  {
    "fileName": "SummonXTokensOfSameTypeEffect.cs",
    "relativeFilePath": "Assets/Scripts/SO Asset Scripts/EffectAsset/AtomicEffects/SummonXTokensOfSameTypeEffect.cs",
    "type": "script",
    "content": "using System.Collections;" +"using System.Collections.Generic;" +"using CG.Cards;" +"using UnityEngine;" +"[CreateAssetMenu(menuName = \"Effects/SummonXTokensOfSameType\")]" +"public class SummonXTokensOfSameTypeEffect : AtomicEffect" +"{" +"    public CardAsset creatureAsset;" +"    public override void ActivateEffect(int specialAmount = 0, Queue<IIdentifiable> targets = null, TargetType targetType = TargetType.EnemyCreature)" +"    {" +"        //Summon specialAmount number of creatureAssets on this player's board." +"        //possibly need to create a command for this as it requires visual and logical changes." +"        //call logic layer and it will handle the command to talk to visual itself" +"        Player p = TurnManager.Instance.whoseTurn;" +"        p.SummonCreatures(creatureAsset, specialAmount);" +"    }" +"" +"    public override EffectTargetData TargetInfo()" +"    {" +"        return null;" +"    }" +"}" 
  }
,
  {
    "fileName": "CompositeEffect.cs",
    "relativeFilePath": "Assets/Scripts/SO Asset Scripts/EffectAsset/CompositeEffect.cs",
    "type": "script",
    "content": "using System.Collections;" +"using System.Collections.Generic;" +"using UnityEngine;" +"" +"[CreateAssetMenu(menuName = \"Effects/CompositeEffect\")]" +"public class CompositeEffect : ScriptableObject" +"{" +"    [SerializeField] private List<AtomicEffect> atomicEffects;" +"    [SerializeField] private List<int> specialAmounts;" +"" +"    public void ActivateEffects(Queue<IIdentifiable> targets = null, TargetType targetType = TargetType.EnemyCreature)" +"    {" +"       if (atomicEffects.Count != specialAmounts.Count)" +"        {" +"            Debug.LogError(\"The number of atomic effects does not match the number of special amounts!\");" +"            return;" +"        }" +"" +"        for (int i = 0; i < atomicEffects.Count; i++)" +"        {" +"            if (i > 0 && atomicEffects[i-1].canDestroyCreatures && !atomicEffects[i].canDestroyCreatures) {" +"                new CallbackCommand(() => CreatureLogic.HandleQueueEmpty()).AddToQueue();" +"            }" +"            atomicEffects[i].ActivateEffect(specialAmounts[i], targets, targetType);" +"        }" +"    }" +"    //targetType, promptMessage" +"    public List<EffectTargetData> PollTargetsRequired() {" +"        List<EffectTargetData> targets = new List<EffectTargetData>();" +"        for (int i = 0; i < atomicEffects.Count; i++)" +"        {" +"            EffectTargetData targetData = atomicEffects[i].TargetInfo();" +"            if (targetData != null) {" +"                if (i>0 && atomicEffects[i-1].propagateTarget) continue;" +"                targets.Add(targetData);" +"            }" +"        } " +"        return targets;" +"    }" +"}" 
  }
,
  {
    "fileName": "EffectTargetData.cs",
    "relativeFilePath": "Assets/Scripts/SO Asset Scripts/EffectTargetData.cs",
    "type": "script",
    "content": "using System.Collections;" +"using System.Collections.Generic;" +"using CG.Cards;" +"using UnityEngine;" +"" +"public class EffectTargetData " +"{" +"   public TargetingOptions targetType;" +"   public string promptMessage;" +"" +"    public EffectTargetData(TargetingOptions targetType, string promptMessage)" +"    {" +"        this.targetType = targetType;" +"        this.promptMessage = promptMessage;" +"    }" +"}" 
  }
,
  {
    "fileName": "BoxOutline.cs",
    "relativeFilePath": "Assets/Scripts/UI/Outlines/BoxOutline.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using UnityEngine.UI;" +"using System.Collections.Generic;" +"" +"public class BoxOutline : ModifiedShadow" +"{" +"    const int maxHalfSampleCount = 20;" +"" +"    [SerializeField] [Range(1, maxHalfSampleCount)]" +"    int m_halfSampleCountX = 1;" +"    [SerializeField] [Range(1, maxHalfSampleCount)]" +"    int m_halfSampleCountY = 1;" +"" +"    public int halfSampleCountX" +"    {" +"        get" +"        {" +"            return m_halfSampleCountX;" +"        }" +"" +"        set" +"        {" +"            m_halfSampleCountX = Mathf.Clamp(value, 1, maxHalfSampleCount);" +"            if (graphic != null)" +"                graphic.SetVerticesDirty();" +"        }" +"    }" +"" +"    public int halfSampleCountY" +"    {" +"        get" +"        {" +"            return m_halfSampleCountY;" +"        }" +"" +"        set" +"        {" +"            m_halfSampleCountY = Mathf.Clamp(value, 1, maxHalfSampleCount);" +"            if (graphic != null)" +"                graphic.SetVerticesDirty();" +"        }" +"    }" +"" +"    public override void ModifyVertices(List<UIVertex> verts)" +"    {" +"        if (!IsActive())" +"            return;" +"" +"        var neededCapacity = verts.Count * (m_halfSampleCountX * 2 + 1) * (m_halfSampleCountY * 2 + 1);" +"        if (verts.Capacity < neededCapacity)" +"            verts.Capacity = neededCapacity;" +"" +"        var original = verts.Count;" +"        var count = 0;" +"        var dx = effectDistance.x / m_halfSampleCountX;" +"        var dy = effectDistance.y / m_halfSampleCountY;" +"        for (int x = -m_halfSampleCountX; x <= m_halfSampleCountX; x++)" +"        {" +"            for (int y = -m_halfSampleCountY; y <= m_halfSampleCountY; y++)" +"            {" +"                if (!(x == 0 && y == 0))" +"                {" +"                    var next = count + original;" +"                    ApplyShadow(verts, effectColor, count, next, dx * x, dy * y);" +"                    count = next;" +"                }" +"            }" +"        }" +"    }" +"}" 
  }
,
  {
    "fileName": "CircleOutline.cs",
    "relativeFilePath": "Assets/Scripts/UI/Outlines/CircleOutline.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using UnityEngine.UI;" +"using System.Collections.Generic;" +"" +"public class CircleOutline : ModifiedShadow" +"{" +"    [SerializeField]" +"    int m_circleCount = 2;" +"    [SerializeField]" +"    int m_firstSample = 4;" +"    [SerializeField]" +"    int m_sampleIncrement = 2;" +"" +"#if UNITY_EDITOR" +"    protected override void OnValidate()" +"    {" +"        base.OnValidate();" +"        circleCount = m_circleCount;" +"        firstSample = m_firstSample;" +"        sampleIncrement = m_sampleIncrement;" +"    }" +"#endif" +"" +"    public int circleCount" +"    {" +"        get" +"        {" +"            return m_circleCount;" +"        }" +"" +"        set" +"        {" +"            m_circleCount = Mathf.Max(value, 1);" +"            if (graphic != null)" +"                graphic.SetVerticesDirty();" +"        }" +"    }" +"" +"    public int firstSample" +"    {" +"        get" +"        {" +"            return m_firstSample;" +"        }" +"" +"        set" +"        {" +"            m_firstSample = Mathf.Max(value, 2);" +"            if (graphic != null)" +"                graphic.SetVerticesDirty();" +"        }" +"    }" +"" +"    public int sampleIncrement" +"    {" +"        get" +"        {" +"            return m_sampleIncrement;" +"        }" +"" +"        set" +"        {" +"            m_sampleIncrement = Mathf.Max(value, 1);" +"            if (graphic != null)" +"                graphic.SetVerticesDirty();" +"        }" +"    }" +"" +"    public override void ModifyVertices(List<UIVertex> verts)" +"    {" +"        if (!IsActive())" +"            return;" +"" +"        var total = (m_firstSample * 2 + m_sampleIncrement * (m_circleCount - 1)) * m_circleCount / 2;" +"        var neededCapacity = verts.Count * (total + 1);" +"        if (verts.Capacity < neededCapacity)" +"            verts.Capacity = neededCapacity;" +"        var original = verts.Count;" +"        var count = 0;" +"        var sampleCount = m_firstSample;" +"        var dx = effectDistance.x / circleCount;" +"        var dy = effectDistance.y / circleCount;" +"        for (int i = 1; i <= m_circleCount; i++)" +"        {" +"            var rx = dx * i;" +"            var ry = dy * i;" +"            var radStep = 2 * Mathf.PI / sampleCount;" +"            var rad = (i % 2) * radStep * 0.5f;" +"            for (int j = 0; j < sampleCount; j++)" +"            {" +"                var next = count + original;" +"                ApplyShadow(verts, effectColor, count, next, rx * Mathf.Cos(rad), ry * Mathf.Sin(rad));" +"                count = next;" +"                rad += radStep;" +"            }" +"            sampleCount += m_sampleIncrement;" +"        }" +"    }" +"}" 
  }
,
  {
    "fileName": "ListPool.cs",
    "relativeFilePath": "Assets/Scripts/UI/Outlines/ListPool.cs",
    "type": "script",
    "content": "﻿using System;" +"using System.Collections.Generic;" +"using UnityEngine;" +"" +"static class ListPool<T>" +"{" +"    // Object pool to avoid allocations." +"    private static readonly ObjectPool<List<T>> s_ListPool = new ObjectPool<List<T>>(null, l => l.Clear());" +"" +"    public static List<T> Get()" +"    {" +"        return s_ListPool.Get();" +"    }" +"" +"    public static void Release(List<T> toRelease)" +"    {" +"        s_ListPool.Release(toRelease);" +"    }" +"}" 
  }
,
  {
    "fileName": "ModifiedShadow.cs",
    "relativeFilePath": "Assets/Scripts/UI/Outlines/ModifiedShadow.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using UnityEngine.UI;" +"using System.Collections.Generic;" +"" +"/// <summary>" +"/// The behaviour of this class is almost the same as the original except:" +"/// 1. It absorbs version differences." +"/// 2. It corrects the calculation of vertex list capacity (Unity 5.3 or older)." +"/// </summary>" +"public class ModifiedShadow : Shadow" +"{" +"#if !UNITY_5_4_OR_NEWER" +"    protected new void ApplyShadow(List<UIVertex> verts, Color32 color, int start, int end, float x, float y)" +"    {" +"        UIVertex vt;" +"" +"        // The capacity calculation of the original version seems wrong." +"        var neededCpacity = verts.Count + (end - start);" +"        if (verts.Capacity < neededCpacity)" +"            verts.Capacity = neededCpacity;" +"" +"        for (int i = start; i < end; ++i)" +"        {" +"            vt = verts[i];" +"            verts.Add(vt);" +"" +"            Vector3 v = vt.position;" +"            v.x += x;" +"            v.y += y;" +"            vt.position = v;" +"            var newColor = color;" +"            if (useGraphicAlpha)" +"                newColor.a = (byte)((newColor.a * verts[i].color.a) / 255);" +"            vt.color = newColor;" +"            verts[i] = vt;" +"        }" +"    }" +"#endif" +"" +"#if UNITY_5_2 && !UNITY_5_2_1pX" +"    public override void ModifyMesh(Mesh mesh)" +"    {" +"        if (!this.IsActive())" +"            return;" +"" +"        using (var vh = new VertexHelper(mesh))" +"        {" +"            ModifyMesh(vh);" +"            vh.FillMesh(mesh);" +"        }" +"    }" +"#endif" +"" +"#if !(UNITY_4_6 || UNITY_4_7 || UNITY_5_0 || UNITY_5_1)" +"#if UNITY_5_2_1pX || UNITY_5_3_OR_NEWER" +"    public override void ModifyMesh(VertexHelper vh)" +"#else" +"    public void ModifyMesh(VertexHelper vh)" +"#endif" +"    {" +"        if (!this.IsActive())" +"            return;" +"" +"        var list = ListPool<UIVertex>.Get();" +"        vh.GetUIVertexStream(list);" +"" +"        ModifyVertices(list);" +"" +"#if UNITY_5_2_1pX || UNITY_5_3_OR_NEWER" +"        vh.Clear();" +"#endif" +"        vh.AddUIVertexTriangleStream(list);" +"        ListPool<UIVertex>.Release(list);" +"    }" +"" +"    public virtual void ModifyVertices(List<UIVertex> verts)" +"    {" +"    }" +"#endif" +"}" 
  }
,
  {
    "fileName": "ObjectPool.cs",
    "relativeFilePath": "Assets/Scripts/UI/Outlines/ObjectPool.cs",
    "type": "script",
    "content": "﻿using System.Collections.Generic;" +"using UnityEngine;" +"using UnityEngine.Events;" +"" +"public class ObjectPool<T> where T : new()" +"{" +"    private readonly Stack<T> m_Stack = new Stack<T>();" +"    private readonly UnityAction<T> m_ActionOnGet;" +"    private readonly UnityAction<T> m_ActionOnRelease;" +"" +"    public int countAll { get; private set; }" +"    public int countActive { get { return countAll - countInactive; } }" +"    public int countInactive { get { return m_Stack.Count; } }" +"" +"    public ObjectPool(UnityAction<T> actionOnGet, UnityAction<T> actionOnRelease)" +"    {" +"        m_ActionOnGet = actionOnGet;" +"        m_ActionOnRelease = actionOnRelease;" +"    }" +"" +"    public T Get()" +"    {" +"        T element;" +"        if (m_Stack.Count == 0)" +"        {" +"            element = new T();" +"            countAll++;" +"        }" +"        else" +"        {" +"            element = m_Stack.Pop();" +"        }" +"        if (m_ActionOnGet != null)" +"            m_ActionOnGet(element);" +"        return element;" +"    }" +"" +"    public void Release(T element)" +"    {" +"        if (m_Stack.Count > 0 && ReferenceEquals(m_Stack.Peek(), element))" +"            Debug.LogError(\"Internal error. Trying to destroy object that is already released to pool.\");" +"        if (m_ActionOnRelease != null)" +"            m_ActionOnRelease(element);" +"        m_Stack.Push(element);" +"    }" +"}" 
  }
,
  {
    "fileName": "Outline8.cs",
    "relativeFilePath": "Assets/Scripts/UI/Outlines/Outline8.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using UnityEngine.UI;" +"using System.Collections.Generic;" +"" +"public class Outline8 : ModifiedShadow" +"{" +"    public override void ModifyVertices(List<UIVertex> verts)" +"    {" +"        if (!IsActive())" +"            return;" +"" +"        var neededCapacity = verts.Count * 9;" +"        if (verts.Capacity < neededCapacity)" +"            verts.Capacity = neededCapacity;" +"" +"        var original = verts.Count;" +"        var count = 0;" +"        for (int x = -1; x <= 1; x++)" +"        {" +"            for (int y = -1; y <= 1; y++)" +"            {" +"                if (!(x == 0 && y == 0))" +"                {" +"                    var next = count + original;" +"                    ApplyShadow(verts, effectColor, count, next, effectDistance.x * x, effectDistance.y * y);" +"                    count = next;" +"                }" +"            }" +"        }" +"    }" +"}" 
  }
,
  {
    "fileName": "ViewportDimensions.cs",
    "relativeFilePath": "Assets/Scripts/ViewportDimensions.cs",
    "type": "script",
    "content": "using UnityEngine;" +"" +"public class ViewportDimensions : MonoBehaviour" +"{ public Camera mainCamera;" +"    public float distanceFromCamera = 5.0f;" +"    public float canvasScale = 0.005f;" +"" +"    void Start()" +"    {" +"        // Calculate the viewport's height and width in world units at the given distance from the camera" +"        float viewportHeight = 2.0f * distanceFromCamera * Mathf.Tan(mainCamera.fieldOfView * 0.5f * Mathf.Deg2Rad);" +"        float viewportWidth = viewportHeight * mainCamera.aspect;" +"" +"        // Calculate the required width and height for the canvas in world units" +"        float canvasWidth = viewportWidth / canvasScale;" +"        float canvasHeight = viewportHeight / canvasScale;" +"" +"        // Set the canvas width and height" +"       Debug.Log(\$\"width: {canvasWidth}, height: {canvasHeight}\");" +"    }" +"    " +"}" 
  }
,
  {
    "fileName": "BetterCardRotation.cs",
    "relativeFilePath": "Assets/Scripts/Visual/BetterCardRotation.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"/// <summary>" +"/// This script should be attached to the card game object to display card\`s rotation correctly." +"/// </summary>" +"" +"[ExecuteInEditMode]" +"public class BetterCardRotation : MonoBehaviour {" +"" +"    // parent game object for all the card face graphics" +"    public RectTransform CardFront;" +"" +"    // parent game object for all the card back graphics" +"    public RectTransform CardBack;" +"" +"    // an empty game object that is placed a bit above the face of the card, in the center of the card" +"    public Transform targetFacePoint;" +"" +"    public LayerMask cardLayer;" +"" +"    // 3d collider attached to the card (2d colliders like BoxCollider2D won\`t work in this case)" +"    [SerializeField]" +"    private Collider col;" +"    private Transform mainCameraTransform;" +"" +"    // if this is true, our players currently see the card Back" +"    private bool showingBack = false;" +"" +"    void Start() {" +"        mainCameraTransform = Camera.main.transform;" +"    }" +"" +"	// Update is called once per frame" +"	void Update () " +"    {" +"        // Raycast from Camera to a target point on the face of the card" +"        // If it passes through the card\`s collider, we should show the back of the card" +"        RaycastHit[] hits;" +"        hits = Physics.RaycastAll(origin: mainCameraTransform.position, " +"                                  direction: (-mainCameraTransform.position + targetFacePoint.position).normalized, " +"            maxDistance: (-mainCameraTransform.position + targetFacePoint.position).magnitude) ;" +"        bool passedThroughColliderOnCard = false;" +"        foreach (RaycastHit h in hits)" +"        {" +"            if (h.collider == col)" +"                passedThroughColliderOnCard = true;" +"        }" +"        //Debug.Log(\"TotalHits: \" + hits.Length); " +"        if (passedThroughColliderOnCard!= showingBack)" +"        {" +"            // something changed" +"            showingBack = passedThroughColliderOnCard;" +"            CardFront.gameObject.SetActive(!showingBack);" +"            CardBack.gameObject.SetActive(showingBack);" +"        }" +"" +"	}" +"}" 
  }
,
  {
    "fileName": "CreatureAttackVisual.cs",
    "relativeFilePath": "Assets/Scripts/Visual/CreatureAttackVisual.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using DG.Tweening;" +"" +"public class CreatureAttackVisual : MonoBehaviour" +"{" +"    private OneCreatureManager manager;" +"    private WhereIsTheCardOrCreature w;" +"" +"    void Awake()" +"    {" +"        manager = GetComponent<OneCreatureManager>();" +"        w = GetComponent<WhereIsTheCardOrCreature>();" +"    }" +"" +"    public void AttackTarget(int targetUniqueID, int damageTakenByTarget, int damageTakenByAttacker, int attackerHealthAfter, int targetHealthAfter)" +"    {" +"        manager.CanAttackNow = false;" +"        GameObject target = IDHolder.GetGameObjectWithID(targetUniqueID);" +"" +"        // bring this creature to front sorting-wise." +"        w.BringToFront();" +"        VisualStates tempState = w.VisualState;" +"        w.VisualState = VisualStates.Transition;" +"        //TODO : Make all of this a sequence, when creature reaches target, create the damage effect, then transition back to og position" +"        //Sequence s = DOTween.Sequence();" +"        Sequence s = DOTween.Sequence();" +"        s.Append(transform.DOMove(new Vector3(transform.position.x, transform.position.y, transform.position.z - 2), 0.2f).SetEase(Ease.Linear));" +"        // Step 1: Move object to target with ease" +"        s.Append(transform.DOMove(target.transform.position, 0.4f).SetEase(Ease.InExpo));" +"        " +"" +"        // Step 2: Create an impact effect" +"        s.Append(transform.DOShakePosition(0.1f,1,50));" +"" +"        // Step 3: Show the damage effect and update health values" +"        s.AppendCallback(() =>" +"        {" +"            if (damageTakenByTarget > 0)" +"                DamageEffect.CreateDamageEffect(target, damageTakenByTarget);" +"            " +"            if (damageTakenByAttacker > 0) {" +"                manager.HealthText.text = attackerHealthAfter.ToString();" +"                 DamageEffect.CreateDamageEffect(this.gameObject, damageTakenByAttacker);" +"            }" +"            " +"            if (targetUniqueID == GlobalSettings.Instance.LowPlayer.PlayerID || targetUniqueID == GlobalSettings.Instance.TopPlayer.PlayerID)" +"            {" +"                // target is a player" +"                target.GetComponent<PlayerPortraitVisual>().HealthText.text = targetHealthAfter.ToString();" +"            }" +"            else" +"                target.GetComponent<OneCreatureManager>().HealthText.text = targetHealthAfter.ToString();" +"" +"        });" +"        s.AppendInterval(0.1f);" +"" +"        // Step 4: Move object back to its original position" +"        s.Append(transform.DOMove(transform.position, 0.5f).SetEase(Ease.OutQuart));" +"" +"        // Step 5: Perform rest of the code" +"        s.AppendCallback(() =>" +"        {" +"            w.SetTableSortingOrder();" +"            w.VisualState = tempState;" +"" +"            " +"        });" +"" +"        s.AppendInterval(0.3f);" +"        s.OnComplete(Command.CommandExecutionComplete);" +"" +"        s.Play();" +"" +"" +"        // transform.DOMove(target.transform.position, 0.5f).SetLoops(2, LoopType.Yoyo).SetEase(Ease.InCubic).OnComplete(() =>" +"        //     {" +"        //         if(damageTakenByTarget>0)" +"        //             DamageEffect.CreateDamageEffect(target, damageTakenByTarget);" +"        //         if(damageTakenByAttacker>0)" +"        //             DamageEffect.CreateDamageEffect(this.gameObject, damageTakenByAttacker);" +"" +"        //         if (targetUniqueID == GlobalSettings.Instance.LowPlayer.PlayerID || targetUniqueID == GlobalSettings.Instance.TopPlayer.PlayerID)" +"        //         {" +"        //             // target is a player" +"        //             target.GetComponent<PlayerPortraitVisual>().HealthText.text = targetHealthAfter.ToString();" +"        //         }" +"        //         else" +"        //             target.GetComponent<OneCreatureManager>().HealthText.text = targetHealthAfter.ToString();" +"" +"        //         w.SetTableSortingOrder();" +"        //         w.VisualState = tempState;" +"" +"        //         manager.HealthText.text = attackerHealthAfter.ToString();" +"        //         Sequence s = DOTween.Sequence();" +"        //         s.AppendInterval(1f);" +"        //         s.OnComplete(Command.CommandExecutionComplete);" +"        //         //Command.CommandExecutionComplete();" +"        //     });" +"    }" +"" +"}" 
  }
,
  {
    "fileName": "DamageEffect.cs",
    "relativeFilePath": "Assets/Scripts/Visual/DamageEffect.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using System.Collections.Generic;" +"using UnityEngine.UI;" +"using DG.Tweening;" +"" +"/// <summary>" +"/// This class will show damage dealt to creatures or payers" +"/// </summary>" +"" +"public class DamageEffect : MonoBehaviour" +"{" +"" +"    // an array of sprites with different blood splash graphics" +"    public Sprite[] Splashes;" +"" +"    // a UI image to show the blood splashes" +"    public Image DamageImage;" +"" +"    // CanvasGropup should be attached to the Canvas of this damage effect" +"    // It is used to fade away the alpha value of this effect" +"" +"    [SerializeField] private CanvasGroup canvasGroup;" +"    [SerializeField] private Text damageText;" +"" +"    [SerializeField] private float displayDuration = 0.7f; // how long to display before starting fade" +"    [SerializeField] private float fadeDuration = 0.3f; // how long to fade" +"" +"" +"    private void Start()" +"    {" +"        // DamageImage.sprite = Splashes[Random.Range(0, Splashes.Length)];  " +"        // Start the sequence immediately when the DamageEffect is instantiated" +"        StartEffectSequence();" +"    }" +"" +"    public void SetDamage(int damage)" +"    {" +"        damageText.text = damage.ToString();" +"    }" +"" +"    private void StartEffectSequence()" +"    {" +"        // Display for a duration then start the fade sequence" +"        DOVirtual.DelayedCall(displayDuration, () =>" +"        {" +"            FadeAndDestroy();" +"        });" +"    }" +"" +"    private void FadeAndDestroy()" +"    {" +"        // Fade out and then destroy the game object" +"        canvasGroup.DOFade(0, fadeDuration).OnComplete(() => Destroy(gameObject));" +"    }" +"" +"" +"    public static void CreateDamageEffect(GameObject parent, int amount)" +"    {" +"        // // Instantiate a DamageEffect from prefab" +"        GameObject newDamageEffect = GameObject.Instantiate(GlobalSettings.Instance.DamageEffectPrefab, parent.transform.position, Quaternion.identity, parent.transform) as GameObject;" +"        newDamageEffect.transform.localPosition = new Vector3(0, 0, -0.1f);" +"        // // Get DamageEffect component in this new game object" +"        DamageEffect de = newDamageEffect.GetComponent<DamageEffect>();" +"        // // Change the amount text to reflect the amount of damage dealt" +"        de.SetDamage(-amount);" +"" +"" +"    }" +"}" 
  }
,
  {
    "fileName": "DamageEffectTest.cs",
    "relativeFilePath": "Assets/Scripts/Visual/DamageEffectTest.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class DamageEffectTest : MonoBehaviour {" +"" +"    public static DamageEffectTest Instance;" +"" +"    void Awake()" +"    {" +"        Instance = this;" +"    }" +"" +"    void Update()" +"    {" +"        if (Input.GetKeyDown(KeyCode.B))" +"            DamageEffect.CreateDamageEffect(this.gameObject, Random.Range(1, 100));" +"    }" +"}" 
  }
,
  {
    "fileName": "EndTurnButton.cs",
    "relativeFilePath": "Assets/Scripts/Visual/EndTurnButton.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class EndTurnButton : MonoBehaviour {" +"" +"    public void OnClick()" +"    {" +"            TurnManager.Instance.EndTurn();" +"    }" +"" +"}" 
  }
,
  {
    "fileName": "GlobalSettings.cs",
    "relativeFilePath": "Assets/Scripts/Visual/GlobalSettings.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using System.Collections.Generic;" +"using UnityEngine.UI;" +"using CG.Cards;" +"" +"public class GlobalSettings: MonoBehaviour " +"{" +"    [Header(\"Players\")]" +"    public Player TopPlayer;" +"    public Player LowPlayer;" +"    [Header(\"Colors\")]" +"    public Color32 CardBodyStandardColor;" +"    public Color32 CardRibbonsStandardColor;" +"    public Color32 CardGlowColor;" +"    [Header(\"Numbers and Values\")]" +"    public float CardPreviewTime = 1f;" +"    public float CardTransitionTime= 1f;" +"    public float CardPreviewTimeFast = 0.2f;" +"    public float CardTransitionTimeFast = 0.5f;" +"    [Header(\"Prefabs and Assets\")]" +"    public GameObject NoTargetSpellCardPrefab;" +"    public GameObject TargetedSpellCardPrefab;" +"    public GameObject CreatureCardPrefab;" +"    public GameObject CreaturePrefab;" +"    public GameObject DamageEffectPrefab;" +"    public GameObject ExplosionPrefab;" +"    [Header(\"Other\")]" +"    public Button EndTurnButton;" +"    public CardAsset CoinCard;" +"    public GameObject GameOverCanvas;" +"    //public Sprite HeroPowerCrossMark;" +"" +"    public Dictionary<AreaPosition, Player> Players = new Dictionary<AreaPosition, Player>();" +"" +"" +"    // SINGLETON" +"    public static GlobalSettings Instance;" +"" +"    void Awake()" +"    {" +"        Players.Add(AreaPosition.Top, TopPlayer);" +"        Players.Add(AreaPosition.Low, LowPlayer);" +"        Instance = this;" +"    }" +"" +"    public bool CanControlThisPlayer(AreaPosition owner)" +"    {" +"        bool PlayersTurn = (TurnManager.Instance.whoseTurn == Players[owner]);" +"        bool NotDrawingAnyCards = !Command.CardDrawPending();" +"        return Players[owner].PArea.AllowedToControlThisPlayer && Players[owner].PArea.ControlsON && PlayersTurn && NotDrawingAnyCards;" +"    }" +"" +"    public bool CanControlThisPlayer(Player ownerPlayer)" +"    {" +"        bool PlayersTurn = (TurnManager.Instance.whoseTurn == ownerPlayer);" +"        bool NotDrawingAnyCards = !Command.CardDrawPending();" +"        return ownerPlayer.PArea.AllowedToControlThisPlayer && ownerPlayer.PArea.ControlsON && PlayersTurn && NotDrawingAnyCards;" +"    }" +"" +"    public void EnableEndTurnButtonOnStart(Player P)" +"    {" +"        if (P == LowPlayer && CanControlThisPlayer(AreaPosition.Low) ||" +"            P == TopPlayer && CanControlThisPlayer(AreaPosition.Top))" +"            EndTurnButton.interactable = true;" +"        else" +"            EndTurnButton.interactable = false;" +"            " +"    }" +"}" 
  }
,
  {
    "fileName": "GlowBlink.cs",
    "relativeFilePath": "Assets/Scripts/Visual/GlowBlink.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"[ExecuteInEditMode]" +"public class GlowBlink : MonoBehaviour " +"{	" +"    [Range(0,30f)]" +"    public float Padding = 0f;" +"" +"    void Update()" +"    {" +"        RectTransform r = transform as RectTransform;" +"        r.offsetMax = new Vector2(-Padding, -Padding);" +"        r.offsetMin = new Vector2(Padding, Padding);" +"    }" +"}" 
  }
,
  {
    "fileName": "HandVisual.cs",
    "relativeFilePath": "Assets/Scripts/Visual/HandVisual.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using System.Collections.Generic;" +"using DG.Tweening;" +"using CG.Cards;" +"using System;" +"public class HandVisual : MonoBehaviour" +"{" +"    // PUBLIC FIELDS" +"    public AreaPosition owner;" +"    public bool TakeCardsOpenly = true;" +"    public PositionManager slots;" +"    [SerializeField]" +"    public CardAsset testCardAsset;" +"" +"    [Header(\"Transform References\")]" +"    public Transform DrawPreviewSpot;" +"    public Transform DeckTransform;" +"    public Transform OtherCardDrawSourceTransform;" +"    public Transform PlayPreviewSpot;" +"    public event Action OnHandChange;" +"    private int UniqueID;" +"" +"    // PRIVATE : a list of all card visual representations as GameObjects" +"    private List<GameObject> CardsInHand = new List<GameObject>();" +"    // Define the list to track the slots" +"    List<GameObject> slotTracker = new List<GameObject>();" +"    private readonly int MAX_CARDS_IN_HAND = 9;" +"    // public event Action CommandComplete = delegate {};" +"" +"    // ADDING OR REMOVING CARDS FROM HAND" +"    void Start()" +"    {" +"        // Initialize the slot tracker with nulls" +"        for (int i = 0; i < 9; i++)" +"        {" +"            slotTracker.Add(null);" +"        }" +"        UniqueID = 0;" +"        //CommandComplete += Command.CommandExecutionFlagUpdate;" +"    }" +"    private void NullifySlots()" +"    {" +"        for (int i = 0; i < 9; i++)" +"        {" +"            slotTracker[i] = null;" +"        }" +"    }" +"    // add a new card GameObject to hand" +"    public int AddCard(GameObject card)" +"    {" +"        CardsInHand.Add(card);" +"" +"        // parent this card to our Slots GameObject" +"        card.transform.SetParent(slots.transform);" +"" +"        // re-calculate the position of the hand" +"        PlaceCardsOnNewSlotsVirtual();" +"        return slotTracker.IndexOf(card);" +"    }" +"" +"    // remove a card GameObject from hand" +"    public void RemoveCard(GameObject card)" +"    {" +"        // remove a card from the list" +"        CardsInHand.Remove(card);" +"" +"" +"        // re-calculate the position of the hand" +"        PlaceCardsOnNewSlotsVirtual();" +"        PlaceCardsOnNewSlotsAnimate(0.5f);" +"        OnHandChange?.Invoke();" +"    }" +"" +"    // remove card with a given index from hand" +"    public void RemoveCardAtIndex(int index)" +"    {" +"        CardsInHand.RemoveAt(index);" +"        // re-calculate the position of the hand" +"        PlaceCardsOnNewSlotsVirtual();" +"    }" +"" +"    // get a card GameObject with a given index in hand" +"    public GameObject GetCardAtIndex(int index)" +"    {" +"        return CardsInHand[index];" +"    }" +"" +"    // MANAGING CARDS AND SLOTS" +"" +"    void PlaceCardsOnNewSlotsVirtual()" +"    {" +"        int middleIndex = 4;" +"        int totalCards = CardsInHand.Count;" +"        int startIndex, endIndex;" +"        bool isEven = totalCards % 2 == 0;" +"" +"        NullifySlots();" +"        if (isEven)" +"        {" +"            startIndex = middleIndex - totalCards / 2;" +"            endIndex = middleIndex + totalCards / 2;" +"        }" +"        else" +"        {" +"            startIndex = middleIndex - totalCards / 2;" +"            endIndex = middleIndex + totalCards / 2 + 1;" +"        }" +"" +"        for (int i = 0; i < totalCards; i++)" +"        {" +"            int targetSlotIndex = startIndex + i;" +"            if (targetSlotIndex == middleIndex && isEven)" +"            {" +"                startIndex++;" +"                targetSlotIndex++;" +"            }" +"            GameObject g = CardsInHand[i];" +"" +"            // Update the slot tracker" +"            slotTracker[targetSlotIndex] = g;" +"" +"            WhereIsTheCardOrCreature w = g.GetComponent<WhereIsTheCardOrCreature>();" +"            w.Slot = targetSlotIndex;" +"            w.SetHandSortingOrder();" +"        }" +"    }" +"" +"    private void PlaceCardsOnNewSlotsAnimate(float duration)" +"    {" +"        // Iterate over the slotTracker list and move the cards in parallel" +"        for (int i = 0; i < slotTracker.Count; i++)" +"        {" +"            GameObject g = slotTracker[i];" +"            if (g != null) // Check that the slot isn't empty" +"            {" +"                if (owner == AreaPosition.Top)" +"                {" +"                    // Use DOMove to move the card to the position of its new slot" +"                    // Quaternion slotRotation = slots.Children[i].transform.rotation;" +"                    // Quaternion newCardRotation = Quaternion.Euler(slotRotation.eulerAngles.x, slotRotation.eulerAngles.y + 180f, slotRotation.eulerAngles.z);" +"                    g.transform.DOMove(slots.Children[i].transform.position, duration);" +"                    g.transform.DORotate(slots.Children[i].transform.rotation.eulerAngles, 0.1f);" +"                }" +"                else" +"                {" +"                    // Sequence seq = DOTween.Sequence();" +"                    // seq.Append(g.transform.DOMove(slots.Children[i].transform.position, duration));" +"                    // seq.Insert(0f, g.transform.DORotate(slots.Children[i].transform.rotation.eulerAngles, 0.1f));" +"                    // seq.OnComplete(() => {" +"                    //     CommandComplete();" +"                    //     Command.CommandExecutionComplete();" +"                    // });" +"                    // Use DOMove to move the card to the position of its new slot" +"                    g.transform.DOMove(slots.Children[i].transform.position, duration);" +"                    g.transform.DORotate(slots.Children[i].transform.rotation.eulerAngles, 0.1f);" +"                    // Command.CommandExecutionComplete();" +"                }" +"" +"            }" +"        }" +"        //CommandComplete();" +"        Command.CommandExecutionComplete();" +"    }" +"" +"    // CARD DRAW METHODS" +"" +"    // creates a card and returns a new card as a GameObject" +"    GameObject CreateACardAtPosition(CardAsset c, Vector3 position, Vector3 eulerAngles)" +"    {" +"        // Instantiate a card depending on its type" +"        GameObject card;" +"        if (c.MaxHealth > 0)" +"        {" +"            // this card is a creature card" +"            card = GameObject.Instantiate(GlobalSettings.Instance.CreatureCardPrefab, position, Quaternion.Euler(eulerAngles)) as GameObject;" +"        }" +"        else" +"        {" +"            // this is a spell: checking for targeted or non-targeted spell" +"            if (c.Targets == TargetingOptions.NoTarget)" +"                card = GameObject.Instantiate(GlobalSettings.Instance.NoTargetSpellCardPrefab, position, Quaternion.Euler(eulerAngles)) as GameObject;" +"            else" +"            {" +"                card = GameObject.Instantiate(GlobalSettings.Instance.TargetedSpellCardPrefab, position, Quaternion.Euler(eulerAngles)) as GameObject;" +"                // pass targeting options to DraggingActions" +"                DragSpellOnTarget dragSpell = card.GetComponentInChildren<DragSpellOnTarget>();" +"                dragSpell.Targets = c.Targets;" +"            }" +"" +"        }" +"" +"        // apply the look of the card based on the info from CardAsset" +"        OneCardManager manager = card.GetComponent<OneCardManager>();" +"        manager.cardAsset = c;" +"        manager.ReadCardFromAsset();" +"" +"        return card;" +"    }" +"" +"    // gives player a new card from a given position" +"    public void GivePlayerACard(CardAsset c, int UniqueID, bool fast = false, bool fromDeck = true)" +"    {" +"        GameObject card;" +"        if (fromDeck)" +"            card = CreateACardAtPosition(c, DeckTransform.position, new Vector3(0f, -179f, 0f));" +"        else" +"            card = CreateACardAtPosition(c, OtherCardDrawSourceTransform.position, new Vector3(0f, 0f, 0f));" +"        // Check if hand is full" +"        // Suppose 'transform' is the Transform you want to change" +"        if (CardsInHand.Count >= MAX_CARDS_IN_HAND) // Assuming MAX_CARDS_IN_HAND is a constant representing max hand size" +"        {" +"            // Shake and destroy the card at the preview spot" +"            Sequence seq = DOTween.Sequence();" +"            seq.Append(card.transform.DOMove(DrawPreviewSpot.position, GlobalSettings.Instance.CardTransitionTime));" +"            if (TakeCardsOpenly)" +"                seq.Append(card.transform.DORotate(Vector3.zero, 0.2f));" +"            seq.Append(card.transform.DOShakePosition(1, 0.5f, 10, 40, true, false)) // Shake for 1 second with a strength of 0.5" +"              .OnComplete(() =>" +"              {" +"                  HoverPreview.PreviewsAllowed = true;" +"                  Destroy(card);" +"              }); // Destroy the card after shaking" +"            return;" +"        }" +"        // Set a tag to reflect where this card is" +"        foreach (Transform t in card.GetComponentsInChildren<Transform>())" +"            t.tag = owner.ToString() + \"Card\";" +"        // pass this card to HandVisual class" +"        int newIndex = AddCard(card);" +"" +"        // Bring card to front while it travels from draw spot to hand" +"        WhereIsTheCardOrCreature w = card.GetComponent<WhereIsTheCardOrCreature>();" +"        w.BringToFront();" +"        w.Slot = newIndex;" +"        w.VisualState = VisualStates.Transition;" +"" +"        // pass a unique ID to this card." +"        IDHolder id = card.AddComponent<IDHolder>();" +"        id.UniqueID = UniqueID;" +"        float slotsAnimate = 0.5f;" +"        // move card to the hand;" +"        Sequence s = DOTween.Sequence();" +"        if (!fast)" +"        {" +"            // Debug.Log (\"Not fast!!!\");" +"            s.Append(card.transform.DOMove(DrawPreviewSpot.position, GlobalSettings.Instance.CardTransitionTime));" +"            if (TakeCardsOpenly)" +"                s.Append(card.transform.DORotate(Vector3.zero, 0.2f));" +"            // else" +"            //     s.Insert(0f, card.transform.DORotate(new Vector3(0f, 179f, 0f), GlobalSettings.Instance.CardTransitionTime));" +"            s.Insert(1f, card.transform.DOScale(2f, 0.05f)); // scale up in half of the transition time" +"            s.AppendInterval(GlobalSettings.Instance.CardPreviewTime);" +"            s.Append(card.transform.DOScale(1f, 0.05f)); // scale up in half of the transition time" +"            // displace the card so that we can select it in the scene easier." +"            //s.Append(card.transform.DOLocalMove(slots.Children[newIndex].transform.position, GlobalSettings.Instance.CardTransitionTime));" +"        }" +"        else" +"        {" +"            // displace the card so that we can select it in the scene easier." +"            //s.Append(card.transform.DOLocalMove(slots.Children[newIndex].transform.localPosition, GlobalSettings.Instance.CardTransitionTimeFast));" +"            transform.rotation = Quaternion.identity;" +"            slotsAnimate = GlobalSettings.Instance.CardTransitionTimeFast;" +"            s.AppendInterval(0.35f);" +"        }" +"" +"        s.OnComplete(() =>" +"        {" +"            ChangeLastCardStatusToInHand(card, w);" +"            PlaceCardsOnNewSlotsAnimate(slotsAnimate);" +"            OnHandChange?.Invoke();" +"        });" +"    }" +"" +"    // this method will be called when the card arrived to hand " +"    void ChangeLastCardStatusToInHand(GameObject card, WhereIsTheCardOrCreature w)" +"    {" +"        //Debug.Log(\"Changing state to Hand for card: \" + card.gameObject.name);" +"        if (owner == AreaPosition.Low)" +"            w.VisualState = VisualStates.LowHand;" +"        else" +"            w.VisualState = VisualStates.TopHand;" +"" +"        // set correct sorting order" +"        w.SetHandSortingOrder();" +"        // end command execution for DrawACArdCommand" +"" +"    }" +"" +"" +"    // PLAYING SPELLS" +"" +"    // 2 Overloaded method to show a spell played from hand" +"    public void PlayASpellFromHand(int CardID)" +"    {" +"        GameObject card = IDHolder.GetGameObjectWithID(CardID);" +"        PlayASpellFromHand(card);" +"    }" +"" +"    public void PlayASpellFromHand(GameObject CardVisual)" +"    {" +"" +"        CardVisual.GetComponent<WhereIsTheCardOrCreature>().VisualState = VisualStates.Transition;" +"        RemoveCard(CardVisual);" +"        Command.CommandExecutionComplete();" +"" +"        // CardVisual.transform.SetParent(null);" +"" +"        // Sequence s = DOTween.Sequence();" +"        // s.Append(CardVisual.transform.DOMove(PlayPreviewSpot.position, 1f));" +"        // s.Insert(0f, CardVisual.transform.DORotate(Vector3.zero, 1f));" +"        // s.AppendInterval(2f);" +"        // s.OnComplete(() =>" +"        //     {" +"        //         //Command.CommandExecutionComplete();" +"        //         Destroy(CardVisual);" +"        //     });" +"    }" +"" +"    internal void DestroyCardVisual(int uniqueCardID)" +"    {" +"        GameObject card = IDHolder.GetGameObjectWithID(uniqueCardID);" +"        StartCoroutine(DestroyWithDelay(card, 0.2f, () =>" +"{" +"    Command.CommandExecutionComplete();" +"    // additional code here" +"}));" +"" +"    }" +"    private IEnumerator DestroyWithDelay(GameObject gameObject, float delay, Action callback)" +"    {" +"        yield return new WaitForSeconds(delay);" +"        Destroy(gameObject);" +"        callback?.Invoke();" +"    }" +"}" 
  }
,
  {
    "fileName": "HeroPowerButton.cs",
    "relativeFilePath": "Assets/Scripts/Visual/HeroPowerButton.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class HeroPowerButton : MonoBehaviour {" +"" +"    public AreaPosition owner;" +"" +"    public GameObject Front;" +"    public GameObject Back;" +"" +"    public GameObject Glow;" +"" +"    private bool wasUsed = false;" +"    public bool WasUsedThisTurn" +"    { " +"        get" +"        {" +"            return wasUsed;" +"        } " +"        set" +"        {" +"            wasUsed = value;" +"            if (!wasUsed)" +"            {" +"                Front.SetActive(true);" +"                Back.SetActive(false);" +"            }" +"            else" +"            {" +"                Front.SetActive(false);" +"                Back.SetActive(true);" +"                Highlighted = false;" +"            }" +"        }" +"    }" +"" +"    private bool highlighted = false;" +"    public bool Highlighted" +"    {" +"        get{ return highlighted; }" +"" +"        set" +"        {" +"            highlighted = value;" +"            Glow.SetActive(highlighted);" +"        }" +"    }" +"" +"    void OnMouseDown()" +"    {" +"        if (!WasUsedThisTurn && Highlighted)" +"        {" +"            GlobalSettings.Instance.Players[owner].UseHeroPower();" +"            WasUsedThisTurn= !WasUsedThisTurn;" +"        }" +"    }" +"}" 
  }
,
  {
    "fileName": "HoverPreview.cs",
    "relativeFilePath": "Assets/Scripts/Visual/HoverPreview.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using DG.Tweening;" +"using System.Collections.Generic;" +"" +"public class HoverPreview : MonoBehaviour" +"{" +"    // PUBLIC FIELDS" +"    public GameObject TurnThisOffWhenPreviewing;  // if this is null, will not turn off anything " +"    public Vector3 TargetPosition;" +"    public float TargetScale;" +"    public GameObject previewGameObject;" +"    public bool ActivateInAwake = false;" +"" +"    // PRIVATE FIELDS" +"    private static HoverPreview currentlyViewing = null;" +"" +"    // PROPERTIES WITH UNDERLYING PRIVATE FIELDS" +"    private static Dictionary<int, Sequence> runningSequences = new Dictionary<int, Sequence>();" +"" +"     // Add new serialized field for delay" +"    [SerializeField]" +"    private float previewDelay = 0.5f;" +"" +"    // Add private field for coroutine" +"    private Coroutine previewCoroutine;" +"    private static bool _PreviewsAllowed = true;" +"    public static bool PreviewsAllowed" +"    {" +"        get { return _PreviewsAllowed; }" +"" +"        set" +"        {" +"            //Debug.Log(\"Hover Previews Allowed is now: \" + value);" +"            _PreviewsAllowed = value;" +"            if (!_PreviewsAllowed)" +"                StopAllPreviews();" +"        }" +"    }" +"" +"    private bool _thisPreviewEnabled = false;" +"    public bool ThisPreviewEnabled" +"    {" +"        get { return _thisPreviewEnabled; }" +"" +"        set" +"        {" +"            _thisPreviewEnabled = value;" +"            if (!_thisPreviewEnabled)" +"                StopThisPreview();" +"        }" +"    }" +"" +"    public bool OverCollider { get; set; }" +"" +"    // MONOBEHVIOUR METHODS" +"    void Awake()" +"    {" +"        ThisPreviewEnabled = ActivateInAwake;" +"    }" +"" +"    void OnMouseEnter()" +"    {" +"        // OverCollider = true;" +"        // if (PreviewsAllowed && ThisPreviewEnabled)" +"        //     PreviewThisObject();" +"         OverCollider = true;" +"        if (PreviewsAllowed && ThisPreviewEnabled)" +"            previewCoroutine = StartCoroutine(PreviewWithDelay());" +"    }" +"" +"    void OnMouseExit()" +"    {" +"        // OverCollider = false;" +"" +"        // if (!PreviewingSomeCard())" +"        //     StopAllPreviews();" +"         OverCollider = false;" +"" +"        if (!PreviewingSomeCard())" +"            StopAllPreviews();" +"" +"        // If the preview coroutine has started, stop it." +"        if (previewCoroutine != null)" +"        {" +"            StopCoroutine(previewCoroutine);" +"            previewCoroutine = null;" +"        }" +"    }" +"" +"    // Add new method for Coroutine" +"    IEnumerator PreviewWithDelay()" +"    {" +"        // Wait for the specified delay" +"        yield return new WaitForSeconds(previewDelay);" +"" +"        // Then call the preview method" +"        PreviewThisObject();" +"    }" +"" +"    // OTHER METHODS" +"    void PreviewThisObject()" +"    {" +"        StopAllPreviews();" +"" +"        currentlyViewing = this;" +"        if (!PreviewsAllowed) return;" +"        previewGameObject.SetActive(true);" +"" +"        if (TurnThisOffWhenPreviewing != null)" +"            TurnThisOffWhenPreviewing.SetActive(false);" +"" +"        previewGameObject.transform.localPosition = Vector3.zero;" +"        previewGameObject.transform.localScale = Vector3.one;" +"        // Set rotation to match the inverse rotation of the world" +"        Vector3 previewRotation = transform.eulerAngles;" +"        previewRotation.z = 0;" +"        previewRotation.x = 0;" +"        previewGameObject.transform.rotation = Quaternion.Euler(previewRotation);" +"" +"" +"" +"        // Create or restart the sequence for this HoverPreview" +"        if (!runningSequences.ContainsKey(GetInstanceID()))" +"        {" +"            runningSequences[GetInstanceID()] = DOTween.Sequence();" +"        }" +"        else" +"        {" +"            runningSequences[GetInstanceID()].Restart();" +"        }" +"" +"        Sequence mySequence = runningSequences[GetInstanceID()];" +"        mySequence.Kill();" +"        mySequence = DOTween.Sequence();" +"        mySequence.Append(previewGameObject.transform.DOLocalMove(TargetPosition, 1f).SetEase(Ease.OutQuint));" +"        mySequence.Join(previewGameObject.transform.DOScale(TargetScale, 1f).SetEase(Ease.OutQuint));" +"    }" +"" +"    void StopThisPreview()" +"    {" +"        if (runningSequences.ContainsKey(GetInstanceID()))" +"        {" +"            Sequence mySequence = runningSequences[GetInstanceID()];" +"            mySequence.Kill();" +"            mySequence = DOTween.Sequence();" +"            mySequence.Append(previewGameObject.transform.DOLocalMove(Vector3.zero, 0.2f).SetEase(Ease.InQuint));" +"            mySequence.Join(previewGameObject.transform.DOScale(Vector3.one, 0.2f).SetEase(Ease.InQuint));" +"            mySequence.AppendCallback(() =>" +"            {" +"                if (previewGameObject == null) return;" +"                previewGameObject.SetActive(false);" +"                if (TurnThisOffWhenPreviewing != null)" +"                    TurnThisOffWhenPreviewing.SetActive(true);" +"            });" +"        }" +"        else" +"        {" +"            previewGameObject.SetActive(false);" +"            previewGameObject.transform.localScale = Vector3.one;" +"            previewGameObject.transform.localPosition = Vector3.zero;" +"            if (TurnThisOffWhenPreviewing != null)" +"                TurnThisOffWhenPreviewing.SetActive(true);" +"        }" +"    }" +"" +"    // STATIC METHODS" +"    private static void StopAllPreviews()" +"    {" +"        if (currentlyViewing != null)" +"        {" +"            // Call StopThisPreview() to handle stopping and animations properly" +"            currentlyViewing.StopThisPreview();" +"            // Clear the currentlyViewing variable" +"            currentlyViewing = null;" +"        }" +"" +"    }" +"" +"    private static bool PreviewingSomeCard()" +"    {" +"        if (!PreviewsAllowed)" +"            return false;" +"" +"        HoverPreview[] allHoverBlowups = GameObject.FindObjectsOfType<HoverPreview>();" +"" +"        foreach (HoverPreview hb in allHoverBlowups)" +"        {" +"            if (hb.OverCollider && hb.ThisPreviewEnabled)" +"                return true;" +"        }" +"" +"        return false;" +"    }" +"" +"" +"}" 
  }
,
  {
    "fileName": "IDFactory.cs",
    "relativeFilePath": "Assets/Scripts/Visual/IDFactory.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using System.Collections.Generic;" +"" +"public static class IDFactory {" +"" +"    public static int Count;" +"" +"    public static int GetUniqueID()" +"    {" +"        // Count++ has to go first, otherwise - unreachable code." +"        Count++;" +"        return Count;" +"    }" +"	" +"    public static void ResetIDs()" +"    {" +"        Count = 0;" +"    }" +"" +"" +"}" 
  }
,
  {
    "fileName": "ManaPoolVisual.cs",
    "relativeFilePath": "Assets/Scripts/Visual/ManaPoolVisual.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using UnityEngine.UI;" +"" +"#if UNITY_EDITOR" +"using UnityEditor;" +"#endif" +"[ExecuteInEditMode]" +"public class ManaPoolVisual : MonoBehaviour" +"{" +"    public int TestFullCrystals;" +"    public int TestTotalCrystalsThisTurn;" +"" +"    public Image[] Crystals;" +"    public Text ProgressText;" +"    private int totalCrystals;" +"    public int TotalCrystals" +"    {" +"        get { return totalCrystals; }" +"        set" +"        {" +"            int clampedValue = Mathf.Clamp(value, 0, Crystals.Length);" +"            if (clampedValue != totalCrystals)" +"            {" +"                totalCrystals = clampedValue;" +"                UpdateCrystals();" +"            }" +"        }" +"    }" +"" +"    private int availableCrystals;" +"    public int AvailableCrystals" +"    {" +"        get { return availableCrystals; }" +"        set" +"        {" +"            int clampedValue = Mathf.Clamp(value, 0, totalCrystals);" +"            if (clampedValue != availableCrystals)" +"            {" +"                availableCrystals = clampedValue;" +"                UpdateCrystals();" +"            }" +"        }" +"    }" +"" +"" +"" +"    private readonly string progressTextFormat = \"{0}/{1}\";" +"" +"    void Update()" +"    {" +"#if UNITY_EDITOR" +"        if (Application.isEditor && !Application.isPlaying)" +"        {" +"            TotalCrystals = TestTotalCrystalsThisTurn;" +"            AvailableCrystals = TestFullCrystals;" +"        }" +"#endif" +"    }" +"" +"    private void UpdateCrystals()" +"    {" +"        for (int i = 0; i < Crystals.Length; i++)" +"        {" +"            if (i < totalCrystals)" +"            {" +"                Crystals[i].color = i < availableCrystals ? Color.white : Color.gray;" +"            }" +"            else" +"            {" +"                Crystals[i].color = Color.clear;" +"            }" +"        }" +"" +"        UpdateProgressText();" +"    }" +"" +"    private void UpdateProgressText()" +"    {" +"        ProgressText.text = string.Format(progressTextFormat, availableCrystals, totalCrystals);" +"    }" +"}" 
  }
,
  {
    "fileName": "MessageManager.cs",
    "relativeFilePath": "Assets/Scripts/Visual/MessageManager.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using UnityEngine.UI;" +"using DG.Tweening;" +"" +"public class MessageManager : MonoBehaviour " +"{" +"    public Text MessageText;" +"    public GameObject MessagePanel;" +"    public GameObject MiniMessagePanel;" +"    public Text MiniMessageText;" +"    private CanvasGroup canvasGroup;" +"    private CanvasGroup miniCanvasGroup;" +"" +"    // Serialized fields" +"    [SerializeField]" +"    private float fadeDuration = 1f; // default value is 1" +"    [SerializeField]" +"    private float scaleDuration = 1f; // default value is 1" +"    [SerializeField]" +"    private float scaleValue = 1.2f; // default value is 1.2" +"" +"    public static MessageManager Instance;" +"" +"    void Awake()" +"    {" +"        Instance = this;" +"        MessagePanel.SetActive(false);" +"        MiniMessagePanel.SetActive(false);" +"        canvasGroup = MessagePanel.GetComponent<CanvasGroup>();" +"        miniCanvasGroup = MiniMessagePanel.GetComponent<CanvasGroup>();" +"    }" +"" +"    public void ShowMessage(string Message, float Duration)" +"    {" +"        StartCoroutine(ShowMessageCoroutine(Message, Duration));" +"        " +"    }" +"" +"    IEnumerator ShowMessageCoroutine(string Message, float Duration)" +"    {" +"        MessageText.text = Message;" +"        MessagePanel.SetActive(true);" +"" +"        // Fade in and scale up" +"        canvasGroup.DOFade(1, fadeDuration);" +"        MessageText.transform.DOScale(scaleValue, scaleDuration).SetLoops(2, LoopType.Yoyo);" +"" +"        yield return new WaitForSeconds(Duration);" +"        Command.CommandExecutionComplete();" +"        // Fade out" +"        canvasGroup.DOFade(0, fadeDuration)" +"                .OnComplete(() =>" +"                {" +"                    MessagePanel.SetActive(false);" +"                    canvasGroup.alpha = 1f; // reset the transparency to be ready for the next message" +"" +"                });" +"    }" +"    IEnumerator RefreshMessage(string Message, float duration) {" +"        FadeOutMessage(duration);" +"        yield return new WaitForSeconds(duration);" +"        FadeInMessage(Message, duration);" +"    }" +"    " +"" +"    private void FadeOutMessage(float fadeDuration)" +"    {" +"        miniCanvasGroup.DOFade(0, fadeDuration)" +"                .OnComplete(() =>" +"                {" +"                    MiniMessagePanel.SetActive(false);" +"                    miniCanvasGroup.alpha = 1f; // reset the transparency to be ready for the next message" +"" +"                });" +"    }" +"" +"    private void FadeInMessage(string Message, float fadeDuration)" +"    {" +"        MiniMessageText.text = Message;" +"        MiniMessagePanel.SetActive(true);" +"" +"        // Fade in and scale up" +"        miniCanvasGroup.DOFade(1, fadeDuration);" +"        MiniMessageText.transform.DOScale(scaleValue, scaleDuration).SetLoops(2, LoopType.Yoyo);" +"    }" +"    public void RefreshMessagePanel(string Message, float duration) {" +"        StartCoroutine(RefreshMessage(Message, duration));" +"    }" +"    public void ShowMessageInstant(string Message) {" +"        MiniMessageText.text = Message;" +"        MiniMessagePanel.SetActive(true);" +"        miniCanvasGroup.alpha = 1f;" +"    }" +"    public void HideMessageInstant() {" +"        MiniMessagePanel.SetActive(false);" +"        miniCanvasGroup.alpha = 0f;" +"    }" +"" +"    " +"}" 
  }
,
  {
    "fileName": "MoveAlongPath.cs",
    "relativeFilePath": "Assets/Scripts/Visual/MoveAlongPath.cs",
    "type": "script",
    "content": "using UnityEngine;" +"using DG.Tweening;" +"" +"public class MoveAlongPath : MonoBehaviour" +"{" +"    [SerializeField] private DOTweenPath path;" +"    [SerializeField] private float duration = 5f;" +"" +"    private void Start()" +"    {" +"        Vector3[] pathPoints = path.wps.ToArray();" +"        transform.DOScale(Vector3.zero, 0);" +"        transform.DOPath(pathPoints, duration, path.pathType)" +"            .OnWaypointChange(waypointIndex => {" +"                transform.DOScale(Vector3.one * (waypointIndex + 1) / (float)pathPoints.Length, 0.5f);" +"            });" +"    }" +"}" 
  }
,
  {
    "fileName": "OneCardManager.cs",
    "relativeFilePath": "Assets/Scripts/Visual/OneCardManager.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using UnityEngine.UI;" +"using CG.Cards;" +"using System.Text;" +"using System;" +"// holds the refs to all the Text, Images on the card" +"public class OneCardManager : MonoBehaviour {" +"" +"    public CardAsset cardAsset;" +"    public OneCardManager PreviewManager;" +"    [Header(\"Text Component References\")]" +"    public Text NameText;" +"    public Text ManaCostText;" +"    public Text DescriptionText;" +"    public Text HealthText;" +"    public Text AttackText;" +"    public Text CardTypeText;" +" " +"    [Header(\"Image References\")]" +"    public Image CardTopRibbonImage;" +"    public Image CardLowRibbonImage;" +"    public Image CardGraphicImage;" +"    " +"    public Image CardBodyImage;" +"    public Image CardFaceFrameImage;" +"    public Image CardFaceGlowImage;" +"    public Image CardBackGlowImage;" +"" +"    public event Action OnCardLoaded;" +"" +"    void Awake()" +"    {" +"        if (cardAsset != null)" +"            ReadCardFromAsset();" +"    }" +"" +"    private bool canBePlayedNow = false;" +"    public bool CanBePlayedNow" +"    {" +"        get" +"        {" +"            return canBePlayedNow;" +"        }" +"" +"        set" +"        {" +"            canBePlayedNow = value;" +"" +"            CardFaceGlowImage.enabled = value;" +"        }" +"    }" +"" +"    public void ReadCardFromAsset()" +"    {" +"        // universal actions for any Card" +"        // 1) apply tint" +"        if (cardAsset.characterAsset != null)" +"        {" +"            CardBodyImage.color = cardAsset.characterAsset.ClassCardTint;" +"            CardFaceFrameImage.color = cardAsset.characterAsset.ClassCardTint;" +"            CardTopRibbonImage.color = cardAsset.characterAsset.ClassRibbonsTint;" +"            CardLowRibbonImage.color = cardAsset.characterAsset.ClassRibbonsTint;" +"        }" +"        else" +"        {" +"            CardFaceFrameImage.color = Color.white;" +"        }" +"        // 2) add card name" +"        NameText.text = cardAsset.name;" +"        // 3) add mana cost" +"        ManaCostText.text = cardAsset.ManaCost.ToString();" +"        // 4) add description" +"        DescriptionText.text = cardAsset.Description;" +"        // 5) Change the card graphic sprite" +"        CardGraphicImage.sprite = cardAsset.CardImage;" +"        CardTypeText.text = EnumToStringWithSpaces(cardAsset.CardType);" +"" +"        if (cardAsset.MaxHealth != 0)" +"        {" +"            // this is a creature" +"            AttackText.text = cardAsset.Attack.ToString();" +"            HealthText.text = cardAsset.MaxHealth.ToString();" +"        }" +"" +"        if (PreviewManager != null)" +"        {" +"            // this is a card and not a preview" +"            // Preview GameObject will have OneCardManager as well, but PreviewManager should be null there" +"            PreviewManager.cardAsset = cardAsset;" +"            PreviewManager.ReadCardFromAsset();" +"        }" +"    }" +"    private void Start() {" +"        OnCardLoaded?.Invoke();" +"    }" +"    public static string EnumToStringWithSpaces(ECardType value)" +"{" +"    string input = value.ToString();" +"    StringBuilder output = new StringBuilder();" +"" +"    for (int i = 0; i < input.Length; i++)" +"    {" +"        if (i > 0 && char.IsUpper(input[i]))" +"        {" +"            output.Append(' ');" +"        }" +"        output.Append(input[i]);" +"    }" +"" +"    return output.ToString();" +"}" +"}" 
  }
,
  {
    "fileName": "OneCreatureManager.cs",
    "relativeFilePath": "Assets/Scripts/Visual/OneCreatureManager.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using UnityEngine.UI;" +"using CG.Cards;" +"" +"public class OneCreatureManager : MonoBehaviour " +"{" +"    public CardAsset cardAsset;" +"    public OneCardManager PreviewManager;" +"    [Header(\"Text Component References\")]" +"    public Text HealthText;" +"    public Text AttackText;" +"    [Header(\"Image References\")]" +"    public Image CreatureGraphicImage;" +"    public Image CreatureGlowImage;" +"" +"    void Awake()" +"    {" +"        if (cardAsset != null)" +"            ReadCreatureFromAsset();" +"    }" +"" +"    private bool canAttackNow = false;" +"    public bool CanAttackNow" +"    {" +"        get" +"        {" +"            return canAttackNow;" +"        }" +"" +"        set" +"        {" +"            canAttackNow = value;" +"" +"            CreatureGlowImage.enabled = value;" +"        }" +"    }" +"" +"    public void ReadCreatureFromAsset()" +"    {" +"        // Change the card graphic sprite" +"        CreatureGraphicImage.sprite = cardAsset.CreatureImage;" +"" +"        AttackText.text = cardAsset.Attack.ToString();" +"        HealthText.text = cardAsset.MaxHealth.ToString();" +"" +"        if (PreviewManager != null)" +"        {" +"            PreviewManager.cardAsset = cardAsset;" +"            PreviewManager.ReadCardFromAsset();" +"        }" +"    }	" +"" +"    public void TakeDamage(int amount, int healthAfter)" +"    {" +"        if (amount > 0)" +"        {" +"            //DamageEffect.CreateDamageEffect(transform.position, amount);" +"            HealthText.text = healthAfter.ToString();" +"        }" +"    }" +"}" 
  }
,
  {
    "fileName": "PlayerArea.cs",
    "relativeFilePath": "Assets/Scripts/Visual/PlayerArea.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public enum AreaPosition{Top, Low}" +"" +"public class PlayerArea : MonoBehaviour " +"{" +"    public AreaPosition owner;" +"    public bool ControlsON = true;" +"    public PlayerDeckVisual PDeck;" +"    public ManaPoolVisual ManaBar;" +"    public HandVisual handVisual;" +"    public PlayerPortraitVisual Portrait;" +"    public HeroPowerButton HeroPower;" +"    public TableVisual tableVisual;" +"    public Transform PortraitPosition;" +"    public Transform PlayCardStackPosition;" +"" +"    public bool AllowedToControlThisPlayer" +"    {" +"        get;" +"        set;" +"    }      " +"" +"" +"" +"}" 
  }
,
  {
    "fileName": "PlayerDeckVisual.cs",
    "relativeFilePath": "Assets/Scripts/Visual/PlayerDeckVisual.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using DG.Tweening;" +"" +"// this class should be attached to the deck" +"// generates new cards and places them into the hand" +"public class PlayerDeckVisual : MonoBehaviour {" +"" +"    public AreaPosition owner;" +"    public float HeightOfOneCard = 0.012f;" +"" +"    void Start()" +"    {" +"        CardsInDeck = GlobalSettings.Instance.Players[owner].deck.cards.Count;" +"    }" +"" +"    private int cardsInDeck = 0;" +"    public int CardsInDeck" +"    {" +"        get{ return cardsInDeck; }" +"" +"        set" +"        {" +"            cardsInDeck = value;" +"            transform.position = new Vector3(transform.position.x, transform.position.y, - HeightOfOneCard * value);" +"        }" +"    }" +"   " +"}" 
  }
,
  {
    "fileName": "PlayerPortraitVisual.cs",
    "relativeFilePath": "Assets/Scripts/Visual/PlayerPortraitVisual.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using UnityEngine.UI;" +"using DG.Tweening;" +"" +"public class PlayerPortraitVisual : MonoBehaviour" +"{" +"" +"    // TODO : get ID from players when game starts" +"" +"    public CharacterAsset charAsset;" +"    [Header(\"Text Component References\")]" +"    //public Text NameText;" +"    public Text HealthText;" +"    [Header(\"Image References\")]" +"    public Image HeroPowerIconImage;" +"    public Image HeroPowerBackgroundImage;" +"    public Image PortraitImage;" +"    public Image PortraitBackgroundImage;" +"" +"    private void Awake()" +"    {" +"        if (charAsset != null)" +"        {" +"            ApplyLookFromAsset();" +"        }" +"    }" +"    public void ApplyLookFromAsset()" +"    {" +"        HealthText.text = charAsset.MaxHealth.ToString();" +"        HeroPowerIconImage.sprite = charAsset.HeroPowerIconImage;" +"        HeroPowerBackgroundImage.sprite = charAsset.HeroPowerBGImage;" +"        PortraitImage.sprite = charAsset.AvatarImage;" +"        PortraitBackgroundImage.sprite = charAsset.AvatarBGImage;" +"" +"        HeroPowerBackgroundImage.color = charAsset.HeroPowerBGTint;" +"        PortraitBackgroundImage.color = charAsset.AvatarBGTint;" +"" +"    }" +"" +"    public void TakeDamage(int amount, int healthAfter)" +"    {" +"        if (amount > 0)" +"        {" +"            //DamageEffect.CreateDamageEffect(transform.position, amount);" +"            HealthText.text = healthAfter.ToString();" +"        }" +"    }" +"" +"    public void Explode()" +"    {" +"        /*" +"        Instantiate(GlobalSettings.Instance.ExplosionPrefab, transform.position, Quaternion.identity);" +"        Sequence s = DOTween.Sequence();" +"        s.PrependInterval(2f);" +"        s.OnComplete(() => GlobalSettings.Instance.GameOverCanvas.SetActive(true));" +"        */" +"    }" +"" +"" +"" +"}" 
  }
,
  {
    "fileName": "PositionManager.cs",
    "relativeFilePath": "Assets/Scripts/Visual/PositionManager.cs",
    "type": "script",
    "content": "using UnityEngine;" +"public class PositionManager : MonoBehaviour" +"{" +"    private Transform FirstSlot;" +"    private Transform LastSlot;" +"    private Vector3 firstPos, lastPos;" +"    public Transform[] Children;" +"     public AreaPosition owner;" +"    [SerializeField] private float maxRotation = 20f;  // maximum rotation for first and last cards" +"    [SerializeField] private float radiusFactor = 0.5f;  // adjust this value to control the spread of the cards" +"    [SerializeField] private int angleFactor = 12;" +"    [SerializeField] private float yCorrectionFactor = 2f;" +"    // [SerializeField] private float lengthPerCard = 1f;" +"    // [SerializeField] private float maxHandLength = 8f;" +"" +"    private void Awake()" +"    {" +"        UpdateFirstAndLastSlots();" +"        firstPos = FirstSlot.position;" +"        lastPos = LastSlot.position;" +"        PositionSlots();" +"        " +"    }" +"    private void Update() {" +"        //UpdateFirstAndLastSlots();" +"        // PositionSlots();" +"    }" +"    // private void OnTransformChildrenChanged()" +"    // {" +"    //     //UpdateFirstAndLastSlots();" +"    //     PositionSlots();" +"    // }" +"    " +"    private void PositionSlots()" +"    {" +"" +"        float firstRotZ = maxRotation;" +"        float lastRotZ = -maxRotation;" +"        float radius = ((lastPos - firstPos).magnitude / 2f) * radiusFactor;  // radius of the arc" +"        Vector3 centerPos = (lastPos + firstPos) / 2f;  // center of the arc" +"" +"        for (int i = 0; i < Children.Length; i++)" +"        {" +"            Transform child = transform.GetChild(i);" +"            float t = (float)i / (transform.childCount - 1);" +"" +"            // Calculate angle in radians" +"            float angle = Mathf.Lerp(-Mathf.PI / angleFactor, Mathf.PI / angleFactor, t);" +"" +"            // Calculate position on the arc" +"            Vector3 posOnArc = new Vector3(radius * Mathf.Sin(angle), radius * Mathf.Cos(angle) + centerPos.y * yCorrectionFactor, 0f);" +"            child.position = centerPos + posOnArc;" +"" +"            // Calculate rotation" +"            float rotZ = Mathf.Lerp(firstRotZ, lastRotZ, t);" +"            if (owner == AreaPosition.Top) {" +"                child.rotation = Quaternion.Euler(0, 0, rotZ - 180f);" +"            }" +"            else {" +"                child.rotation = Quaternion.Euler(0, 0, rotZ);" +"            }" +"        }" +"    }" +"    private void UpdateFirstAndLastSlots()" +"    {" +"        if (transform.childCount > 0)" +"        {" +"            FirstSlot = transform.GetChild(0);" +"            LastSlot = transform.GetChild(transform.childCount - 1);" +"        }" +"    }" +"}" 
  }
,
  {
    "fileName": "PromptWindow.cs",
    "relativeFilePath": "Assets/Scripts/Visual/PromptWindow.cs",
    "type": "script",
    "content": "using System.Collections;" +"using System.Collections.Generic;" +"using CG.Cards;" +"using DG.Tweening;" +"using UnityEngine;" +"using UnityEngine.UI;" +"" +"public class PromptWindow : MonoBehaviour" +"{" +"    public static PromptWindow Instance { get; private set; }" +"" +"    public GameObject Canvas;" +"    public GameObject SpellCardPrefab;" +"    public GameObject CreatureCardPrefab;" +"    public GameObject CardDisplayArea;" +"    public Button PreviousButton;" +"    public Button NextButton;" +"    public Text DisplayTextPrompt;" +"    public int itemsPerPage = 6;" +"    private int totalItems = 0;" +"    private int currentPage = 1;" +"    private int totalPages = 1;" +"    private int requiredTargets = 3;" +"    //private List<CardLogic> cards = new List<CardLogic>();" +"    public List<CardAsset> cardData = new List<CardAsset>();" +"    private List<CardAsset> selectedCards = new List<CardAsset>();" +"    private List<int> selectedIndexes = new List<int>();" +"    private List<GameObject> cardDisplays = new List<GameObject>();" +"    // Start is called before the first frame update" +"" +"    private void Awake()" +"    {" +"        // Singleton pattern" +"        if (Instance == null)" +"        {" +"            Instance = this;" +"            // Assuming this script is attached to the Canvas GameObject itself" +"            this.Canvas.transform.localScale = new Vector3(0, this.Canvas.transform.localScale.y, this.Canvas.transform.localScale.z);" +"            this.Canvas.SetActive(false);" +"        }" +"        else" +"        {" +"            Destroy(gameObject);" +"        }" +"    }" +"    private void OnEnable()" +"    {" +"        SelectableCardGlowController.OnCardClicked += HandleCardClick;" +"    }" +"" +"    private void OnDisable()" +"    {" +"        SelectableCardGlowController.OnCardClicked -= HandleCardClick;" +"    }" +"" +"    private void HandleCardClick(int cardIndex, bool selected)" +"    {" +"        // Handle the card click event here" +"        Debug.Log(\"Card at index \" + cardIndex + \" was clicked. Its selected state is \" + selected);" +"        if (selected)" +"        {" +"            selectedIndexes.Add(cardIndex);" +"            if (selectedIndexes.Count == requiredTargets)" +"            {" +"" +"                selectedIndexes.ForEach(i =>" +"                {" +"                    selectedCards.Add(cardData[i]);" +"                });" +"                Debug.Log(\"Selected cards: \");" +"                selectedCards.ForEach(c =>" +"                {" +"                    Debug.Log(c.name);" +"                });" +"                ClosePrompt();" +"            }" +"        }" +"        else" +"        {" +"            selectedIndexes.Remove(cardIndex);" +"        }" +"    }" +"    public void DisplayPrompt()" +"    {" +"        Canvas.SetActive(true);" +"        DisplayTextPrompt.text = \"Select 3 different cards.\";" +"        Canvas.GetComponent<RectTransform>().DOScaleX(0.01f, 0.5f); // animate over 1 second" +"" +"        //cards = newCards;" +"        //requiredTargets = numTargets;" +"        foreach (var card in cardData)" +"        {" +"            GameObject cardAsset = null;" +"            switch (card.CardType)" +"            {" +"                case ECardType.Spell:" +"                    {" +"                        cardAsset = GameObject.Instantiate(SpellCardPrefab, CardDisplayArea.transform);" +"                        break;" +"                    }" +"                case ECardType.Creature:" +"                    {" +"                        cardAsset = GameObject.Instantiate(CreatureCardPrefab, CardDisplayArea.transform);" +"                        break;" +"                    }" +"            }" +"            if (card.CardType == ECardType.Spell) { }" +"            OneCardManager manager = cardAsset.GetComponent<OneCardManager>();" +"            manager.cardAsset = card;" +"            manager.ReadCardFromAsset();" +"            cardAsset.SetActive(false);" +"" +"            cardDisplays.Add(cardAsset);" +"" +"        };" +"        Debug.Log(\"Updating display\");" +"        totalItems = cardDisplays.Count;" +"        totalPages = (totalItems + itemsPerPage - 1) / itemsPerPage;" +"        UpdatePagination();" +"    }" +"    private void UpdatePagination()" +"    {" +"        // Ceiling division" +"" +"        PreviousButton.interactable = currentPage > 1;" +"        NextButton.interactable = currentPage < totalPages;" +"        string s = \"\";" +"        // Enable/Disable cards based on the current page" +"        for (int i = 0; i < cardDisplays.Count; i++)" +"        {" +"            bool shouldShow = i >= (currentPage - 1) * itemsPerPage && i < currentPage * itemsPerPage;" +"            cardDisplays[i].SetActive(shouldShow);" +"            if (shouldShow) s += \" \" + i;" +"        }" +"        Debug.Log(\"Showing cards: \" + s);" +"    }" +"" +"    public void ClosePrompt()" +"    {" +"        Canvas.GetComponent<RectTransform>().DOScaleX(0f, 0.5f).OnComplete(() =>" +"        {" +"            Canvas.SetActive(false);" +"" +"        });" +"        cardDisplays.ForEach(Destroy);" +"        cardDisplays = new List<GameObject>();" +"        currentPage = 1;" +"        totalPages = 1;" +"        totalItems = 0;" +"        selectedCards = new List<CardAsset>();" +"        selectedIndexes = new List<int>();" +"        // Execute the completion command." +"        //Command.CommandExecutionComplete();" +"    }" +"    public void ChangePage(int value)" +"    {" +"        currentPage += value;" +"        UpdatePagination();" +"    }" +"" +"}" 
  }
,
  {
    "fileName": "RaycastExample.cs",
    "relativeFilePath": "Assets/Scripts/Visual/RaycastExample.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class RaycastExample : MonoBehaviour {" +"" +"    void Update () {" +"        if (Input.GetMouseButtonDown (0)) {" +"            Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);" +"            RaycastHit hit;" +"            if (Physics.Raycast(ray, out hit)) {" +"                Debug.Log (\"Name = \" + hit.collider.name);" +"                Debug.Log (\"Tag = \" + hit.collider.tag);" +"                Debug.Log (\"Hit Point = \" + hit.point);" +"                Debug.Log (\"Object position = \" + hit.collider.gameObject.transform.position);" +"                Debug.Log (\"--------------\");" +"            }" +"        }" +"    }" +"}" 
  }
,
  {
    "fileName": "RopeVisual.cs",
    "relativeFilePath": "Assets/Scripts/Visual/RopeVisual.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"public class RopeVisual : MonoBehaviour {" +"" +"	// Use this for initialization" +"	void Start () {" +"	" +"	}" +"	" +"	// Update is called once per frame" +"	void Update () {" +"	" +"	}" +"}" 
  }
,
  {
    "fileName": "SameDistanceChildren.cs",
    "relativeFilePath": "Assets/Scripts/Visual/SameDistanceChildren.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"" +"// place first and last elements in children array manually" +"// others will be placed automatically with equal distances between first and last elements" +"public class SameDistanceChildren : MonoBehaviour {" +"" +"    public Transform[] Children;" +"" +"	// Use this for initialization" +"	void Awake () " +"    {" +"        Vector3 firstElementPos = Children[0].transform.position;" +"        Vector3 lastElementPos = Children[Children.Length - 1].transform.position;" +"" +"        // dividing by Children.Length - 1 because for example: between 10 points that are 9 segments" +"        float XDist = (lastElementPos.x - firstElementPos.x)/(float)(Children.Length - 1);" +"        float YDist = (lastElementPos.y - firstElementPos.y)/(float)(Children.Length - 1);" +"        float ZDist = (lastElementPos.z - firstElementPos.z)/(float)(Children.Length - 1);" +"" +"        Vector3 Dist = new Vector3(XDist, YDist, ZDist);" +"" +"        for (int i = 1; i < Children.Length; i++)" +"        {" +"            Children[i].transform.position = Children[i - 1].transform.position + Dist;" +"        }" +"	}" +"	" +"	" +"}" 
  }
,
  {
    "fileName": "SceneReloader.cs",
    "relativeFilePath": "Assets/Scripts/Visual/SceneReloader.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using UnityEngine.SceneManagement;" +"" +"public class SceneReloader: MonoBehaviour {" +"" +"    public void ReloadScene()" +"    {" +"        // Command has some static members, so let\`s make sure that there are no commands in the Queue" +"        Debug.Log(\"Scene reloaded\");" +"        // reset all card and creature IDs" +"        IDFactory.ResetIDs();" +"        IDHolder.ClearIDHoldersList();" +"        Command.CommandList.Clear();" +"        Command.CommandExecutionComplete();" +"        SceneManager.LoadScene(SceneManager.GetActiveScene().name);" +"    }" +"}" 
  }
,
  {
    "fileName": "SelectableCardGlowController.cs",
    "relativeFilePath": "Assets/Scripts/Visual/SelectableCardGlowController.cs",
    "type": "script",
    "content": "using System.Collections;" +"using System.Collections.Generic;" +"using DG.Tweening;" +"using UnityEngine;" +"using UnityEngine.EventSystems;" +"using UnityEngine.UI;" +"" +"public class SelectableCardGlowController : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler, IPointerClickHandler" +"{" +"     public GameObject GlowImage; // Assign this in the inspector." +"    public Color SelectedColor;" +"    public Color HoverColor;" +"" +"    private bool isGlowing;" +"    private Image glowImageComponent;" +"" +"    public delegate void CardClicked(int cardIndex, bool selected);" +"public static event CardClicked OnCardClicked;" +"" +"    private void Start() " +"    {" +"        // Make sure the glow is off at the start." +"        GlowImage.SetActive(false);" +"" +"        glowImageComponent = GlowImage.GetComponent<Image>();" +"        glowImageComponent.color = HoverColor;" +"    }" +"" +"    public void OnPointerEnter(PointerEventData eventData) " +"    {" +"        // When the mouse enters the card, activate the glow." +"        GlowImage.SetActive(true);" +"    }" +"" +"    public void OnPointerExit(PointerEventData eventData) " +"    {" +"        // When the mouse leaves the card, deactivate the glow unless it's selected." +"        if (!isGlowing) {" +"            GlowImage.SetActive(false);" +"        }" +"    }" +"" +"    public void OnPointerClick(PointerEventData eventData) " +"    {" +"        // When the card is clicked, toggle whether it's selected or not." +"        isGlowing = !isGlowing;" +"        GlowImage.SetActive(isGlowing);" +"" +"        if (isGlowing) {" +"            // Change color and scale up the glow image when selected" +"            glowImageComponent.DOColor(SelectedColor, 0.3f);" +"            GlowImage.transform.DOScale(1.1f, 0.3f);" +"        }" +"        else {" +"            // Change color and scale down the glow image when deselected" +"            glowImageComponent.DOColor(HoverColor, 0.3f);" +"            GlowImage.transform.DOScale(1.0f, 0.3f);" +"        }" +"        // If any listeners are subscribed to the OnCardClicked event, raise the event." +"    if (OnCardClicked != null)" +"    {" +"        int cardIndex = transform.GetSiblingIndex();" +"        OnCardClicked(cardIndex, isGlowing);" +"    }" +"    }" +"}" 
  }
,
  {
    "fileName": "ShufflingExtention.cs",
    "relativeFilePath": "Assets/Scripts/Visual/ShufflingExtention.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using System.Collections.Generic;" +"" +"public static class ShufflingExtention {" +"" +"    // not my code!!!!!" +"    // got it here: http://stackoverflow.com/questions/273313/randomize-a-listt/1262619#1262619 " +"    private static System.Random rng = new System.Random();" +"" +"    public static void Shuffle<T>(this IList<T> list)  " +"    {  " +"        int n = list.Count;  " +"        while (n > 1) {  " +"            n--;  " +"            int k = rng.Next(n + 1);  " +"            T value = list[k];  " +"            list[k] = list[n];  " +"            list[n] = value;  " +"        }  " +"    }" +"}" 
  }
,
  {
    "fileName": "TableVisual.cs",
    "relativeFilePath": "Assets/Scripts/Visual/TableVisual.cs",
    "type": "script",
    "content": "using UnityEngine;" +"using System.Collections;" +"using System.Collections.Generic;" +"using DG.Tweening;" +"using CG.Cards;" +"using System.Linq;" +"using System;" +"" +"public class TableVisual : MonoBehaviour" +"{" +"    // PUBLIC FIELDS" +"" +"    // an enum that mark to whish caracter this table belongs. The alues are - Top or Low" +"    public AreaPosition owner;" +"    public CardAsset testAsset;" +"" +"    [SerializeField] public int maxCreatures = 8;" +"" +"    // a referense to a game object that marks positions where we should put new Creatures" +"    public SameDistanceChildren slots;" +"" +"    public event Action OnTableChange;" +"" +"    // PRIVATE FIELDS" +"" +"    // list of all the creature cards on the table as GameObjects" +"    private List<GameObject> CreaturesOnTable = new List<GameObject>();" +"" +"    // are we hovering over this table\`s collider with a mouse" +"    private bool cursorOverThisTable = false;" +"    private GameObject placeHolder;" +"    [SerializeField] public GameObject placeHolderPrefab;" +"    [SerializeField] public float shakeDuration = 0.5f;" +"" +"    // A 3D collider attached to this game object" +"    private BoxCollider col;" +"    private int UniqueID = 0;" +"    private UniqueIdGenerator generator = new UniqueIdGenerator();" +"    // PROPERTIES" +"" +"    // returns true if we are hovering over any player\`s table collider" +"    public static bool CursorOverSomeTable" +"    {" +"        get" +"        {" +"            TableVisual[] bothTables = GameObject.FindObjectsOfType<TableVisual>();" +"            // Debug.Log(\"Collide flag: \" + CursorOverSomeTable );" +"            return (bothTables[0].CursorOverThisTable || bothTables[1].CursorOverThisTable);" +"        }" +"    }" +"" +"    // returns true only if we are hovering over this table\`s collider" +"    public bool CursorOverThisTable" +"    {" +"        get { return cursorOverThisTable; }" +"    }" +"    public delegate void OnCreatureTrigger(int creatureID);" +"    public event OnCreatureTrigger OnCreatureEnterBattlefield;" +"" +"    // METHODS" +"" +"    // MONOBEHAVIOUR SCRIPTS (mouse over collider detection)" +"    void Awake()" +"    {" +"        col = GetComponent<BoxCollider>();" +"    }" +"    private void Start()" +"    {" +"        ShiftSlotsGameObjectAccordingToNumberOfCreatures();" +"        DraggingActions.DragFailed += OnDragFailed;" +"    }" +"" +"    // CURSOR/MOUSE DETECTION" +"    void Update()" +"    {" +"        // we need to Raycast because OnMouseEnter, etc reacts to colliders on cards and cards \"cover\" the table" +"        // create an array of RaycastHits" +"        RaycastHit[] hits;" +"        // raycst to mousePosition and store all the hits in the array" +"        hits = Physics.RaycastAll(Camera.main.ScreenPointToRay(Input.mousePosition), 30f);" +"" +"        bool passedThroughTableCollider = false;" +"        foreach (RaycastHit h in hits)" +"        {" +"            // check if the collider that we hit is the collider on this GameObject" +"            if (h.collider == col)" +"                passedThroughTableCollider = true;" +"        }" +"        cursorOverThisTable = passedThroughTableCollider;" +"" +"    }" +"    private void OnDragFailed()" +"    {" +"        if (placeHolder != null && CreaturesOnTable.Contains(placeHolder))" +"        {" +"            CreaturesOnTable.Remove(placeHolder);" +"            Destroy(placeHolder);" +"            placeHolder = null;" +"            ShiftSlotsGameObjectAccordingToNumberOfCreatures();" +"            PlaceCreaturesOnNewSlots();" +"        }" +"    }" +"    public void PredictCreatureSlot(int tablePos)" +"    {" +"        if (placeHolder != null && CreaturesOnTable.Contains(placeHolder))" +"        {" +"            CreaturesOnTable.Remove(placeHolder);" +"        }" +"        else" +"        {" +"            placeHolder = GameObject.Instantiate(placeHolderPrefab, slots.Children[tablePos].transform.position, Quaternion.identity, slots.transform) as GameObject;" +"        }" +"        CreaturesOnTable.Insert(tablePos, placeHolder);" +"        ShiftSlotsGameObjectAccordingToNumberOfCreatures();" +"        PlaceCreaturesOnNewSlots();" +"        Command.CommandExecutionComplete();" +"" +"    }" +"    // method to create a new creature and add it to the table" +"    public void AddCreatureAtIndex(CardAsset ca, int UniqueID, int index)" +"    {" +"        DestroyPlaceholder();" +"" +"        // create a new creature from prefab" +"        GameObject creature = CreateCreatureGO(index);" +"        ReadCardAssetForCreature(ca, creature);" +"" +"        ApplyTagsOnCreature(creature);" +"        SetParentForCreature(creature);" +"        AddCreatureToTable(index, creature);" +"        AddIDToCreature(UniqueID, creature);" +"" +"        UpdateTablePlacing();" +"        // Trigger the OnTableChange event" +"        OnTableChange?.Invoke();" +"" +"        // end command execution" +"        Command.CommandExecutionComplete();" +"    }" +"    public void SummonCreaturesOnTable(CardAsset ca, List<int> UniqueIDs)" +"    {" +"        List<int> indexes = new List<int>();" +"        int i = 0;" +"        while (CreaturesOnTable.Count + i < maxCreatures && indexes.Count < UniqueIDs.Count)" +"        {" +"            indexes.Add(CreaturesOnTable.Count + i);" +"            i++;" +"        }" +"        DestroyPlaceholder();" +"        List<GameObject> creatures = new List<GameObject>();" +"        for (int j = 0; j < indexes.Count; j++)" +"        {" +"            int index = indexes[j];" +"            int id = UniqueIDs[j];" +"            // create a new creature from prefab" +"            GameObject creature = CreateCreatureGO(index);" +"            creatures.Add(creature);" +"            //fade creature" +"" +"            ReadCardAssetForCreature(ca, creature);" +"" +"            ApplyTagsOnCreature(creature);" +"            SetParentForCreature(creature);" +"            AddCreatureToTable(index, creature);" +"            AddIDToCreature(id, creature);" +"            CanvasGroup canvasGroup = creature.GetComponentInChildren<CanvasGroup>();" +"            canvasGroup.alpha = 0;" +"            canvasGroup.DOFade(1, 1f);" +"        }" +"        UpdateTablePlacing();" +"        // Trigger the OnTableChange event" +"        OnTableChange?.Invoke();" +"        Command.CommandExecutionComplete();" +"" +"    }" +"" +"    private void UpdateTablePlacing()" +"    {" +"        // after a new creature is added update placing of all the other creatures" +"        ShiftSlotsGameObjectAccordingToNumberOfCreatures();" +"        PlaceCreaturesOnNewSlots();" +"    }" +"" +"    private static void AddIDToCreature(int UniqueID, GameObject creature)" +"    {" +"        // add our unique ID to this creature" +"        IDHolder id = creature.AddComponent<IDHolder>();" +"        id.UniqueID = UniqueID;" +"    }" +"" +"    private void AddCreatureToTable(int index, GameObject creature)" +"    {" +"        // add a new creature to the list" +"        CreaturesOnTable.Insert(index, creature);" +"" +"        // let this creature know about its position" +"        WhereIsTheCardOrCreature w = creature.GetComponent<WhereIsTheCardOrCreature>();" +"        w.Slot = index;" +"        w.VisualState = VisualStates.LowTable;" +"    }" +"" +"    private void SetParentForCreature(GameObject creature)" +"    {" +"        // parent a new creature gameObject to table slots" +"        creature.transform.SetParent(slots.transform);" +"    }" +"" +"    private void ApplyTagsOnCreature(GameObject creature)" +"    {" +"        // add tag according to owner" +"        foreach (Transform t in creature.GetComponentsInChildren<Transform>())" +"            t.tag = owner.ToString() + \"Creature\";" +"    }" +"" +"    private static void ReadCardAssetForCreature(CardAsset ca, GameObject creature)" +"    {" +"        // apply the look from CardAsset" +"        OneCreatureManager manager = creature.GetComponent<OneCreatureManager>();" +"        manager.cardAsset = ca;" +"        manager.ReadCreatureFromAsset();" +"    }" +"" +"    private GameObject CreateCreatureGO(int index)" +"    {" +"        return GameObject.Instantiate(GlobalSettings.Instance.CreaturePrefab, slots.Children[index].transform.position, Quaternion.identity) as GameObject;" +"    }" +"" +"    private void DestroyPlaceholder()" +"    {" +"        if (placeHolder != null && CreaturesOnTable.Contains(placeHolder))" +"        {" +"            CreaturesOnTable.Remove(placeHolder);" +"            Destroy(placeHolder);" +"            placeHolder = null;" +"        }" +"    }" +"" +"" +"    // returns an index for a new creature based on mousePosition" +"    // included for placing a new creature to any positon on the table" +"    public int TablePosForNewCreature(float MouseX)" +"    {" +"        // if there are no creatures or if we are pointing to the right of all creatures with a mouse." +"        // right - because the table slots are flipped and 0 is on the right side." +"        int pos = 0;" +"        if (CreaturesOnTable.Count == 0 || MouseX > slots.Children[0].transform.position.x)" +"            return 0;" +"        else if (MouseX < slots.Children[CreaturesOnTable.Count - 1].transform.position.x) // cursor on the left relative to all creatures on the table" +"            pos = CreaturesOnTable.Count;" +"        for (int i = 0; i < CreaturesOnTable.Count; i++)" +"        {" +"            if (MouseX < slots.Children[i].transform.position.x && MouseX > slots.Children[i + 1].transform.position.x)" +"            {" +"                pos = i + 1;" +"                break;" +"            }" +"" +"        }" +"" +"        if (placeHolder != null && CreaturesOnTable.Contains(placeHolder))" +"        {" +"            return Mathf.Clamp(pos - 1, 0, CreaturesOnTable.Count);" +"        }" +"        //Debug.Log(\"Suspicious behavior. Reached end of TablePosForNewCreature method. Returning 0\");" +"        return pos;" +"    }" +"" +"    public static void MassRemoveCreatures(IEnumerable<IGrouping<Player, CreatureLogic>> creatureGroupsByOwner)" +"    {" +"        int totalAnimations = 0;" +"        int completedAnimations = 0;" +"        List<Player> players = new List<Player>();" +"        foreach (var creatureGroup in creatureGroupsByOwner)" +"        {" +"            // creatureGroup.Key is the owner (Player)" +"            Player owner = creatureGroup.Key;" +"            players.Add(owner);" +"            // creatureGroup is the list of creatures belonging to this owner" +"            List<CreatureLogic> creatures = creatureGroup.ToList();" +"            // Count the total number of animations" +"            totalAnimations += creatures.Count;" +"" +"            // Now you can handle each group of creatures separately" +"            // For example, call a method that handles creatures' death for a specific owner" +"            owner.PArea.tableVisual.RemoveCreaturesByIDs(creatureGroup.ToList().Select(c => c.ID).ToList(), () =>" +"            {" +"                // Increment the number of completed animations" +"                completedAnimations++;" +"" +"                // If all animations have completed, call CommandExecutionComplete" +"                if (completedAnimations >= totalAnimations)" +"                {" +"                    players.ForEach(p =>" +"                    {" +"                        p.PArea.tableVisual.ShiftSlotsGameObjectAccordingToNumberOfCreatures();" +"                        p.PArea.tableVisual.PlaceCreaturesOnNewSlots();" +"                        p.PArea.tableVisual.OnTableChange?.Invoke();" +"                    });" +"" +"                    Command.CommandExecutionComplete();" +"                }" +"            });" +"        }" +"    }" +"    // Destroy a creature" +"    public void RemoveCreatureWithID(int IDToRemove)" +"    {" +"        // TODO: Here we visually remove a creature from the board. Use DOTween to slightly shake the position, then perform the rest of the code after the interval (interval should be public and editable from unity)" +"        GameObject creatureToRemove = IDHolder.GetGameObjectWithID(IDToRemove);" +"        creatureToRemove.transform.DOShakePosition(shakeDuration)" +"       .OnComplete(() =>" +"       {" +"           // After the shaking is done, remove and destroy the creature" +"           CreaturesOnTable.Remove(creatureToRemove);" +"           Destroy(creatureToRemove);" +"" +"           ShiftSlotsGameObjectAccordingToNumberOfCreatures();" +"           PlaceCreaturesOnNewSlots();" +"           // Trigger the OnTableChange event" +"           OnTableChange?.Invoke();" +"       });" +"    }" +"    public void RemoveCreaturesByIDs(List<int> IDs, Action onCompletion)" +"    {" +"        List<GameObject> creaturesToRemove = IDHolder.GetGameObjects(IDs);" +"        creaturesToRemove.ForEach(c =>" +"        {" +"            c.transform.DOShakePosition(shakeDuration, 1, 50)" +"                .OnComplete(() =>" +"                {" +"                    // After the shaking is done, remove and destroy the creature" +"                    CreaturesOnTable.Remove(c);" +"                    Destroy(c);" +"                    // Call the completion action" +"                    onCompletion();" +"                });" +"        });" +"    }" +"" +"    /// <summary>" +"    /// Shifts the slots game object according to number of creatures." +"    /// </summary>" +"    void ShiftSlotsGameObjectAccordingToNumberOfCreatures()" +"    {" +"        float posX;" +"        if (CreaturesOnTable.Count > 0)" +"            posX = (slots.Children[0].transform.localPosition.x - slots.Children[CreaturesOnTable.Count - 1].transform.localPosition.x) / 2f;" +"        else" +"            posX = 0f;" +"" +"        slots.gameObject.transform.DOLocalMoveX(posX, 0.3f);" +"    }" +"" +"    /// <summary>" +"    /// After a new creature is added or an old creature dies, this method" +"    /// shifts all the creatures and places the creatures on new slots." +"    /// </summary>" +"    void PlaceCreaturesOnNewSlots()" +"    {" +"        foreach (GameObject g in CreaturesOnTable)" +"        {" +"            g.transform.DOLocalMoveX(slots.Children[CreaturesOnTable.IndexOf(g)].transform.localPosition.x, 0.3f);" +"            // apply correct sorting order and HandSlot value for later " +"            // TODO: figure out if I need to do something here:" +"            // g.GetComponent<WhereIsTheCardOrCreature>().SetTableSortingOrder() = CreaturesOnTable.IndexOf(g);" +"        }" +"    }" +"" +"    public void TriggerOnCreatureEnter(int creatureID)" +"    {" +"        //check for creature etb effect." +"        GameObject creature = IDHolder.GetGameObjectWithID(creatureID);" +"        CardAsset ca = creature.GetComponent<OneCreatureManager>().cardAsset;" +"        CompositeEffect effect = ca.OnCreatureEnterEffect;" +"        StartCoroutine(TriggerCreatureEffect(creatureID, creature, effect, OnCreatureEnterBattlefield));" +"        //TODO: Get DragCreatureAttack component and use it to fetch targets for effect. Then activate OnEnter effect." +"       " +"    }" +"    private IEnumerator TriggerCreatureEffect(int creatureID, GameObject creature, CompositeEffect effect, OnCreatureTrigger creatureEvent) {" +"        if (effect != null)" +"        {" +"            DragCreatureAttack targetSelector = creature.GetComponent<DragCreatureAttack>();" +"            targetSelector.UpdateTargetsMetadataFromEffect(effect);" +"            //now go into the target selection flow" +"            while (targetSelector.selectingTargets)" +"            {" +"                yield return null; // wait until next frame" +"            }" +"            List<int> selectedTargets = targetSelector.GetSelectedTargets();" +"            List<int> idBackups = null;" +"            if (selectedTargets != null)" +"                idBackups = new List<int>(selectedTargets);" +"            List<IIdentifiable> targets = GetCharactersFromIds(idBackups);" +"            Queue<IIdentifiable> targetsQueue = new Queue<IIdentifiable>();" +"            if (targets != null)" +"            {" +"                targets.ForEach(t => targetsQueue.Enqueue(t));" +"            }" +"            Command.PauseQueueExecution();" +"            effect.ActivateEffects(targetsQueue);" +"            Command.ResumeQueueExecution();" +"" +"            //Use selected targets to activate spell effect, similar to how it is done for Player.PlayASpellFromHand" +"        }" +"         creatureEvent?.Invoke(creatureID);" +"" +"    }" +"    private List<IIdentifiable> GetCharactersFromIds(List<int> ids)" +"    {" +"        if (ids == null || ids.Count == 0) return null;" +"        List<IIdentifiable> chars = new List<IIdentifiable>();" +"        foreach (int id in ids)" +"        {" +"            if (id == GlobalSettings.Instance.TopPlayer.PlayerID)" +"            {" +"                chars.Add(GlobalSettings.Instance.TopPlayer);" +"                continue;" +"            }" +"            if (id == GlobalSettings.Instance.TopPlayer.PlayerID)" +"            {" +"                chars.Add(GlobalSettings.Instance.TopPlayer);" +"                continue;" +"            }" +"            chars.Add(CreatureLogic.CreaturesCreatedThisGame[id]);" +"        }" +"        return chars;" +"    }" +"}" 
  }
,
  {
    "fileName": "TestImageRect.cs",
    "relativeFilePath": "Assets/Scripts/Visual/TestImageRect.cs",
    "type": "script",
    "content": "using System.Collections;" +"using System.Collections.Generic;" +"using UnityEngine;" +"" +"public class TestImageRect : MonoBehaviour" +"{" +"    // Start is called before the first frame update" +"    void Start()" +"    {" +"        // Assuming \`image\` is your Image component." +"        RectTransform rectTransform = GetComponent<RectTransform>();" +"" +"        float width = rectTransform.rect.width;" +"        float height = rectTransform.rect.height;" +"" +"        float ratio = width / height;" +"        Debug.Log(\"Width: \" + width);" +"        Debug.Log(\"Height: \" + height);" +"        Debug.Log(\"The width/height ratio is: \" + ratio);" +"    }" +"" +"    // Update is called once per frame" +"    void Update()" +"    {" +"" +"    }" +"}" 
  }
,
  {
    "fileName": "UniqueIdGenerator.cs",
    "relativeFilePath": "Assets/Scripts/Visual/UniqueIdGenerator.cs",
    "type": "script",
    "content": "using System.Collections;" +"using System.Collections.Generic;" +"using UnityEngine;" +"" +"public class UniqueIdGenerator" +"{" +"    private HashSet<int> usedIds;" +"    private int currentMaxId;" +"    private System.Random random;" +"" +"    public UniqueIdGenerator()" +"    {" +"        usedIds = new HashSet<int>();" +"        currentMaxId = 1;" +"        random = new System.Random();" +"    }" +"" +"    public int GenerateUniqueId(int maxId)" +"    {" +"        // If the maxId is greater than the currentMaxId, update the currentMaxId" +"        if(maxId > currentMaxId)" +"        {" +"            currentMaxId = maxId;" +"        }" +"" +"        int newId;" +"        // Generate new ids until we find one that isn't used" +"        do" +"        {" +"            newId = random.Next(1, currentMaxId + 1);" +"        }" +"        while (usedIds.Contains(newId));" +"" +"        // Add the new id to the set of used ids" +"        usedIds.Add(newId);" +"" +"        return newId;" +"    }" +"}" +"" 
  }
,
  {
    "fileName": "WhereIsTheCardOrCreature.cs",
    "relativeFilePath": "Assets/Scripts/Visual/WhereIsTheCardOrCreature.cs",
    "type": "script",
    "content": "﻿using UnityEngine;" +"using System.Collections;" +"using System.Collections.Generic;" +"" +"// an enum to store the info about where this object is" +"public enum VisualStates" +"{" +"    Transition," +"    LowHand, " +"    TopHand," +"    LowTable," +"    TopTable," +"    Dragging" +"}" +"" +"public class WhereIsTheCardOrCreature : MonoBehaviour {" +"" +"    // reference to a HoverPreview Component" +"    private HoverPreview hover;" +"" +"    // reference to a canvas on this object to set sorting order" +"    private Canvas canvas;" +"" +"    // a value for canvas sorting order when we want to show this object above everything" +"    private int TopSortingOrder = 500;" +"" +"    // PROPERTIES" +"    private int slot = -1;" +"    public int Slot" +"    {" +"        get{ return slot;}" +"" +"        set" +"        {" +"            slot = value;" +"            /*if (value != -1)" +"            {" +"                canvas.sortingOrder = HandSortingOrder(slot);" +"            }*/" +"        }" +"    }" +"" +"    private VisualStates state;" +"    public VisualStates VisualState" +"    {" +"        get{ return state; }  " +"" +"        set" +"        {" +"            state = value;" +"            switch (state)" +"            {" +"                case VisualStates.LowHand:" +"                    hover.ThisPreviewEnabled = true;" +"                    break;" +"                case VisualStates.LowTable:" +"                case VisualStates.TopTable:" +"                    hover.ThisPreviewEnabled = true;" +"                    break;" +"                case VisualStates.Transition:" +"                    hover.ThisPreviewEnabled = false;" +"                    break;" +"                case VisualStates.Dragging:" +"                    hover.ThisPreviewEnabled = false;" +"                    break;" +"                case VisualStates.TopHand:" +"                    hover.ThisPreviewEnabled = true;" +"                    break;" +"            }" +"        }" +"    }" +"" +"    void Awake()" +"    {" +"        hover = GetComponent<HoverPreview>();" +"        // for characters hover is attached to a child game object" +"        if (hover == null)" +"            hover = GetComponentInChildren<HoverPreview>();" +"        canvas = GetComponentInChildren<Canvas>();" +"    }" +"" +"    public void BringToFront()" +"    {" +"        canvas.sortingOrder = TopSortingOrder;" +"        //TODO" +"        canvas.sortingLayerName = \"Everything else\";" +"    }" +"" +"    // not setting sorting order inside of VisualStaes property because when the card is drawn, " +"    // we want to set an index first and set the sorting order only when the card arrives to hand. " +"    public void SetHandSortingOrder()" +"    {" +"        if (slot != -1)" +"            canvas.sortingOrder = HandSortingOrder(slot);" +"        canvas.sortingLayerName = \"Cards\";" +"    }" +"" +"    public void SetTableSortingOrder()" +"    {" +"        canvas.sortingOrder = 0;" +"        canvas.sortingLayerName = \"Creatures\";" +"    }" +"" +"    private int HandSortingOrder(int placeInHand)" +"    {" +"        return ((placeInHand + 1) * 10); " +"    }" +"" +"" +"}" 
  }
]}
